/* START LIBRARY DESCRIPTION ***************************************************
*
*   File        : X_SER_HWIO.LIB
*   Description : Library of INIT METHODS FOR XT SYSTEM BOARD HARDWARE REV 1
*   Project     : Colby Instruments Programmable Delay Line X SERIES
*   Date        : MAY 17, 2021
*               : Copyright(c) 2021 Colby Instruments, Bellevue, WA
*   NOTES:      : System Board HW Initialization
*   COMBINE IO_HW AND INIT_HW TO CREATE HWIO.LIB
*
END DESCRIPTION ***************************************************************/

////////////////////////////////////////////////////////////////////////////////

// 06.09.21 XT SYSTEM BUILD - XT_SER_HWIO_B2109.LIB
// 06.09.21 XT SYSTEM BUILD - XT_SER_HWIO_B2109.LIB
// 06.09.21 XT SYSTEM BUILD - XT_SER_HWIO_B2109.LIB

// 06.23.21 added INSTRUMENT.statePENDING_OPC_QUERY_CH2 and 3
// 06.23.21 added stateOPC_CHAR_RECEIVED
// 07.17.21 factory default of CTSTORE use CAL TABLE to ON on reset
// 08.08.21 PC6 SHOULD BE NORMAL FUNCTION
// 08.10.21 ADD HWIO_REL_SetupAndSet_X_ODD TO HANDLE TEN_X AND LAST RELAY SECTION ODD
// 07.26.21 X SERIES FINAL PRODUCTION CODE VERSION 1.00 BUILD 2109 --------------------------------------------------
// 07.30.21 RD073021 BUILD
// 08.04.21 X SERIES FINAL PRODUCTION CODE VERSION 1.00 BUILD 2109 --------------------------------------------------
// 08.06.21 RD080621 BUILD
// 08.17.21 UPDATES TO HWIO_REL APIS, ROUND DOWN BUG AT LAST SECTION (SECTION NOW TURNS OFF FOR TROBONE TO DO REMAINDER)

// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------
// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------
// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------

// 10.05.21 added handle #ifdef DEVICE_XT100_312P
// 10.06.21 RD081621 BUILD
// 10.07.21 INSTRUMENT.Device_Mode == DEVICE_PARALLEL default for DEVICE_XT100_312P
// 10.18.21 START BUILD2112
// 10.22.21 ADD float HWIO_REL_SetupRelaysAndSet_UL(float delay_value) and returns FLOAT with ps and fs
// 11.09.21 HWIO_REL_SetupRelaysAndSet_UL: IF BUILDING FOR DEVICE_XT100_200N THEN HANDLE LAST SECTION RELAY VALUE DIFFERENTLY THAN NORMAL SUBTRACTION

// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------
// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------
// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------

// 11.11.21 BUILD2112_RD102121_RD111121
// 11.13.21 HWIO_Initialize_Variables:  #ifdef DEVICE_XT200_312P INSTRUMENT.stateDEVICE_MODE = DEVICE_PARALLEL; //default is PARALLEL TROMBONE MODE
// 11.13.21 MAX_DELAY_SETTING 312.50 for DEVICE_XT200_312P INSTRUMENT
// 11.15.21 HWIO_FactoryDefault: default IP address is 192.168.100.8, default GW is 192.168.100.1 for STATIC IP
// 11.15.21 HWIO_FactoryDefault: default NM is class C 255.255.255.0
// 11.19.21 HWIO_REL_SetRelays_X_SER: remove (not used) INSTRUMENT.CURRENT_STATE
// 11.19.21 HWIO_FactoryDefault: g_NVParameters.nv_terminal_mode = TRUE; DEFAULT NOW FOR X SERIES

// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------
// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------
// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------

// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------
// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------
// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------

// 03.16.22 ADDED #ifdef XT_BOARD_REV3 AND CHANGES IN HWIO_INIT TO PAR PORT A, C, AND D
// 03.21.22 HWIO_PreInit_XT_HW : SETUP PD0 AS ALT SERCLK OUTPUT FOR TFT DISPLAY
// 03.21.22 added HWIO_Initialize_TFT_Display
// 03.21.22 use ifdef XT_BOARD_REV3 and
// 03.23.22 use ifdef TFT_ATTACHED
// 03.24.22 HWIO_REL_SetRelays_X_SER: set PDM modules added
// 06.01.22 added unsigned char stateFIRST_TIME_INIT_SEQUENCE; IN INSTRUMENT STRUCTURE
// 06.03.22 added unsigned char stateLESS_TO_MORE_DELAY_SETTING; IN INSTRUMENT STRUCTURE

// 08.11.22 COMPARED/MERGED TO B2203 AND TIMING_TEST VERSIONS
// 08.19.22 ADD MAX DELAY SETTING FOR DEVICE_XS100_005N OR DEVICE_XS100_010N
// 08.23.22 COMPARED/MERGED TO B2203 AND TIMING_TEST VERSIONS AND SOURCE CODE VER 1.17
// 08.24.22 ADDED SIZE_CAL_TABLE 2056 FOR XS-100-010N

/*** BeginHeader */
#ifndef X_SER_IO_HW_LIB
#define X_SER_IO_HW_LIB

#ifndef HIGH
#define HIGH 1
#endif

#ifndef LOW
#define LOW 0
#endif

// ALLOW SERIAL PORT B ON PARALLEL PORT PDx PINS
//#define SERB_USEPORTD
// ALLOW SERIAL PORT E ON PARALLEL PORT PE6,7 PINS
#define SERE_TXPORT PEDR
#define SERE_RXPORT PEDR

// SET SIZE OF BUFFERS
#define BINBUFSIZE 31
#define BOUTBUFSIZE 31
#define BBAUD 9600 // was 38400

#define CINBUFSIZE 31
#define COUTBUFSIZE 31
#define CBAUD 9600 // was 38400

#define EINBUFSIZE 31
#define EOUTBUFSIZE 31
#define EBAUD 9600 // was 38400

#define DBAUD 9600 // 03.25.22

// FOR EXTERNAL TRIGGER SIGNAL INTERRUPT
#define RISE_EDGE 0x02
#define FALL_EDGE 0x01
#define BOTH_EDGE 0x03
#define NONE_EDGE 0x00
#define ENABLE 1

#define _XIRQ_PRIORITY 1        // Interrupt priority
#define _XIRQ_EDGE_NONE 0x00    // Bit config for no edge DISABLED
#define _XIRQ_EDGE_RISING 0x02  // Bit config for rising edge
#define _XIRQ_EDGE_FALLING 0x01 // Bit config for falling edge
#define _XIRQ_EDGE_BOTH 0x03    // Bit config for both edges

// #defines FOR I2C RELAY BOARDS
//           B B B //
// 0 0 0 0 0 2 1 0 //
// COMMAND BYTE 0x00    Input Port
//              0x01    Output Port
//              0x02    Polarity Inversion
//              0x03    Configuration
#define INPUT_PORT 0x00
#define OUTPUT_PORT 0x01
#define POL_INV 0x02
#define CONFIG 0x03
#define ZEROES 0x00
#define ALL_ONES 0xFF
#define RELAY_ONE 0x01
#define RELAY_TWO 0x02
#define RELAY_BOTH 0x03
// a0 a1 a2

#define BASE_PCA9534 0x20

// THESE ARE SPECIAL CASE DEFINES FOR REV 1 XT SYSTEM BOARD
// THESE SHOULD BE CHANGED TO BE ADDRESS SEQUENTIALLY STARTING FROM BASE_PCA9543 ADDRESS

#define SECTION_0 BASE_PCA9534 + 0x0
#define SECTION_1 BASE_PCA9534 + 0x1
#define SECTION_2 BASE_PCA9534 + 0x2
#define SECTION_3 BASE_PCA9534 + 0x3
#define SECTION_4 BASE_PCA9534 + 0x4
#define SECTION_5 BASE_PCA9534 + 0x5
#define SECTION_6 BASE_PCA9534 + 0x6
#define SECTION_7 BASE_PCA9534 + 0x7

#define WAIT_MS 80

#define PA0 0
#define PA1 1
#define PA2 2
#define PA3 3
#define PA4 4
#define PA5 5
#define PA6 6
#define PA7 7

#define PC0 0
#define PD0 0

// 03.17.22 MAP THE PHYSICAL PINS ON PARALLEL PORT A TO TFT_ LINES
#ifndef XT_BOARD_REV3
// define ST7789 TFT module pin connections for RCM6700 DEV BOARD
// THESE ARE DEFINED FOR PARALLEL PORT A RCM6700
#define TFT_RST PA7 // reset pin, optional!
#define TFT_DC PA6  // data/command pin
#define TFT_CS PA0  // chip select pin, use it if the display has CS pin
#define TFT_SCK PA1
#define TFT_DIN PA2
#else
// define ST7789 TFT module pin connections for XT BOARD REV 3
#define TFT_RST PA5 // TFT_RST RESET
#define TFT_DC PA3  // TFT_DC DATA/COMMAND
#define TFT_CS 0    // NOT USED
#define TFT_SCK PA1 // TFT_SCK IS ON PD0
#define TFT_DIN PA2 // TFT_MOSI IS ON PC0

#define PDM_LATCH PA3
#define PDM_CLK PD0
#define PDM_DATA PC0
#define XS_LED PA5
#endif

// Some ready-made 16-bit ('565') color settings:
#define ST7789_BLACK 0x0000
#define ST7789_BLUE 0x001F
#define ST7789_RED 0xF800
#define ST7789_GREEN 0x07E0
#define ST7789_CYAN 0x07FF
#define ST7789_MAGENTA 0xF81F
#define ST7789_YELLOW 0xFFE0
#define ST7789_WHITE 0xFFFF

// ERROR CODE DEFINITIONS

#define NO_ERROR 0
#define INVALID_COMMAND 1
#define INVALID_ARG 2
#define NO_CALIBRATION 3
#define DELAY_LIMIT 4
#define DELAY_NOT_SET 5
#define STACK_FULL 6 // added 04.25.07
#define STACK_EMPTY 7
#define INVALID_RESPONSE 8
#define BUFFER_OVERFLOW 99

#define PS 1
#define NS 2
#define ON 1
#define OFF 0
#define DEVICE_SERIAL 1
#define DEVICE_PARALLEL 2
#define DEVICE_HYBRID 3
#define DEVICE_CHANNEL_ONE 4
#define DEVICE_CHANNEL_TWO 5

// 08.01.17 THESE ARE USED FOR XT-200
#define CHANNEL_ONE 1
#define CHANNEL_TWO 2
#define CHANNEL_THREE 3
#define CHANNEL_BOTH 4

#define CHAN_ONE_PS 1
#define CHAN_ONE_NS 2
#define CHAN_TWO_PS 3
#define CHAN_TWO_NS 4
#define CHAN_BOTH_PS 5
#define CHAN_BOTH_NS 6

#define CYCLE_SEQ 1
#define CYCLE_UNIT 2
#define CYCLE_CHANNEL 3

#define MAX_STACK_SIZE 100

#define COMMAND_MAX 500 // 06.18.08
#define BUFFER_MAX 500
#define DISP_LINE_MAX 512
#define cmdARG1_MAX 20
#define cmdARG2_MAX 128
#define cmdARG3_MAX 20

#define INPUT_BUFFER_SIZE_MAX 256 // 05.09.18 was 128, increase to 256 for CTSTOREM command

// SPECIFY MAX_DELAY_SETTING FOR TROMBONE
#ifdef DEVICE_XT100_312P
#define MAX_DELAY_SETTING 312.5
#endif

#ifdef DEVICE_XT100
#define MAX_DELAY_SETTING 625
#endif

// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
#define MAX_DELAY_SETTING 312.5
#endif

#ifdef DEVICE_XT200
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
#define MAX_DELAY_SETTING 312.50
#else
#define MAX_DELAY_SETTING 625.0
#endif
#endif

// 08.19.22
#if defined(DEVICE_XS100_005N)
#define MAX_DELAY_SETTING 5120.0
#else
#if defined(DEVICE_XS100_010N)
#define MAX_DELAY_SETTING 10230.0
#endif
#endif

// INSTRUMENT INTERNALS

#define NVPARAMS_USERBLOCK_LOCATION 0
#define MAGIC_XSUM_BYTE 0x44 // This can be any random number besides 0x00 and 0xFF.

// 01.26.21 TO ADD DHCP_SEND_HOSTNAME FEATURE
#define DHCP_SEND_HOSTNAME

// 04.26.22 ADD SUPPORT FOR XS-100
#if defined(DEVICE_XS100_005N)
// 04.26.22 FOR XS-100 AT 1 PS STEP RESOLUTION
#define SIZE_CAL_TABLE 5125
#else
#if defined(DEVICE_XS100_010N)
#define SIZE_CAL_TABLE 2056
#else
// 04.30.18 change from 6251 to 1251 (0 to 625.0 ps with 0.50 ps step resolution)
#define SIZE_CAL_TABLE 1251
#endif
#endif

#define SIZE_CAL_INFO_FIELD 240

// RD03 TOP_TO_BOTTOM_NEW_LED ADDED USE THIS FOR NEW LED
#define TOP_TO_BOTTOM_NEW_LED

// RD02 ENABLE NET STATUS FOR GLOBAL VARIABLE FOR LED
#define NET_STATUS

// NEW MOTOR DEFINITIONS
#define CINBUFSIZE 31
#define COUTBUFSIZE 31

// MAX STEPS
// 05.28.21 assume 625 #define MAX_NUMBER_MOTOR_STEPS 520312
// 05.28.21 UPDATED FOR NEW XT_SYSTEM OPTICAL DETECTOR POSITION
#define MAX_NUMBER_MOTOR_STEPS 524475

// 09.01.21
//#define MOTOR_STEPS_PER_ONE_PS 832.5
#define MOTOR_STEPS_PER_ONE_PS 830.5

// 09.01.21
//#define MOTOR_STEPS_PER_FIVE_PS 4162.5
#define MOTOR_STEPS_PER_FIVE_PS 4152.50

// 3000 ms to move one MIN delay to MAX delay wait time // 02.03.18 change to 4000
#define MIN_MAX_MOTOR_WAIT_TIME 4000

#define SC_CODE_MOTOR_ENABLED 0x0001
#define SC_CODE_DRIVE_FAULT 0x0004
#define SC_CODE_IN_POSITION 0x0008
#define SC_CODE_ALARM_PRESENT 0x0200

#define AL_CODE_POS_LIMIT 0x0001
#define AL_CODE_CCW_LIMIT 0x0002
#define AL_CODE_CW_LIMIT 0x0004
#define AL_CODE_OVER_TEMP 0x0008
#define AL_CODE_COMM_ERROR 0x0400
#define AL_CODE_NO_MOVE 0x1000

#define DI_STOP_DISTANCE_AFTER_SENSOR 1
#define HALF_SEC 500
#define ONE_SEC 1000
#define MAX_CALIBRATION_POINTS 315
#define CAL_PTS_ZERO_TO_TWO 21

#define WAIT 1
#define NOWAIT 0

#define REMOTE 1
#define LOCAL 0

/*** EndHeader */

/*** BeginHeader

HWIO_ShiftRegBarGraphInitXT,
HWIO_ShiftRegBarGraphOutputXT,
HWIO_BarGraphSetHighDataBitXT,
HWIO_BarGraphSetLowDataBitXT,
HWIO_BarGraphToggleClockBit,
HWIO_Flip_UL_Word,
HWIO_Test_EXT_IRQ,
HWIO_SendToRelayBoard,
HWIO_Init_SerialPorts,
HWIO_msDelay,
HWIO_PreInit_XT_HW,
HWIO_FactoryDefault,

HWIO_Initialize_SerialPortsXT,
HWIO_Initialize_Variables,
HWIO_Initialize_Ethernet,
HWIO_Initialize_InstrumentVariables,
HWIO_Initialize_BarGraphXT,
HWIO_Initialize_PDM_SREG_XS,
HWIO_Initialize_RelaysXT,
HWIO_Initialize_XIRQ,
HWIO_Initialize_TFT_Display,
HWIO_EnableDisable_XIRQ,
HWIO_REL_SetRelays_X_SER,
HWIO_REL_SetupRelaysAndSet,
HWIO_REL_SetupRelaysAndSet_UL,
HWIO_REL_SetupAndSet_X,
HWIO_REL_SetupAndSet_X_ODD,
HWIO_FlipByte,
HWIO_REL_BitTestSetRelay,
HWIO_my_isr1()
*/

/* Variables and functions in here are public access */
void HWIO_ShiftRegBarGraphInitXT(void);
void HWIO_ShiftRegBarGraphOutputXT(unsigned long);
void HWIO_BarGraphSetHighDataBitXT(void);
void HWIO_BarGraphSetLowDataBitXT(void);
void HWIO_BarGraphToggleClockBit(void);
unsigned long HWIO_Flip_UL_Word(unsigned long fourbytes);
void HWIO_Test_EXT_IRQ(void);
void HWIO_SendToRelayBoard(char _RegAddress, char _RelaySectionNumber, char _RegData);
void HWIO_Init_SerialPorts(void);
void HWIO_msDelay(unsigned int delay);
void HWIO_PreInit_XT_HW(void);
void HWIO_FactoryDefault(void);

void HWIO_Initialize_SerialPortsXT(void);
void HWIO_Initialize_Variables(void);
void HWIO_Initialize_Ethernet(void);
void HWIO_Initialize_InstrumentVariables(void);
void HWIO_Initialize_BarGraphXT(void);
void HWIO_Initialize_PDM_SREG_XS(void); // new added 03.24.22
void HWIO_Initialize_RelaysXT(void);
void HWIO_Initialize_XIRQ(char _EdgeType);
void HWIO_Initialize_TFT_Display(void);
void HWIO_EnableDisable_XIRQ(char _Enable);

unsigned char HWIO_FlipByte(unsigned char byte);
char HWIO_REL_BitTestSetRelay(char _BitPosition, unsigned short _Relays);
void HWIO_REL_SetRelays_X_SER(unsigned int Relays);                                                                            // replaces HWIO_RelaySetRelayXT
float HWIO_REL_SetupRelaysAndSet(float delay_value);                                                                           // replaces HWIO_RelaySetupRelaysAndSet
float HWIO_REL_SetupRelaysAndSet_UL(float delay_value, unsigned long _DelaySetting_NPS_UL, unsigned long _DelaySetting_FS_UL); // 10.22.21 NEW FOR DEVICE_XT100_200N
float HWIO_REL_SetupAndSet_X(float delay_value);                                                                               // replaces HWIO_RelaySetupRelaysAndSet_X
float HWIO_REL_SetupAndSet_X_ODD(float delay_value);
nodebug root interrupt void HWIO_my_isr1();

/*** EndHeader */

// These defines are specified in the Dynamic C function reference manual.
#define SER_CLK_C_DIV 255 // Set the clock divisor to max value for slowest speed

// FOR XT
#define HW3V1_BAR_GRAPH_SR_LOAD PA0
#define HW3V1_BAR_GRAPH_SR_CLOCK PA1
#define HW3V1_BAR_GRAPH_SR_DATA PA2
//

void HWIO_ShiftRegBarGraphInitXT(void)
{
    /*  Desc:       Initializes the OUTPUT pins to send to the Bar Graph
     *   Args:       None.
     *   Returns:    None.
     *   Prereq:     None.
     *   Globals:    None.
     *   Side E:     Sets up port
     *   Notes:
     *   FOR XT_SYSTEM_BOARD REV2
     *   PA0 is the SR LOAD BARGRAPH
     *   PA1 is the SR CLOCK BARGRAPH
     *   PA2 is the SR_DATA BARGRAPH
     */

    // SETUP PARALLEL PORT A AS ALL OUTPUTS
    WrPortI(SPCR, &SPCRShadow, 0x84); // HW3V1

    // SET ALL LINES TO LOW
    BitWrPortI(PADR, &PADRShadow, LOW, HW3V1_BAR_GRAPH_SR_CLOCK); // HW3V1 // LOW
    BitWrPortI(PADR, &PADRShadow, LOW, HW3V1_BAR_GRAPH_SR_LOAD);  // HW3V1 // LOW
    BitWrPortI(PADR, &PADRShadow, LOW, HW3V1_BAR_GRAPH_SR_DATA);  // HW3V1 // LOW

#ifdef XT_BOARD_REV1
    // ASSERT THIS PORT LINE HIGH (PA3) SINCE CANNOT REMOVE JUMPER FROM R22
    // IF NEED TO READ DEFAULT SWITCH CORRECTLY
    BitWrPortI(PADR, &PADRShadow, TRUE, PA3); // HIGH FOR PA3
                                              // TEMPORARY FIX UNTIL SYSTEM BOARD REV 2 IS READY
#endif

} /* end HWIO_ShiftRegBarGraphInitXT */

void HWIO_ShiftRegBarGraphOutputXT(unsigned long BarGraphData)
{
#if defined(XT_BOARD_REV2)
    /*  Description: This function outputs data to the Bar Graph LED display.  Up to
    20 bits of data is displayed from left (MSB) Left TO (LSB) Right.

    1. SL B == shift load : set this to HIGH to allow LOADING to occur
    2. SR DATA B == set the bit to 0 or 1 depending on the data
    3. CLOCK it ... LOW to HIGH transition allows the bit to be clocked and shifted
    4. SL B == shift load: set this to LOW to finish LOADING

   HW3RD01

    XT system board REV 2 uses the following IO lines:
    PA0    : SL B       // set HIGH to allow loading to occur, then set LOW
    PA1    : SR CLK B   // low to high transition allows the bit to be clocked and shifted
    PA2    : SR DATA B  // data bit

*   Args:    None.
*   Returns: None.
*   Prereq:
*   Globals: None.
*   Notes:   None.
*   BarGraphData is unsigned long 32 bits wide.
*  MSB                                                                                          LSB
*  32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01
*  -- -- -- -- -- -- -- -- -- -- -- NN XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
*  -- = UNUSED/IGNORED
*  XX = 0 OR 1
*  NN = NETWORK STATUS LED BIT 21
*/

    int _i;
    int _BitNumber;
    unsigned long _BitDetectionMask;
    unsigned long _Result;
    _i = 0;
    _BitNumber = 1;
    _BitDetectionMask = 0x00000001;
    _Result = 0x00000000;

    // IF THIS IS A 21 BIT LED X CHASSIS, FIRST BIT IS THE LED LAN BIT
    if (INSTRUMENT_SETTINGS.CURRENT_LAN_LED_STATUS)
    {
        // HIGH
        HWIO_BarGraphSetHighDataBitXT();
        HWIO_BarGraphToggleClockBit();
    }
    else
    {
        // LOW
        HWIO_BarGraphSetLowDataBitXT();
        HWIO_BarGraphToggleClockBit();
    }

    //
    // SHIFT all the data bits into the register by CLOCKing each bit
    //
    for (_BitNumber = 20; _BitNumber >= 1; _BitNumber--)
    {
        _BitDetectionMask = 0x00000001;
        _BitDetectionMask = _BitDetectionMask << (_BitNumber - 1);

        _Result = _BitDetectionMask & BarGraphData;
        if (_Result != 0x00000000)
        {
            // HIGH
            HWIO_BarGraphSetHighDataBitXT();
            HWIO_BarGraphToggleClockBit();
        }
        else
        {
            // LOW
            HWIO_BarGraphSetLowDataBitXT();
            HWIO_BarGraphToggleClockBit();
        }
    }

    //
    // After all the data bits are in the register, toggle the LOAD line to
    // have them display into the LEDs
    // Set SR_LOAD to HIGH for loading

    // TOGGLE LOAD LINE
    BitWrPortI(PADR, &PADRShadow, HIGH, HW3V1_BAR_GRAPH_SR_LOAD); // HW3V2 // HIGH
    HWIO_msDelay(1);                                              // HW3V2 // MUST PUT THIS DELAY IN HERE BECAUSE RCM6700 IS TOO FAST
    BitWrPortI(PADR, &PADRShadow, LOW, HW3V1_BAR_GRAPH_SR_LOAD);  // HW3V2 // LOW

    return;
#endif
} /* end HWIO_ShiftRegBarGraphOutputXT */

void HWIO_BarGraphSetHighDataBitXT(void)
{
#if defined(XT_BOARD_REV2)
    /* Set HIGH */
    // BitWrPortI(PGDR, &PGDRShadow, 1, BAR_GRAPH_SR_DATA); // USE PG2 IF USING SPI FROM LIB //
    BitWrPortI(PADR, &PADRShadow, HIGH, HW3V1_BAR_GRAPH_SR_DATA); // HW3V2 // HIGH
#endif
}

void HWIO_BarGraphSetLowDataBitXT(void)
{
#if defined(XT_BOARD_REV2)
    /* Set LOW */
    // BitWrPortI(PGDR, &PGDRShadow, 0, BAR_GRAPH_SR_DATA); // USE PG2 IF USING SPI FROM LIB //
    BitWrPortI(PADR, &PADRShadow, LOW, HW3V1_BAR_GRAPH_SR_DATA); // HW3V2 // LOW
#endif
}

void HWIO_BarGraphToggleClockBit(void)
{
#if defined(XT_BOARD_REV2)
    /* Set LOW */                                                 // set CLOCK to 0
    BitWrPortI(PADR, &PADRShadow, LOW, HW3V1_BAR_GRAPH_SR_CLOCK); // HW3V2 // LOW
    HWIO_msDelay(1);
    /* Set HIGH */                                                 // set CLOCK to 1
    BitWrPortI(PADR, &PADRShadow, HIGH, HW3V1_BAR_GRAPH_SR_CLOCK); // HW3V2 // HIGH
    HWIO_msDelay(1);
    /* Set LOW */                                                 // set CLOCK to 0
    BitWrPortI(PADR, &PADRShadow, LOW, HW3V1_BAR_GRAPH_SR_CLOCK); // HW3V2 // LOW
#endif
}

unsigned long HWIO_Flip_UL_Word(unsigned long _BarGraphFourBytes)
{
    //
    //  Desc:   Flips the 20 bits of the unsigned long _BarGraphFourBytes in reverse order
    //          input byte such that the input LSB is the returned MSB and vice-versa
    //  Note:   this does not take into account the NETWORK LED yet ... TBD

    unsigned long _CompareWith;
    unsigned long _FinalResult;
    unsigned long _BitItemToAdd;
    unsigned long _TestResult;
    int _Index;
    int _BitNumber;
    int _Temp;

    _Temp = 0;
    _FinalResult = 0x00000000;
    _BitItemToAdd = 0x00000000;
    _CompareWith = 0x00000000;
    _BitNumber = 0;

    for (_Index = 0; _Index < 20; _Index++)
    {

        _BitNumber = 19 - _Index;
        _CompareWith = 0x00000001;
        _CompareWith = (_CompareWith << _BitNumber);

        _TestResult = (_BarGraphFourBytes & _CompareWith);

        if (_TestResult != 0x00000000)
        {
            // temp |= 1<<(index);
            _BitItemToAdd = 0x00000001;
            _BitItemToAdd = (_BitItemToAdd << _Index);
            _FinalResult = _FinalResult + _BitItemToAdd; // adding the bit is same as turning it on
        }
    }
    return _FinalResult;

} // end HWIO_Flip_UL_Word

void HWIO_Test_EXT_IRQ(void)
{

    char _LastValue;
    char _Bit;

    //_INT_COUNT = 0;
    // INSTRUMENT.EXT_HW_INT_COUNT = 0 ;

    // PARALLEL PORT D
    // WrPortI(PDDDR, &PDDDRShadow, PDDDRShadow | 0x00); // set port D as all inputs

    _LastValue = 0;
    _Bit = 0;

    HWIO_Initialize_XIRQ(_XIRQ_EDGE_RISING);

    // test the Interrupt int
    // while (INSTRUMENT.EXT_HW_INT_COUNT < 5)
    //{
    //
    //  // output the interrupt count every second
    //  costate
    //  {
    //      printf("counts = %3d \n", INSTRUMENT.EXT_HW_INT_COUNT);
    //      waitfor(DelaySec(1));
    //  }
    //}

    // 05.05.22 WHY DISABLE ? // NEED TO PROVIDE COMMAND ENABLE/DISABLE INTERRUPTS
    // WrPortI(I1CR, &I1CRShadow, 0x00); // disable external interrupt 1
}

void HWIO_Initialize_XIRQ(char _EdgeType)
{
    int temp;
    int _RetVal;

    INSTRUMENT.EXT_HW_EDGE_TYPE = _EdgeType;

    // COPY OF CODE FROM REFACTOR_BASE_XT_LIBRARY
    // ==>> Test the hardware external interrupt code here ...

    _RetVal = SetVectExtern(1, HWIO_my_isr1);

    // re-setup ISR's to show example of retrieving ISR address using GetVectExtern
    //_RetVal = SetVectExtern(1, GetVectExtern(1));

    //#define _XIRQ_PRIORITY        1           // Interrupt priority
    //#define _XIRQ_EDGE_NONE       0x00        // Bit config for no edge DISABLED
    //#define _XIRQ_EDGE_RISING     0x02        // Bit config for rising edge
    //#define _XIRQ_EDGE_FALLING    0x01        // Bit config for falling edge
    //#define _XIRQ_EDGE_BOTH       0x03

    // FROM SAMPLE CODE RCM6700 DEV BOARD
    // WrPortI(I1CR, &I1CRShadow, _EdgeType); // enable external INT1 on PD1, RISING edge, priority 1
    // 0x81 ... need to generalize this to handle macros
    //

    // Set temp bits for init. call
    temp = (_EdgeType << 6) | _XIRQ_PRIORITY; // 10.29.08

    // Set interrupt edge and priority
    WrPortI(I1CR, &I1CRShadow, temp);
}

void HWIO_Initialize_TFT_Display(void)
{
// 03.23.22 ONLY REV3 BOARD HAS THE TFT ATTACHED
#if defined(XT_BOARD_REV3)

#if defined(TFT_ATTACHED)

    char _Text[20];

    SPIinit(); // INITIALIZE THE SPI INTERFACE HARDWARE
    ginit();   // INITIALIZE THE TFT OLED DISPLAY

    // SETUP THE VIEWPORT FOR MAIN FULL SCREEN
    gsetupvp(VIEWPORT_MAIN, TFT_X, TFT_Y, TFT_X320, TFT_Y240, &arial24x, NULL, GNORMAL); // USE arial24x_code.c
    gselvp(VIEWPORT_MAIN);                                                               // select viewport 1
    gsetvp(TFT_X, TFT_Y, TFT_X320, TFT_Y240);                                            // SET FOR LANDSCAPE MODE

    // SETUP THE VIEWPORT FOR CH1
    gsetupvp(VIEWPORT_CH1, TFT_X, TFT_Y, TFT_X320, 60, &arial24x, NULL, GNORMAL);
    gselvp(VIEWPORT_CH1);
    gsetvp(TFT_X, TFT_CH1_QUAD_LINE_START, TFT_X320, TFT_CH1_QUAD_LINE_END);

#if defined(DEVICE_XT200)
    // SETUP THE VIEWPORT FOR CH2
    gsetupvp(VIEWPORT_CH2, TFT_X, TFT_Y, TFT_X320, 60, &arial24x, NULL, GNORMAL);
    gselvp(VIEWPORT_CH2);
    gsetvp(TFT_X, TFT_CH2_QUAD_LINE_START, TFT_X320, TFT_CH2_QUAD_LINE_END);
#endif

    // SETUP THE VIEWPORT FOR NETWORK
    gsetupvp(VIEWPORT_NET, TFT_X, TFT_Y, TFT_X320, 60, &arial24x, NULL, GNORMAL); // NETWORK ICON AND TEXT // VIEWPORT SIZE OF 320w AND 60h
    gselvp(VIEWPORT_NET);
    gsetvp(TFT_X, TFT_NET_QUAD_LINE_START, TFT_X320, TFT_NET_QUAD_LINE_END); // LOCATION OF VIEWPORT BETWEEN QUAD2 AND QUAD3

    // DRAW THE COLBY LOGO AND TEXT DISPLAY
    gselvp(VIEWPORT_MAIN); // SELECT MAIN VIEWPORT (FULL SCREEN)
                           // 06.09.22 ADD WHITE BACKGROUND TO ENHANCE LOGO AND TEXT
    gsetcolorb(G_WHITE);
    gfillvp(TFT_X, QUAD1PT5, 320, QUAD3PT5, 0X0000);

    // DRAW THE BITMAP
    GFX_DrawBitmap(TFT_LOGO_X, TFT_LOGO_Y, COLBY_LOGO, 64, 48, G_BLUE); // INVERTED 48X48 AT 96DPI
    gsetpos(TFT_LOGO_TEXT_X, TFT_LOGO_TEXT_Y);
    gsetcolorf(G_BLUE);
    gputs("Colby Instruments");

    if (MAIN_CheckFactoryReset() == TRUE) // 05.24.22 ADD THIS CHECK TO SEE IFA
    {
        gsetpos(TFT_RESET_DEFAULT_TEXT_X, TFT_RESET_DEFAULT_TEXT_Y);
        sprintf(_Text, " RESET TO DEFAULT SETTINGS ");
        gsetcolorf(G_RED); // 06.09.22 RED TEXT
        gputs(_Text);

        // INDICATE THE FACTORY DEFAULT BUTTON WAS PRESSED
        INSTRUMENT.stateFACTORY_DEFAULT_PRESSED = TRUE; // FLAG THIS CONDITION
    }

    gsetcolorf(G_BLACK); // 06.09.22 BLACK FOR TEXT

    gsetpos(TFT_LOGO_MODEL_X, TFT_LOGO_MODEL_Y);
    sprintf(_Text, "%s-%s", deviceMODEL, deviceIDN_DISPLAY);
    gputs(_Text);

    gsetpos(TFT_LOGO_SN_X, TFT_LOGO_SN_Y);
    sprintf(_Text, "%s", deviceSN);
    gputs(_Text);

#endif

#endif
}

void HWIO_EnableDisable_XIRQ(char _Enable)
{
    // enable or disable the XIRQ interrupt 1
    // Set bits as needed to enable / disable interrupt

    if (_Enable == TRUE)
    {
        // Enable the interrupt
        // change for IRQ1 on XT Sytem Board
        WrPortI(I1CR, &I1CRShadow, I1CRShadow | _XIRQ_PRIORITY); // Write value to register

    } // end if
    else
    {
        // Disable interrupt
        // change for IRQ1 on XT Sytem Board
        WrPortI(I1CR, &I1CRShadow, I1CRShadow & 0xFC); // Write value DISABLE EXTERNAL INTERRUPT
    }                                                  // end else
}

void HWIO_SendToRelayBoard(char _RegAddress, char _RelaySectionNumber, char _RegData)
{
#if (defined(DEVICE_XT100) || defined(DEVICE_XR100))
    int _ReturnCode; // int

    char _RegisterAddress;  // byte
    char _RegisterData;     // byte
    unsigned long _t_TIMER; // unsigned long for Timer

    //           B B B //
    // 0 0 0 0 0 2 1 0 //
    // COMMAND BYTE 0x00    Input Port
    //              0x01    Output Port
    //              0x02    Polarity Inversion
    //              0x03    Configuration

    _RegisterAddress = _RegAddress;                      // Register Address
    _RegisterData = _RegData;                            // Register Data
    _ReturnCode = I2C_WriteToSlave(_RelaySectionNumber,  // RELAY ADDRESS
                                   &_RegisterAddress, 1, // REGISTER
                                   &_RegisterData, 1,    // data and data len
                                   1, 5);                // blocking mode, 5 ms timeout
    _t_TIMER = MS_TIMER;
    while ((long)(MS_TIMER - _t_TIMER) < WRITE_TIME)
        ;

#endif

} // end HWIO_SendToRelayBoard()

void HWIO_Init_SerialPorts(void)
{
    /*  Desc:       Initializes serial ports B and E for use with the IEEE IFB Hardware.
     *  Args:       None.
     *  Returns:    None.
     *  Prereq:     None.
     *  Globals:    None.
     *  Side E:     Serial ports B, C and E will be turned on.
     *  Notes:      The above #defines must be set properly as specified in the Dynamic C
     *              documentation.
     */

    // Initialize Serial Port B
    serBopen(BBAUD); // SECOND PORT ON SYSTEM BOARD (TO SECONDARY TROMBONE)

    // Initialize Serial Port C
    serCopen(CBAUD); // SERIAL PORT C IS FOR THE NEW HYBRID MOTOR

    // Initialize Serial Port E
    serEopen(EBAUD); // FOR MT-100A ATTACHED VIA POWER BOARD

} // end HWIO_Init_SerialPorts

void HWIO_msDelay(unsigned int delay)
{
    /*  Desc:       Blocks for a specified number of milliseconds (ms).
     *   Args:       unsigned int delay, the number of ms to block for.
     *   Returns:    None.
     *   Prereq:     None.
     *   Globals:    MS_TIMER
     *   Side E:     None.
     *   Notes:      None.
     */

    auto unsigned long start_time;

    start_time = MS_TIMER;
    while ((MS_TIMER - start_time) < (unsigned long)delay)
        ;

} /* end HWIO_msDelay */

void HWIO_PreInit_XT_HW(void)
{

    // RD042721 // CHANGE FOR XT-HW SYSTEM BOARD REVISION 2
    // PARALLEL PORT A
    //---------------------------------------------------------------------
    // PA7  (LATCH RELAY)       OUTPUT     CONNECTED TO PXX PIN #    HW1VER2
    // PA6  NOT USED            OUTPUT
    // PA5  (OE RELAY)          OUTPUT     CONNECTED TO PXX PIN #    HW1VER2
    // PA4  MASTER              OUTPUT     MASTER (PRIMARY TROMBONE) OR NOT FOR TTL TXD/RXD
    // PA3  NOT USED            OUTPUT
    // PA2  SR_DATA BARGRAPH    OUTPUT   -- CONNECTED TO XT J5 PIN 4
    // PA1  SR CLOCK BARGRAPH   OUTPUT   -- CONNECTED TO XT J5 PIN 2
    // PA0  SR LOAD BARGRAPH    OUTPUT   -- CONNECTED TO XT J5 PIN 3
    //---------------------------------------------------------------------

    // 03.16.22 XT SYSTEM BOARD REV 3
    //
    //----------------------------------TFT ATTACHED -------XSPDM_ATTACHED--
    // PA7  UNUSED              OUTPUT  UNUSED              UNUSED
    // PA6  UNUSED              OUTPUT  UNUSED				UNUSED
    // PA5  TFT_RESET           OUTPUT  TFT_RESET           XS_LED
    // PA4  MASTER              OUTPUT  MASTER (PRIMARY TROMBONE) OR NOT FOR TTL TXD/RXD
    // PA3  TFT_DC              OUTPUT  TFT_DC              PDM_LATCH
    // PA2  UNUSED              OUTPUT  UNUSED
    // PA1  UNUSED              OUTPUT  UNUSED
    // PA0  UNUSED              OUTPUT  UNUSED
    //---------------------------------------------------------------------
    //

    // SETUP PARALLEL PORT A AS ALL OUTPUTS
    WrPortI(SPCR, &SPCRShadow, 0x84); // HW3V2

    // /* local defines */
    //#define OUTPUT 1
    //#define INPUT 0

#ifdef XT_BOARD_REV1
    // 042721 - BUG WORKAROUND
    // ASSERT THIS PORT LINE HIGH (PA3) SINCE CANNOT REMOVE JUMPER FROM R22
    BitWrPortI(PADR, &PADRShadow, TRUE, 3); // HIGH FOR PA3
#endif

// 08.05.21
// INTERCONNECT CABLE BETWEEN PRIMARY AND SECONDARY TROMBONE IS STRAIGHT THRU
// SO CHANGE THE CONTROLLING BIT ON MASTER TO TRUE HIGH ELSE ON SECONDARY TO FALSE LOW
#ifdef SECONDARY_TROMBONE
    BitWrPortI(PADR, &PADRShadow, LOW, PA4); // LOW FOR NON-MASTER // SECONDARY TROMBONE
#else
    BitWrPortI(PADR, &PADRShadow, HIGH, PA4); // HIGH FOR MASTER // PRIMARY TROMBONE AND SINGLE TROMBONE
#endif

    // PARALLEL PORT B
    //---------------------------------------------------------------------
    // PB7  NOT USED        INPUT DEFAULT
    // PB6  NOT USED        INPUT DEFAULT
    // PB5  NOT USED        INPUT DEFAULT
    // PB4  NOT USED        INPUT DEFAULT
    // PB3  NOT USED        INPUT DEFAULT
    // PB2  SW2 FACTORY DEF (SINK TO GND ON PRESS)  INPUT DEFAULT
    // PB1  NOT USED        OUTPUT DEFAULT
    // PB0  NOT USED        OUTPUT DEFAULT
    //---------------------------------------------------------------------

    // PARALLEL PORT C                      PCFR
    //---------------------------------------------------------------------
    // PC7                      INPUT       NORMAL
    // PC6                      OUTPUT      NORMAL
    // PC5  SERIAL PORT B RX    INPUT       NORMAL  // FROM RS232 SERIAL PORT B
    // PC4  SERIAL PORT B TX    OUTPUT      ALT     // TO RS232 SERIAL PORT B
    // PC3  SERIAL PORT C RX    INPUT       NORMAL  // FROM MOTOR PORT C
    // PC2  SERIAL PORT C TX    OUTPUT      ALT     // TO MOTOR PORT C
    // PC1                                  NORMAL  // NOT USED
    //
    // PC0  NOT USED            OUTPUT      ALT     // XT_BOARD_REV2
    // PC0  TFT_MOSI DATA       OUTPUT      ALT     // XT_BOARD_REV3 + TFT_ATTACHED
    // PC0  PDM_CLK             OUTPUT      NORMAL  // XT_BOARD_REV3 + XSPDM_ATTACHED
    //---------------------------------------------------------------------

    // Port C 6,4,2,0 : used as outputs. (0b01010101 = 0x55)
    // BIT 0,2,4,6 OUTPUT AND 1,3,5,7 INPUT
    // BIT 6 used as OUTPUT for serial debugging
    WrPortI(PCDDR, &PCDDRShadow, PCDDRShadow | 0x55);

    // PCALR 0bxx00xx00
    WrPortI(PCALR, &PCALRShadow, PCALRShadow | 0x00);

    // PCAHR 0bxxxxxx00
    WrPortI(PCAHR, &PCAHRShadow, PCAHRShadow | 0x00);

    // INCORRECT...
    // PCFR  0b00101000 PORT C FUNCTION REGISTER
    // WrPortI(PCFR, &PCFRShadow, PCFRShadow | 0xE8);

    // PCFR  0b01010101 PORT C FUNCTION REGISTER
    // WrPortI(PCFR, &PCFRShadow, PCFRShadow | 0x55);

#if !defined(XT_BOARD_REV3)
    // 08.06.21 // PC6 SHOULD BE NORMAL
    // PCFR  0b00010101 PORT C FUNCTION REGISTER  - PC0,PC2,PC4 == ALT
    WrPortI(PCFR, &PCFRShadow, PCFRShadow | 0x15);
#else
    // XT_BOARD_REV3 ... DETERMINE TFT_ATTACHED OR XSPDM_ATTACHED

#if (defined(TFT_ATTACHED) || defined(XSPDM_ATTACHED))
    // PCFR  0b00010101 PORT C FUNCTION REGISTER - PC0,PC2,PC4 == ALT
    WrPortI(PCFR, &PCFRShadow, PCFRShadow | 0x15);
#endif
    //#ifdef XSPDM_ATTACHED
    //// PCFR  0b00010100 PORT C FUNCTION REGISTER - PC2,PC4 == ALT
    //// PC0 IS NORMAL AND USE AS PDM_CLK
    // WrPortI(PCFR, &PCFRShadow, PCFRShadow | 0x14);
    //#endif

#endif

    // SERIAL PORTS B,C,D AND E

    // SERIAL PORT B FOR RS-232 COMM TO SEC TROMBONE
    // USES PC4 (NORMAL) FOR TXB AND PC5 (ALT) FOR RXB
    // SBCR  0b00000000
    WrPortI(SBCR, &SBCRShadow, SBCRShadow | 0x00);

    // SERIAL PORT C FOR HYBRID MOTOR
    // USES PC2 (NORMAL) FOR TXC AND PC3 (ALT) FOR RXC
    // SCCR  0b00000000
    WrPortI(SCCR, &SCCRShadow, SCCRShadow | 0x00);

    // SERIAL PORT D
    // USES PC0 (NORMAL) FOR TXD TO REL DATA
    // USES PD0 (ALT) FOR SERIAL DATA CLOCK TO REL
    // SERIAL D INPUT RECEIVER IS DISABLED (NOT USED)
    // SDCR  0b00110000
    WrPortI(SDCR, &SDCRShadow, SDCRShadow | 0x30);

    // SERIAL PORT E FOR MT-100A MICROTERMINAL
    // USES PE6 (ALT) FOR SERIAL TXE AND PE7 (ALT) FOR RXE
    // SECR  0b00100000
    WrPortI(SECR, &SECRShadow, SECRShadow | 0x20);

    // PARALLEL PORT D                  PDFR
    //---------------------------------------------------------------------
    // PD7
    // PD6
    // PD5
    // PD4
    // PD3
    // PD2
    // PD1  USE AS INTERRUPT INPUT I1CR
    // PD0  SERIAL D REL CLOCK  OUTPUT  ALT // REMOVED NOT USED
    //---------------------------------------------------------------------
    // 03.16.22 XT SYSTEM BOARD REV 3
    // PD0  TFT_SCK CLOCK       OUTPUT  ALT //

#if defined(XT_BOARD_REV2)
    // Port D 1 : used as output (0b00000001 = 0x01)
    // WrPortI(PDDDR, &PDDDRShadow, PDDDRShadow | 0x01);

    // 04.30.21
    // PD1 : use as input for interrupt (0b00000000 = 0x00)
    WrPortI(PDDDR, &PDDDRShadow, PDDDRShadow | 0x00); // 0 = input, 1 = output

    // PDALR 0bxxxxxx00 : SERIAL CLOCK D PD0 ALT OUTPUT
    // WrPortI(PDALR, &PDALRShadow, PDALRShadow | 0x00);

    // PDFR  0b00000001 PORT D FUNCTION REGISTER : BIT 0 AS ALT SERCLK OUTPUT
    // WrPortI(PDFR, &PDFRShadow, PDFRShadow | 0x01);
    // 04.27.21
    WrPortI(PDFR, &PDFRShadow, PDFRShadow | 0x00); // 0x00 function normally
#else

    // THIS IS FOR XT_BOARD_REV3
    // SPECIFY #define TFT_ATTACHED or #define XSPDM_ATTACHED

#if (defined(TFT_ATTACHED) || defined(XSPDM_ATTACHED))
    // TFT_ATTACHED and XSPDM_ATTACHED USE SPI AND SERIAL CLOCK
    // SETUP PARALLEL PORT D
    // THIS WILL SETUP PD0 AS OUTPUT AND PD1 BIT AS INPUT

    // 03.24.22
    // PD1 : USE AS INPUT FOR INTERRUPT (0b00000000 = 0x00)
    // PD0 : USE AS OUTPUT FOR SPI CLOCK SERIAL D TXD ... SCK CONTROL LINE
    WrPortI(PDDDR, &PDDDRShadow, PDDDRShadow | 0x01); // 0 = input, 1 = output

    // 03.24.22
    // THIS WILL SETUP PD0 AS OUTPUT AND SERIAL D CLOCK
    // PDALR 0bxxxxxx00 : SERIAL CLOCK D PD0 ALT OUTPUT
    WrPortI(PDALR, &PDALRShadow, PDALRShadow | 0x00);

    // 03.16.22
    // THIS WILL SETUP PD0 AS OUTPUT OF ALT SERCLK
    // PDFR  0b00000001 PORT D FUNCTION REGISTER : BIT 0 AS ALT SERCLK OUTPUT
    WrPortI(PDFR, &PDFRShadow, PDFRShadow | 0x01);

    // 03.25.22 set the drive for PD0
    // 14 ma
    WrPortI(PD0CR, &PDDCRShadow, PDDCRShadow | 0x0C);  // 0x0C default fast output slew no pullup
#endif

#endif

    //---------------------------------------------------------------------
    // PARALLEL PORT E
    // PE7  SERIAL PORT E RX    INPUT       NORMAL
    // PE6  SERIAL PORT E TX    OUTPUT      ALT
    // PE5  NOT USED
    // PE4  NOT USED
    // PE3  NOT USED
    // PE2  NOT USED
    // PE1  SERIAL CLOCK G  // ALT OUT1
    // PE0  SERIAL DATA G   // ALT OUT1
    //---------------------------------------------------------------------
    // Port E 6 : used as outputs. (0b01000000 = 0x40)
    // 04.27.21 add PE1 and PE0 as OUTPUT pins
    // Port E 6,1,0: used as outputs (0b01000011 = 0x43)
    WrPortI(PEDDR, &PEDDRShadow, PEDDRShadow | 0x43);

    // PEAHR 0bxx11xxxx // parallel port E bit 6 alt output 3 (TXE)
    WrPortI(PEAHR, &PEAHRShadow, PEAHRShadow | 0x30);

    // 04.27.21
    // PEALR 0bxxxx0101 // paralleL port E bit 1 alt output 1 (SCLKG)
    //                  // parallel port E bit 0 alt output 1 (SDATG)
    WrPortI(PEALR, &PEALRShadow, PEALRShadow | 0x05);

    // PEFR  0b01000000 PORT E FUNCTION REGISTER // parallel port E bit 6
    // WrPortI(PEFR, &PEFRShadow, PEFRShadow | 0x40);
    // 04.27.21
    // PEFR  0bxxxxxx1x PORT E FUNCTION REGISTER // parallel port E bit 1
    // PEFR  0bxxxxxxx1 PORT E FUNCTION REGISTER // parallel port E bit 0
    // PEFR  0b01000011 == 0x43
    WrPortI(PEFR, &PEFRShadow, PEFRShadow | 0x43);

    //---------------------------------------------------------------------
    // PARALLEL PORT F
    // PF7   NOT USED
    // PF6   NOT USED
    // PF5   NOT USED
    // PF4   NOT USED
    // PF3   NOT USED
    // PF2   NOT USED
    // PF1   NOT USED
    // PF0   NOT USED
    //---------------------------------------------------------------------

    //   WrPortI(PFDR, &PFDRShadow, PFDRShadow & ~0x40);
    //   WrPortI(PFDR, &PFDRShadow, PFDRShadow | 0xB3);
}

void HWIO_Initialize_SerialPortsXT(void)
{

    //
    //  SERIAL PORT E IS FOR THE MT-100A MICROTERMINAL
    //  FOR XT-100: SERIAL PORT SEND/RECEIVE TO MT-100A MICROTERMINAL
    //  FOR XT-200: PRIMARY TROMBONE    : SERIAL PORT SEND/RECEIVE TO MT-100A MICROTERMINAL
    //  FOR XT-200: SECONDARY TROMBONE  : NOT USED
    //  FOR XR-100: SERIAL PORT SEND/RECEIVE TO MT-100A MICROTERMINAL
    //  FOR XT-300: PRIMARY TROMBONE    : TRANSMIT TO TERTIARY TROMBONE
    //  FOR XT-300: SECONDARY TROMBONE  : NOT USED
    //  FOR XT-300: TERTIARY TROMBONE   : RECEIVE FROM PRIMARY TROMBONE

    serEopen(9600); // Serial Port E is the EIA level RS-232 port
    serEwrFlush();  // ON THE XT SYSTEM BOARD THIS IS USED FOR MT-100A IN XT-100
    serErdFlush();  //

    //  SERIAL PORT B IS FOR THE AUX SECONDARY SERIAL PORT
    //  FOR XT-100: NOT USED
    //  FOR XT-200: PRIMARY TROMBONE    : TRANSMIT TO SECONDARY TROMBONE
    //  FOR XT-200: SECONDARY TROMBONE  : RECEIVE FROM PRIMARY TROMBONE

    //  FOR XT-300: PRIMARY TROMBONE    : TRANSMIT TO SECONDARY TROMBONE
    //  FOR XT-300: SECONDARY TROMBONE  : RECEIVE FROM PRIMARY TROMBONE
    //  FOR XT-300: TERTIARY TROMBONE   : RECEIVE FROM PRIMARY TROMBONE

    serBopen(9600); // Serial Port B is the EIA level RS-232 port
    serBflowcontrolOff();
    serBwrFlush(); // ON THE XT SYSTEM BOARD THIS IS USED FOR THE SECONDARY TROMBONE
    serBrdFlush();

    //
    // SERIAL PORT C IS FOR THE RS-485 PORT TO CONTROL THE NEW MOTOR
    //

    serCopen(9600);
    serCflowcontrolOff();
    serCwrFlush();
    serCrdFlush();

    SYSTEM_OutputTerminal("#"); // clear the LCD display
    if (_serial36 == TRUE)
    {
        SYSTEM_OutputTerminal("*");
    } // BEEP THE TERMINAL AT STARTUP

// 04.10.18 send out initial message on MT-100A
#ifdef DEVICE_XT100
    SYSTEM_OutputTerminal("    XT-100");
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS\r\n");
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    SYSTEM_OutputTerminal("    XT-100");
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS\r\n");
#endif
#ifdef DEVICE_XR100
    SYSTEM_OutputTerminal("    XR-100");
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS\r\n");
#endif
#ifdef DEVICE_XT200
    SYSTEM_OutputTerminal("    XT-200");
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS\r\n");
#endif
} // void Init_SERIALPORTS(void) //

void HWIO_Initialize_Variables(void)
{
    //
    // STARTUP PROCESS
    //

    INSTRUMENT.statePARSE = FALSE;
    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = 0;
    INSTRUMENT.stateSER_PORT_B_CHAR = FALSE;
    INSTRUMENT.stateSER_PORT_E_CHAR = FALSE;
    INSTRUMENT.stateSER_PORT_C_CHAR = FALSE;
    INSTRUMENT.stateTCPIP_DATA_IN = FALSE;
    INSTRUMENT.stateTCPIP_DATA_OUT = FALSE;
    INSTRUMENT.stateCMD_FROM_TERM = FALSE;
    INSTRUMENT.stateCMD_FROM_LAN = FALSE;
    INSTRUMENT.stateFIRST_TIME_INIT_SEQUENCE = TRUE;   // FLAG IS RESET IN SYSTEM_OutputPrompt
    INSTRUMENT.stateLESS_TO_MORE_DELAY_SETTING = TRUE; // SET INITIAL DIRECTION FOR PROGRESS BAR FROM LEFT TO RIGHT

// 10.07.21
#ifdef DEVICE_XT100_312P
    INSTRUMENT.stateDEVICE_MODE = DEVICE_PARALLEL; // default is PARALLEL TROMBONE MODE
#else
                                                       // 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
    INSTRUMENT.stateDEVICE_MODE = DEVICE_PARALLEL;     // default is PARALLEL TROMBONE MODE
#else
    INSTRUMENT.stateDEVICE_MODE = DEVICE_SERIAL; // default is SERIAL TROMBONE MODE
#endif
#endif

    INSTRUMENT.stateDEVICE_MODE_MT100A = TRUE;       // default is MT-100A terminal mode
    INSTRUMENT.stateMENU_MODE = 0;                   // 0 = normal (not is menu mode)
    INSTRUMENT.stateMENU_MODE_LAST_RELAY = 0;        // number of last relay specified in MenuMode
    INSTRUMENT.stateFACTORY_DEFAULT_PRESSED = FALSE; // initialize this flag
    INSTRUMENT.stateEXT_HW_INT_TRIGGERED = FALSE;

#if (defined(DEVICE_XT100) || defined(DEVICE_XT200) || defined(DEVICE_XT312P))
    INSTRUMENT.stateMOTOR_Response_VALUE = 0;
    INSTRUMENT.stateMOTOR_ResponseProcessed = FALSE;
#endif

    INSTRUMENT.stateOPC_QueryPending_CH2 = FALSE;
    INSTRUMENT.stateOPC_QueryResponseReceived_CH2 = FALSE;

    INSTRUMENT.stateOPC_QueryPending_CH3 = FALSE;
    INSTRUMENT.stateOPC_QueryResponseReceived_CH3 = FALSE;

    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
    INSTRUMENT.stateOPERATION_COMPLETE_CH2 = FALSE;
    INSTRUMENT.stateOPERATION_COMPLETE_CH3 = FALSE;
    INSTRUMENT.stateLAST_OperationChannelNumber = 1;

    INSTRUMENT_SETTINGS.CURRENT_UNITS = PS; // set default current units (change for diff models?)
    INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE = 0.0;
    INSTRUMENT_SETTINGS.CURRENT_DELAY = 0.0;

    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS = 0.0; // current delay value in picoseconds for Channel One
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = 0.0; // current delay value in picoseconds for Channel Two
    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = 0.0;  // 03.28.18 added
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = 0.0;  // 03.28.18 added
    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_E = 0.0;  // 03.28.18 added
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_E = 0.0;  // 03.28.18 added

    INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH = 0x00000000; // RD03 BARGRAPH // 02.05.21
    INSTRUMENT_SETTINGS.CURRENT_LAN_LED_STATUS = FALSE; // RD03 BARGRAPH // 02.05.21

    DISPLAY_SETTINGS.CURRENT_STEP_SIZE_E = 0.0; // for display purposes
    DISPLAY_SETTINGS.CURRENT_DELAY_E = 0.0;     // SETTINGS.CurrentDelay formatted for display (EXPONENT)
    DISPLAY_SETTINGS.CURRENT_DELAY_F = 0.0;     // SETTINGS.CurrentDelay formatted for display (FLOAT)
                                                //   DISPLAY_SETTINGS.CURRENT_GPIB_ADDR = 0;
    DISPLAY_SETTINGS.CURRENT_DELAY_ONE_F = 0.0; // current delay value as float for display in Command line
    DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E = 0.0; // current delay (as a float var) for display
    DISPLAY_SETTINGS.CURRENT_DELAY_TWO_F = 0.0; // current delay value as float for display in Command line
    DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E = 0.0; // current delay (as a float var) for display

    GLOBAL_SETTINGS.AUTO_SET_PLUS = FALSE;
    GLOBAL_SETTINGS.AUTO_SET_MINUS = FALSE;
    strcpy(INSTRUMENT.deviceOPTION, deviceOPTION);

    GLOBAL_SETTINGS.REMOTE_LOCAL_MODE = LOCAL;

    INSTRUMENT.charSER_PORT_B_ONLY = 0;
    INSTRUMENT.charSER_PORT_E_ONLY = 0;

// added 06.06.22
#if (defined(DEVICE_XT100) || defined(DEVICE_XT200))
#if defined(TFT_ATTACHED)

    INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = 0;
    INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = 0;

#endif
#endif

#ifdef ENABLE_WEB_SERVER
    _f_strcpy(INSTRUMENT.WEB_MESSAGE_DISPLAY, "None");
#endif

} // void HWIO_Initialize_Variables(void) //

void HWIO_FactoryDefault(void)
{
    // PROCESS FACTORY DEFAULT BUTTON PRESSED
    // RESET INSTRUMENT TO DEFAULT CONDITION

    INSTRUMENT.stateFACTORY_DEFAULT_PRESSED = FALSE; // reset this flag
    // RESET TO DEFAULT CONDITION - LOAD FROM NVRAM
    SYSTEM_LoadNVParametersXT();
// OVERWRITE THEM WITH THE NEW DEFAULT VALUE
#ifdef DEVICE_XT200
#ifdef PRIMARY_TROMBONE
    g_NVParameters.nv_ip_addr = aton("192.168.100.8"); // 11.15.21 change to 192.168.100.8 from 0.0.0.0
#endif
#ifdef SECONDARY_TROMBONE
    g_NVParameters.nv_ip_addr = aton("192.168.100.9");
#endif
#else
    // ALL OTHER DEVICES DEFAULT IP ADDRESS
    g_NVParameters.nv_ip_addr = aton("192.168.100.8");
#endif

    g_NVParameters.nv_netmask = aton("255.255.255.0"); // 11.15.21 change to class c from class b
    g_NVParameters.nv_gateway = aton("192.168.100.1"); // 11.15.21 change to 192.168.100.1 from 192.168.1.1
    g_NVParameters.nv_port = 5025;                     // CHANGE TO 5025 FOR INDUSTRY STANDARD SCPI

    g_ENET_PORT = g_NVParameters.nv_port;
    g_NVParameters.nv_useDHCP = TRUE; // DHCP ON IS DEFAULT FOR ALL X SERIES INSTRUMENTS
    g_NVParameters.nv_overshoot = TRUE;
    g_NVParameters.nv_overshoot_PS = 5;     // 07.27.17 5 ps for default overshoot amount
    g_NVParameters.nv_autodrop = TRUE;      // 03.16.15
    g_NVParameters.nv_terminal_mode = TRUE; // 11.19.21 DEFAULT TERMINAL MODE FOR X SERIES IS TRUE
                                            // 11.19.21 MT-100A IS OPTIONAL

    // SET THIS TO TRUE FOR FACTORY DEFAULT SETTINGS
    // ENSURE CAL TABLE IS LOADED AT FACTORY PRODUCTION TIME INSTALL
    g_NVParameters.nv_useCTSTORE = TRUE; // 07.17.21

    strcpy(g_NVParameters.nv_hostname, "COLBY_XXXXXXXX"); // 01.25.21
    //#ifdef WEB_SERVER
    strcpy(g_NVParameters.nv_password, "password");
#ifdef DEVICE_XT100
    strcpy(g_NVParameters.nv_description, "XT-100 Programmable Delay Line Instrument");
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    strcpy(g_NVParameters.nv_description, "XT-100 Programmable Delay Line Instrument");
#endif
#ifdef DEVICE_XT200
    strcpy(g_NVParameters.nv_description, "XT-200 Programmable Delay Line Instrument");
#endif
#ifdef DEVICE_XT300
    strcpy(g_NVParameters.nv_description, "XT-300 Programmable Delay Line Instrument");
#endif
#ifdef DEVICE_XR100
    strcpy(g_NVParameters.nv_description, "XR-100 Programmable Delay Line Instrument");
#endif
#if defined(DEVICE_XS100)
    strcpy(g_NVParameters.nv_description, "XS-100 Programmable Delay Line Instrument");
#endif

    // SAVE ALL PARAMETERS TO NVRAM STORAGE
    SYSTEM_SaveNVParametersXT();
    // INITIALIZE THE ETHERNET CONNECTION
    ENET_Init(FALSE, g_NVParameters.nv_ip_addr, g_NVParameters.nv_netmask, g_NVParameters.nv_gateway, g_NVParameters.nv_autodrop);
}

void HWIO_Initialize_Ethernet(void)
{

    // INITIALIZE the Ethernet chip if using TCPIP
    // IF FACTORY DEFAULT BUTTON IS PRESSED THEN USE DEFAULT PARAMETERS
    // ELSE GET NVRAM PARAMETERS AND USE SETTINGS STORED IN NVRAM

    // 05.26.21 CHECK TO SEE IF THE FACTORY DEFAULT SWITCH HAS BEEN DEPRESSED

    if (INSTRUMENT.stateFACTORY_DEFAULT_PRESSED == TRUE)
    {
        // PROCESS FACTORY DEFAULT
        HWIO_FactoryDefault();

    } // end-if
    else
    {
        // NORMAL OPERATION - LOAD VALUE FROM NVRAM STORAGE
        SYSTEM_LoadNVParametersXT(); // normal operation; load values from NVRAM

#ifndef DHCP_SEND_HOSTNAME
        if (g_NVParameters.nv_useDHCP == TRUE)
        {
            // DHCP = ON
            ENET_Init(TRUE, g_NVParameters.nv_ip_addr, g_NVParameters.nv_netmask, g_NVParameters.nv_gateway, g_NVParameters.nv_autodrop);
        }
        else
        {
            // DHCP = OFF
            ENET_Init(FALSE, g_NVParameters.nv_ip_addr, g_NVParameters.nv_netmask, g_NVParameters.nv_gateway, g_NVParameters.nv_autodrop);
        }
#endif

#ifdef DHCP_SEND_HOSTNAME

        // ON A NEW FLASH MODULE, THE COLBY_XXXXXXXX IS THE DEFAULT nv_hostname set in NVRAM.
        // REPLACE WITH THE CONSTANT STRING "COLBY_" + SN# (e.g. "21031234") THAT IS EDITED/CREATED FOR EACH INSTRUEMENT C SOURCE FILE
        //
        if (strcmp(g_NVParameters.nv_hostname, "COLBY_XXXXXXXX") == 0)
        {
            // MAKE THE DEFAULT TO BE g_StaticMemHostName (static memory COLBY_12345678) as defined at production
            strcpy(g_NVParameters.nv_hostname, g_StaticMemHostName);
            SYSTEM_SaveNVParametersXT();
            strcpy(g_DynamicMemHostName, g_StaticMemHostName); // use Static Mem HostName as the Dynamic Mem HostName
        }
        else
        {
            // g_DynamicMemHostName is in dynamic working memory
            strcpy(g_DynamicMemHostName, g_NVParameters.nv_hostname); // get the hostname from NV memory
        }

        g_RetCode = sethostname(g_DynamicMemHostName); // 01.24.21

        //#ifndef MIN_WEB
        //      g_NVParameters.nv_useDHCP = TRUE; // FOR WEB DEBUGGING WITHOUT HARDWARE -- USE RCM DEV BOARD
        //#endif

        if (g_NVParameters.nv_useDHCP == TRUE)
        {
            // DHCP = ON
            ENET_Init(TRUE, g_NVParameters.nv_ip_addr, g_NVParameters.nv_netmask, g_NVParameters.nv_gateway, g_NVParameters.nv_autodrop);
        }
        else
        {
            // DHCP = OFF
            ENET_Init(FALSE, g_NVParameters.nv_ip_addr, g_NVParameters.nv_netmask, g_NVParameters.nv_gateway, g_NVParameters.nv_autodrop);
        }

        g_RetCode = sethostname(g_DynamicMemHostName); // 01.24.21
#endif

    } // end else-if

} // void HWIO_Initialize_Ethernet(void) //

void HWIO_Initialize_InstrumentVariables(void)
{

    // check to see whether TERMINAL_MODE was set TRUE in NV storage or not
    if (g_NVParameters.nv_terminal_mode == TRUE)
    {
        INSTRUMENT.stateDEVICE_MODE_MT100A = FALSE;
    }
    else
    {
        INSTRUMENT.stateDEVICE_MODE_MT100A = TRUE;
    }

    if (g_NVParameters.nv_overshoot == TRUE)
    {
        GLOBAL_SETTINGS.userOVERSHOOT = TRUE; // 04.18.07
    }
    else
    {
        // 02.28.07 AGILENT FIX FOR USE WITH PHASE NOISE ANALYZER
        GLOBAL_SETTINGS.userOVERSHOOT = FALSE; // 04.18.07
    }

    if (g_NVParameters.nv_useCTSTORE == TRUE)
    {
        GLOBAL_SETTINGS.USE_CAL_TABLE = TRUE; // 02.07.18
    }
    else
    {
        GLOBAL_SETTINGS.USE_CAL_TABLE = FALSE; // 02.07.18
    }

    // 04.10.18 Handle NS_PS CYCLE MODE on startup
    INSTRUMENT.stateCYCLE_MODE = g_NVParameters.nv_nsps_cycle_mode;

    if ((g_NVParameters.nv_nsps_cycle_mode <= 0) || (g_NVParameters.nv_nsps_cycle_mode > CYCLE_CHANNEL))
    {
        INSTRUMENT.stateCYCLE_MODE = CYCLE_UNIT; // default
        g_NVParameters.nv_nsps_cycle_mode = CYCLE_UNIT;
        SYSTEM_SaveNVParametersXT();
    }

    // determine the INSTRUMENT display setting for NS OR PS
    // 04.26.22 REMOVE ??
    // INSTRUMENT.stateDEVICE_DISPLAY_NS = TRUE; // DEFAULT FOR XR-100 MODELS IS NS DISPLAY TRUE

    if ((PARAMETERS.deviceMAX_DELAY_NS == 0.625) || (PARAMETERS.deviceMAX_DELAY_NS == 0.312) || (PARAMETERS.deviceMAX_DELAY_NS == 0.3125)) // EXCEPT FOR TROMBONE ONLY
        INSTRUMENT.stateDEVICE_DISPLAY_NS = FALSE;                                                                                         // DEFAULT IS PS DISPLAY TRUE

    // clear out the cmdBUFFER which holds the command to process
    memset(cmdBUFFER, 0x00, sizeof(cmdBUFFER)); // clear out buffer
    cmdINDEX = 0;                               // cmdINDEX is the index into the cmdBUFFER

    GLOBAL_SETTINGS.COMMAND_CONTINUE = FALSE; // indicate if there are addtional commands to be processed

    // PAUSE AT STARTUP TO ALLOW MT-100A MICROTERMINAL TO POWER UP BEFORE SENDING
    // STARTUP TEXT MESSAGE

    HWIO_msDelay(250);
    SYSTEM_OutputTerminal("\n$"); // clear the display

#ifdef DEVICE_XT100
    SYSTEM_OutputTerminal("XT-100 ");
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    SYSTEM_OutputTerminal("XT-100 ");
#endif
#ifdef DEVICE_XT200
    SYSTEM_OutputTerminal("XT-200 ");
#endif
#ifdef DEVICE_XR100
    SYSTEM_OutputTerminal("XR-100 ");
#endif
#if defined(DEVICE_XS100)
    SYSTEM_OutputTerminal("XS-100 ");
#endif

    // determine the # of digits to display on TERMINAL STARTUP
    if ((PARAMETERS.deviceMAX_DELAY_NS == 0.625) || (PARAMETERS.deviceMAX_DELAY_NS == 0.312) || (PARAMETERS.deviceMAX_DELAY_NS == 0.3125))
    {
        sprintf(BUFFERS.DISPLAY_LINE, "%6.3fNS", PARAMETERS.deviceMAX_DELAY_NS); // digits of prec to display 3
    }
    else
    {
        sprintf(BUFFERS.DISPLAY_LINE, "%6.2fNS", PARAMETERS.deviceMAX_DELAY_NS); // digits of prec to display 2
    }
    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS");
    /////////////////////
    SYSTEM_OutputTerminal("\r"); // overwrite the Initializing ... prompt

    GLOBAL_SETTINGS.ELAPSED_DELAY_TIME = 0; // added for DTIME? 10.04.06
    GLOBAL_SETTINGS.START_DELAY_TIME = 0;
    GLOBAL_SETTINGS.END_DELAY_TIME = 0;
} // void HWIO_Initialize_InstrumentVariables (void) //

void HWIO_Initialize_BarGraphXT()
{
    unsigned long _BarGraphDisplay;
    _BarGraphDisplay = 0x00000000;

    HWIO_ShiftRegBarGraphInitXT(); // change to new XT

    INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH = 0x00000000; // ADDED RD03 02.05.2021 FOR BARGRAPH
    INSTRUMENT_SETTINGS.CURRENT_LAN_LED_STATUS = FALSE; // ADDED RD03 02.05.2021

    // FLASH THE BAR GRAPH OFF - ON - OFF

    INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH = 0x00000000;
    HWIO_ShiftRegBarGraphOutputXT(INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH);

    INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH = 0x000FFFFF;
    HWIO_ShiftRegBarGraphOutputXT(INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH);

    INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH = 0x00000000;
    HWIO_ShiftRegBarGraphOutputXT(INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH);

} // HWIO_Initialize_BarGraphXT

void HWIO_Initialize_PDM_SREG_XS()
{
#if (defined(XSPDM_ATTACHED) && defined(XT_BOARD_REV3))
    /*  Desc: Initializes SPI for control of the PDM Shift Register
     *   FOR XT_BOARD_REV3 FOR XS-100
     *   PA3 PDM_LATCH   // PDM MODULE LOAD LATCH
     *   PD0 PDM_CLK     // PDM MODULE SPI CLOCK ON D0
     *   PC0 PDM_DATA    // PDM MODULE SPI DATA ON C0
     */
    char _temp = 0x00;

    SPIinit(); // INITIALIZE THE SPI PORT

    // SET LATCH LINE TO LOW
    BitWrPortI(PADR, &PADRShadow, LOW, PDM_LATCH); // PA3

    // CLEAR ALL THE SHIFT REGISTERS TO SET PDM CONTROL LINES OFF
    _temp = 0x00;
    XSPDM_SPI_Write_PD(_temp); // HIGH CONTROL BITS TO ZERO
    XSPDM_SPI_Write_PD(_temp); // LOW CONTROL BITS TO ZERO
    XSPDM_SPI_Latch_PD();      // LATCH THE DATA TO SET THE PDM MODULES

#endif

} // HWIO_Initialize_PDM_SREG_XS

void HWIO_Initialize_RelaysXT(void)
{
    /*  Desc:       For XT_SYSTEM BOARD, USE I2C INTERFACE TO COMMUNICATE TO THE RELAYS
     *   Args:       None.
     *   Returns:    None.
     *   Prereq:     None.
     *   Globals:    None.
     *   Notes:      Setup all the Relay Boards for OUTPUT to enable turning them on or off
     */

#if (defined(DEVICE_XT100) || defined(DEVICE_XR100))
    int _WaitSettleTime;

    _WaitSettleTime = 80;
    // SETUP ALL SECTIONS FOR OUTPUT

    // COMMAND BYTE TO OUTPUT PORT TO MAKE ALL OUTPUT
    HWIO_SendToRelayBoard(CONFIG, SECTION_0, ZEROES);
    HWIO_msDelay(_WaitSettleTime); // wait _WaitSettleTime ms

    // COMMAND BYTE TO OUTPUT PORT TO MAKE ALL OUTPUT
    HWIO_SendToRelayBoard(CONFIG, SECTION_1, ZEROES);
    HWIO_msDelay(_WaitSettleTime); // wait _WaitSettleTime ms

    // COMMAND BYTE TO OUTPUT PORT TO MAKE ALL OUTPUT
    HWIO_SendToRelayBoard(CONFIG, SECTION_2, ZEROES);
    HWIO_msDelay(_WaitSettleTime); // wait _WaitSettleTime ms

    // COMMAND BYTE TO OUTPUT PORT TO MAKE ALL OUTPUT
    HWIO_SendToRelayBoard(CONFIG, SECTION_3, ZEROES);
    HWIO_msDelay(_WaitSettleTime); // wait 250 ms

    // COMMAND BYTE TO OUTPUT PORT TO MAKE ALL OUTPUT
    HWIO_SendToRelayBoard(CONFIG, SECTION_4, ZEROES);
    HWIO_msDelay(_WaitSettleTime); // wait 250 ms

    // COMMAND BYTE TO OUTPUT PORT TO MAKE ALL OUTPUT
    HWIO_SendToRelayBoard(CONFIG, SECTION_5, ZEROES);
    HWIO_msDelay(_WaitSettleTime); // wait 250 ms

    // COMMAND BYTE TO OUTPUT PORT TO MAKE ALL OUTPUT
    HWIO_SendToRelayBoard(CONFIG, SECTION_6, ZEROES);
    HWIO_msDelay(_WaitSettleTime); // wait 250 ms

    // COMMAND BYTE TO OUTPUT PORT TO MAKE ALL OUTPUT
    HWIO_SendToRelayBoard(CONFIG, SECTION_7, ZEROES);
    HWIO_msDelay(_WaitSettleTime); // wait 250 ms

#endif
} /* end HWIO_Initialize_RelaysXT */

unsigned char HWIO_FlipByte(unsigned char byte)
{
    //  Desc:   Flips the input byte such that the input LSB is the
    //          returned MSB and vice-versa
    //  not used
    char index, temp;
    temp = 0;

    for (index = 0; index < 8; index++)
    {
        if (byte & (1 << index))
            temp |= 1 << (7 - index);
    }

    return temp;

} // end HWIO_FlipByte

char HWIO_REL_BitTestSetRelay(char _BitPosition, unsigned int _Relays)
{
    // Test the bit position vs. _Relays and return ON or OFF
    unsigned int _Answer;
    _Answer = 0x0000;

    _Answer = _Relays & (0x0001 << _BitPosition);
    _Answer = (_Answer >> _BitPosition);
    return _Answer;
}

void HWIO_REL_SetRelays_X_SER(unsigned int Relays)
{
    //
    // Each bit setting corresponds to Relay Section # PAIR
    //
    // Relays == 0x0001 turns on Relay # 01     01   R1
    //        == 0x0002 turns on Relay # 02          R2
    //        == 0x0004 turns on Relay # 03     02   R1
    //        == 0x0008 turns on Relay # 04          R2
    //        == 0x0010 turns on Relay # 05     03   R1
    //        == 0x0020 turns on Relay # 06          R2
    //        == 0x0040 turns on Relay # 07     04   R1
    //        == 0x0080 turns on Relay # 08          R2
    // Relays == 0x0100 turns on Relay # 09     05   R1
    //        == 0x0200 turns on Relay # 10          R2
    //        == 0x0400 turns on Relay # 11     06   R1
    //        == 0x0800 turns on Relay # 12          R2
    //        == 0x1000 turns on Relay # 13     07   R1
    //        == 0x2000 turns on Relay # 14          R2
    //        == 0x4000 turns on Relay # 15     08   R1
    //        == 0x8000 turns on Relay # 16          R2

    // 11.19.21 REMOVE -- NOT USED -- HW_RELAYS.CURRENT_STATE   : contains current state of relays
    // HW_RELAYS.SETTINGS   : desired relay settings

    char _index;
    char _RelayOneBit;               // 0x00 for Relay One OFF, 0x01 for Relay One ON
    char _RelayTwoBit;               // 0x00 for Relay_Two OFF, 0x01 for Relay Two ON
    char _RelayPairAddrStateSetting; // 0b000000XY, X=Relay_Two ON/OFF, Y=Relay_One ON/OFF

#if (defined(DEVICE_XR100) || defined(DEVICE_XT100))
    _RelayOneBit = 0;
    _RelayTwoBit = 0;

    // SEQUENCE EACH BIT OF RELAYS TO DETERMINE EACH SECTION RELAY PAIR ADDRESS/STATE(DATA PAYLOAD) SETTING

    for (_index = 0; _index < 16; _index = _index + 2)
    {
        _RelayOneBit = HWIO_REL_BitTestSetRelay(_index, Relays);
        _RelayTwoBit = HWIO_REL_BitTestSetRelay(_index + 1, Relays);

        // SEND TO EACH RELAY BOARD THE DESIRED RELAY SETTING PAIR IN THE DATA PAYLOAD
        _RelayPairAddrStateSetting = (_RelayTwoBit << 1) + _RelayOneBit; // DATA PAYLOAD

        switch (_index)
        {
        case 0:
            HWIO_SendToRelayBoard(OUTPUT_PORT, SECTION_0, _RelayPairAddrStateSetting);
            break;
        case 2:
            HWIO_SendToRelayBoard(OUTPUT_PORT, SECTION_1, _RelayPairAddrStateSetting);
            break;
        case 4:
            HWIO_SendToRelayBoard(OUTPUT_PORT, SECTION_2, _RelayPairAddrStateSetting);
            break;
        case 6:
            HWIO_SendToRelayBoard(OUTPUT_PORT, SECTION_3, _RelayPairAddrStateSetting);
            break;
        case 8:
            HWIO_SendToRelayBoard(OUTPUT_PORT, SECTION_4, _RelayPairAddrStateSetting);
            break;
        case 10:
            HWIO_SendToRelayBoard(OUTPUT_PORT, SECTION_5, _RelayPairAddrStateSetting);
            break;
        case 12:
            HWIO_SendToRelayBoard(OUTPUT_PORT, SECTION_6, _RelayPairAddrStateSetting);
            break;
        case 14:
            HWIO_SendToRelayBoard(OUTPUT_PORT, SECTION_7, _RelayPairAddrStateSetting);
            break;
        default:
            break;
        } // switch
    }     // for

#endif

    // RECORDS THE CURRENT RELAYS STATUS
    HW_RELAYS.SETTINGS = Relays; // 11-15-04   GLOBAL VARIABLE IN MAIN()
// 11.19.21 REMOVE -- NOT USED --  HW_RELAYS.CURRENT_STATE = Relays; // reflect the true current state they were set TO

// 03.24.22 ALSO SET THE PDM MODULES
#if defined(XSPDM_ATTACHED) && defined(XT_BOARD_REV3)
// TBD
#endif
}

float HWIO_REL_SetupRelaysAndSet(float delay_value)
{
    //  Desc:       Determines which relay sections to turn ON or OFF for given delay_value delay setting
    //  Args:       delay_value has delay setting
    //  Returns:    None. Sets up global variable HW_RELAYS.RELAY_ON_OFF[1..16] to 1 ON or 0 OFF
    //  Prereq:     hsRELAY_VALUE[1..16] is pre-filled with set Delay Line values.
    //  Globals:    None.
    //  Side E:     None.
    //  Notes:      use HWIO_RelaySetupRelays for only when all relay step sizes are binary step size EVEN boundaries
    //
    //  05.10.05    Need to handle ODD boundary condition, g_LAST_RELAY_SECTION_ODD ... use relaySetupRelays_ODD
    //

    short i;
    unsigned int relaysON_OFF;
    unsigned char n1, n2, n3, n4; // four bits corresponding to n1:n2:n3:n4
    float remainder;

    remainder = delay_value;

    for (i = 16; i > 0; i--)
    {
        if (HW_RELAYS.RELAY_DELAY_VALUE[i] == 0)
        {
            HW_RELAYS.RELAY_ON_OFF[i] = OFF; // turn OFF this relay
        }                                    // end-if
        else
        {
            if ((remainder >= HW_RELAYS.RELAY_DELAY_VALUE[i]) && (i != HW_RELAYS.NUM_OF_SECTIONS))
            { // 05.10.05 added check. NEVER TURN ON LAST SECTION in HWIO_RelaySetupRelays
                // TURN ON THIS RELAY
                HW_RELAYS.RELAY_ON_OFF[i] = ON;
                remainder = remainder - HW_RELAYS.RELAY_DELAY_VALUE[i];
            } // end-if
            else
            {
                HW_RELAYS.RELAY_ON_OFF[i] = OFF; // make sure it is OFF
            }                                    // end-else-if
        }                                        // end else-if
    }                                            // end for

    // HW_RELAYS.RELAY_ON_OFF[] contains which relays to turn off or on and
    // relaysON_OFF contains which bits corresponding to which relays

    relaysON_OFF = 0x0000;

    // 16, 15, 14, 13
    // n1 = (HW_RELAYS.RELAY_ON_OFF[16]) + (HW_RELAYS.RELAY_ON_OFF[15] << 1) + (HW_RELAYS.RELAY_ON_OFF[14] << 2) + (HW_RELAYS.RELAY_ON_OFF[13] << 3);
    // n2 = (HW_RELAYS.RELAY_ON_OFF[12]) + (HW_RELAYS.RELAY_ON_OFF[11] << 1) + (HW_RELAYS.RELAY_ON_OFF[10] << 2) + (HW_RELAYS.RELAY_ON_OFF[9] << 3);
    // n3 = (HW_RELAYS.RELAY_ON_OFF[8]) + (HW_RELAYS.RELAY_ON_OFF[7] << 1) + (HW_RELAYS.RELAY_ON_OFF[6] << 2) + (HW_RELAYS.RELAY_ON_OFF[5] << 3);
    // n4 = (HW_RELAYS.RELAY_ON_OFF[4]) + (HW_RELAYS.RELAY_ON_OFF[3] << 1) + (HW_RELAYS.RELAY_ON_OFF[2] << 2) + (HW_RELAYS.RELAY_ON_OFF[1] << 3);

    // 06.22.21 FOR XT-100 SYSTEM // LOW ORDER BIT IS TO THE FAR RIGHT !

    n4 = (HW_RELAYS.RELAY_ON_OFF[13]) + (HW_RELAYS.RELAY_ON_OFF[14] << 1) + (HW_RELAYS.RELAY_ON_OFF[15] << 2) + (HW_RELAYS.RELAY_ON_OFF[16] << 3);
    n3 = (HW_RELAYS.RELAY_ON_OFF[9]) + (HW_RELAYS.RELAY_ON_OFF[10] << 1) + (HW_RELAYS.RELAY_ON_OFF[11] << 2) + (HW_RELAYS.RELAY_ON_OFF[12] << 3);
    n2 = (HW_RELAYS.RELAY_ON_OFF[5]) + (HW_RELAYS.RELAY_ON_OFF[6] << 1) + (HW_RELAYS.RELAY_ON_OFF[7] << 2) + (HW_RELAYS.RELAY_ON_OFF[8] << 3);
    n1 = (HW_RELAYS.RELAY_ON_OFF[1]) + (HW_RELAYS.RELAY_ON_OFF[2] << 1) + (HW_RELAYS.RELAY_ON_OFF[3] << 2) + (HW_RELAYS.RELAY_ON_OFF[4] << 3);

    relaysON_OFF = n1 + (n2 << 4) + (n3 << 8) + (n4 << 12);
    HWIO_REL_SetRelays_X_SER(relaysON_OFF);

    return remainder; // remainder has the balance of delay (to be provided by trombone)

} // end HWIO_REL_SetupRelaysAndSet

// 10.21.21 BUILD RD102121

float HWIO_REL_SetupRelaysAndSet_UL(float delay_value, unsigned long _DelayNPF_UL, unsigned long _DelayFS_UL)
{
    //  Desc:       Determines which relay sections to turn ON or OFF for given delay_value delay setting
    //  Args:       delay_value has delay setting, _DelayNPF_UL has UL in nnnppp and _DelayFS_UL has UL in fff
    //  Returns:    None. Sets up global variable HW_RELAYS.RELAY_ON_OFF[1..16] to 1 ON or 0 OFF
    //  Prereq:     HW_RELAYS.RELAY_UL[1..16] is pre-filled with set Delay Line values AS UNSIGNED LONG
    //  Globals:    None.
    //  Side E:     None.
    //  Notes:      use HWIO_RelaySetupRelays for only when all relay step sizes are binary step size EVEN boundaries
    //
    //  10.22.21    This method is used for subtracting unsigned long integer delay lengths in # of picoseconds and turning on the relays
    //  10.22.21    ENTRY: delay_value is the FLOAT value in number of picoseconds
    //  10.22.21    EXIT: returns the FLOAT value in picoseconds of remainder portion for TROMBONE delay setting
    short i;
    unsigned int relaysON_OFF;
    unsigned char n1, n2, n3, n4; // four bits corresponding to n1:n2:n3:n4
    float remainder;
    unsigned long remainder_UL;
    unsigned long _SUM_RELAYS_ON_UL; // RUNNING SUM value of relay sections turned ON (for remainder calculations)
    float _TEMP_F1;
    float _TEMP_F2;

    remainder = delay_value;
    remainder_UL = (unsigned long)delay_value;
    _SUM_RELAYS_ON_UL = 0;

    for (i = 16; i > 0; i--)
    {
        if (HW_RELAYS.RELAY_UL[i] == 0)
        {
            HW_RELAYS.RELAY_ON_OFF[i] = OFF; // turn OFF this relay
        }                                    // end-if
        else
        {
            if ((i == HW_RELAYS.NUM_OF_SECTIONS) && (remainder_UL >= ((unsigned long)HW_RELAYS.RELAY_UL[i])))
            {
// 11.09.21 HANDLE LAST SECTION DIFFERENTLY DEPENDING ON DEVICE TYPE
#ifdef DEVICE_XT100_200N
                // 11.09.21 CAN ONLY DO THIS FOR 200N ELSE DO NORMAL SUBTRACTION
                // FOR DEVICE_XT_200N, THE LAST ODD SECTION VALUE IS 40 NS
                remainder_UL = remainder_UL - 40000; // 10.22.21 THIS IS THE VALUE OF RELAY # 10 40 NS
                HW_RELAYS.RELAY_ON_OFF[i] = ON;
                _SUM_RELAYS_ON_UL = _SUM_RELAYS_ON_UL + 40000;
#else
                // 11.09.21 NOTE:THIS CODE IS NOT INTENDED TO BE CALLED ... SINCE ABOVE IS ONLY FOR #DEVICE_XT100_200N
                // 11.09.21 NOTE:HANDLE THIS AS NORMAL SEQUENTIAL SUBTRACTION BUT DOES NOT WORK...HAS NOT BEEN TESTED
                // 11.09.21 NOTE:DOES NOT WORK WHEN LAST SECTION IS NON-BINARY STEP SIZE, ONLY MAY WORK IF SEQUENTIAL BINARY STEP SIZE
                HW_RELAYS.RELAY_ON_OFF[i] = ON;
                remainder_UL = remainder_UL - HW_RELAYS.RELAY_UL[i];
                _SUM_RELAYS_ON_UL = _SUM_RELAYS_ON_UL + HW_RELAYS.RELAY_UL[i];
#endif
            }
            else
            {
                if (remainder_UL >= HW_RELAYS.RELAY_UL[i])
                { // TURN ON
                    HW_RELAYS.RELAY_ON_OFF[i] = ON;
                    remainder_UL = remainder_UL - HW_RELAYS.RELAY_UL[i];
                    _SUM_RELAYS_ON_UL = _SUM_RELAYS_ON_UL + HW_RELAYS.RELAY_UL[i];
                } // end-if
                else
                { // TURN OFF
                    HW_RELAYS.RELAY_ON_OFF[i] = OFF;
                }
            }
        } // end else-if
    }     // end for

    // HW_RELAYS.RELAY_ON_OFF[] CONTAINS THE LOGICAL MAPPING
    // relaysON_OFF contains which bits corresponding to which relays

    relaysON_OFF = 0x0000;

// 16, 15, 14, 13
// n1 = (HW_RELAYS.RELAY_ON_OFF[16]) + (HW_RELAYS.RELAY_ON_OFF[15] << 1) + (HW_RELAYS.RELAY_ON_OFF[14] << 2) + (HW_RELAYS.RELAY_ON_OFF[13] << 3);
// n2 = (HW_RELAYS.RELAY_ON_OFF[12]) + (HW_RELAYS.RELAY_ON_OFF[11] << 1) + (HW_RELAYS.RELAY_ON_OFF[10] << 2) + (HW_RELAYS.RELAY_ON_OFF[9] << 3);
// n3 = (HW_RELAYS.RELAY_ON_OFF[8]) + (HW_RELAYS.RELAY_ON_OFF[7] << 1) + (HW_RELAYS.RELAY_ON_OFF[6] << 2) + (HW_RELAYS.RELAY_ON_OFF[5] << 3);
// n4 = (HW_RELAYS.RELAY_ON_OFF[4]) + (HW_RELAYS.RELAY_ON_OFF[3] << 1) + (HW_RELAYS.RELAY_ON_OFF[2] << 2) + (HW_RELAYS.RELAY_ON_OFF[1] << 3);

// 06.22.21 FOR XT-100 SYSTEM // LOW ORDER BIT IS TO THE FAR RIGHT !

// 11.07.21 THIS IS ONLY FOR DEVICE_XT100_200N BECAUSE OF THE MAKEUP OF THE CABLES AND LENGTHS
#ifdef DEVICE_XT100_200N
    n4 = 0;
    // 10.22.21 rel#09 physical 40NS is determined by logical relay # 8
    // 10.22.21 rel#10 physical 40NS is determined by logical relay # 9
    n3 = (HW_RELAYS.RELAY_ON_OFF[8]) + (HW_RELAYS.RELAY_ON_OFF[9] << 1) + (0 << 2) + (0 << 3);
    n2 = (HW_RELAYS.RELAY_ON_OFF[5]) + (HW_RELAYS.RELAY_ON_OFF[6] << 1) + (HW_RELAYS.RELAY_ON_OFF[7] << 2) + (HW_RELAYS.RELAY_ON_OFF[8] << 3);
    n1 = (HW_RELAYS.RELAY_ON_OFF[1]) + (HW_RELAYS.RELAY_ON_OFF[2] << 1) + (HW_RELAYS.RELAY_ON_OFF[3] << 2) + (HW_RELAYS.RELAY_ON_OFF[4] << 3);
#else
    n4 = (HW_RELAYS.RELAY_ON_OFF[13]) + (HW_RELAYS.RELAY_ON_OFF[14] << 1) + (HW_RELAYS.RELAY_ON_OFF[15] << 2) + (HW_RELAYS.RELAY_ON_OFF[16] << 3);
    n3 = (HW_RELAYS.RELAY_ON_OFF[9]) + (HW_RELAYS.RELAY_ON_OFF[10] << 1) + (HW_RELAYS.RELAY_ON_OFF[11] << 2) + (HW_RELAYS.RELAY_ON_OFF[12] << 3);
    n2 = (HW_RELAYS.RELAY_ON_OFF[5]) + (HW_RELAYS.RELAY_ON_OFF[6] << 1) + (HW_RELAYS.RELAY_ON_OFF[7] << 2) + (HW_RELAYS.RELAY_ON_OFF[8] << 3);
    n1 = (HW_RELAYS.RELAY_ON_OFF[1]) + (HW_RELAYS.RELAY_ON_OFF[2] << 1) + (HW_RELAYS.RELAY_ON_OFF[3] << 2) + (HW_RELAYS.RELAY_ON_OFF[4] << 3);
#endif

    relaysON_OFF = n1 + (n2 << 4) + (n3 << 8) + (n4 << 12);
    HWIO_REL_SetRelays_X_SER(relaysON_OFF);
    // return remainder_UL; // remainder has the balance of delay (to be provided by trombone) in number of PICOSECONDS
    _TEMP_F1 = (float)(_DelayNPF_UL - _SUM_RELAYS_ON_UL);
    _TEMP_F2 = (float)(_DelayFS_UL / 1000.0);

    // 10.22.21 return the picoseconds AND the femotoseconds (if any) as a FLOAT return variable (value is <= 624.50 ps)
    return ((float)(_DelayNPF_UL - _SUM_RELAYS_ON_UL) + (float)(_DelayFS_UL / 1000.0));

} // end HWIO_REL_SetupRelaysAndSet_UL

float HWIO_REL_SetupAndSet_X_ODD(float delay_value)
{
    // THIS IS FOR CONFIGURATIONS WHERE THE LAST SECTION IS ODD (NOT A BINARY STEP SIZE OF FULL RANGE)
    // WHEN THE DELAY SETTING SPECIFIED IS HIGHER THAN THE SUM OF ALL THE DELAY SECTIONS (EXCEPT THE LAST ONE),
    // TURN ON THE LAST SECTION AND THEN PERFORM SUCCESSIVE REMAINDER SUBTRACTION TO SET THE DELAY SECTIONS

    // TURN ON THE LAST RELAY

    // SUBTRACT THE LAST RELAY DELAY VALUE FROM THE DELAY SETTING AND MAKE THAT THE NEW REMAINDER

    // USE SUCCESSIVE SUBTRACTION (STARTING FROM LAST RELAY SECTION - 1) TO SET THE DELAY RELAYS
    // THIS IS ONLY FOR XR-100 DEVICE CONFIGURATIONS

    short i;
    unsigned int relaysON_OFF;
    unsigned char n1, n2, n3, n4; // four bits corresponding to n1:n2:n3:n4
    float remainder;
    float _Delta;

    remainder = delay_value;
    for (i = 16; i > 0; i--)
    {
        if (i > HW_RELAYS.NUM_OF_SECTIONS)
        {
            HW_RELAYS.RELAY_ON_OFF[i] = OFF; // TURN OFF ALL RELAYS ABOVE THE HIGHEST
        }
        else
        {
            if (i == HW_RELAYS.NUM_OF_SECTIONS)
            {
                // 08.16.21 THE LAST SECTION NEEDS TO BE HANDLED DIFFERENTLY
                if (remainder > (GLOBAL_SETTINGS.SUM_RELAYS_LESS_1 * 10.0))
                {
                    // TURN ON THE LAST SECTION ONLY IF DELAY DESIRED IS > (GLOBAL_SETTINGS.SUM_RELAYS_LESS_1 * 10.0)
                    HW_RELAYS.RELAY_ON_OFF[i] = ON; // TURN ON the last section
                    remainder = remainder - (HW_RELAYS.RELAY_DELAY_VALUE[i] * 10);
                }
                else
                {
                    // THIS LAST SECTION ODD SECTION IS SKIPPED BECAUSE DESIRED DELAY IS LESS THAN
                    // (GLOBAL_SETTINGS.SUM_RELAYS_LESS_1 * 10)
                    HW_RELAYS.RELAY_ON_OFF[i] = OFF; // TURN OFF THE LAST SECTION - NOT NEEDED
                }
            }
            else
            {
                if (remainder >= (HW_RELAYS.RELAY_DELAY_VALUE[i] * 10.0))
                {
                    // TURN ON THIS RELAY
                    HW_RELAYS.RELAY_ON_OFF[i] = ON;
                    // 10.01.15
                    remainder = remainder - (HW_RELAYS.RELAY_DELAY_VALUE[i] * 10.0);
                }
                else
                {
                    HW_RELAYS.RELAY_ON_OFF[i] = OFF; // make sure it is OFF
                }                                    // end-else-if
            }
        } // end else-if
    }     // end for

    // HW_RELAYS.RELAY_ON_OFF[] contains which relays to turn off or on and
    // relaysON_OFF contains which bits corresponding to which relays

    // 05.31.18 remainder IS zero but rounding error reports a negative value so make it ZERO
    if ((remainder <= 0) && (remainder >= -0.0500))
    {
        remainder = 0;
    }
    relaysON_OFF = 0x0000;

    // 16, 15, 14, 13 ...
    // FOR SEQUENTIAL RELAYS NO CHANGE HERE...

    // n1 = (HW_RELAYS.RELAY_ON_OFF[16]) + (HW_RELAYS.RELAY_ON_OFF[15] << 1) + (HW_RELAYS.RELAY_ON_OFF[14] << 2) + (HW_RELAYS.RELAY_ON_OFF[13] << 3);
    // n2 = (HW_RELAYS.RELAY_ON_OFF[12]) + (HW_RELAYS.RELAY_ON_OFF[11] << 1) + (HW_RELAYS.RELAY_ON_OFF[10] << 2) + (HW_RELAYS.RELAY_ON_OFF[9] << 3);
    // n3 = (HW_RELAYS.RELAY_ON_OFF[8]) + (HW_RELAYS.RELAY_ON_OFF[7] << 1) + (HW_RELAYS.RELAY_ON_OFF[6] << 2) + (HW_RELAYS.RELAY_ON_OFF[5] << 3);
    // n4 = (HW_RELAYS.RELAY_ON_OFF[4]) + (HW_RELAYS.RELAY_ON_OFF[3] << 1) + (HW_RELAYS.RELAY_ON_OFF[2] << 2) + (HW_RELAYS.RELAY_ON_OFF[1] << 3);

    // 06.22.21 FOR XR-100 SYSTEM // LOW ORDER BIT IS TO THE FAR RIGHT !

    n4 = (HW_RELAYS.RELAY_ON_OFF[13]) + (HW_RELAYS.RELAY_ON_OFF[14] << 1) + (HW_RELAYS.RELAY_ON_OFF[15] << 2) + (HW_RELAYS.RELAY_ON_OFF[16] << 3);
    n3 = (HW_RELAYS.RELAY_ON_OFF[9]) + (HW_RELAYS.RELAY_ON_OFF[10] << 1) + (HW_RELAYS.RELAY_ON_OFF[11] << 2) + (HW_RELAYS.RELAY_ON_OFF[12] << 3);
    n2 = (HW_RELAYS.RELAY_ON_OFF[5]) + (HW_RELAYS.RELAY_ON_OFF[6] << 1) + (HW_RELAYS.RELAY_ON_OFF[7] << 2) + (HW_RELAYS.RELAY_ON_OFF[8] << 3);
    n1 = (HW_RELAYS.RELAY_ON_OFF[1]) + (HW_RELAYS.RELAY_ON_OFF[2] << 1) + (HW_RELAYS.RELAY_ON_OFF[3] << 2) + (HW_RELAYS.RELAY_ON_OFF[4] << 3);

    relaysON_OFF = n1 + (n2 << 4) + (n3 << 8) + (n4 << 12);
    HWIO_REL_SetRelays_X_SER(relaysON_OFF);

    return remainder; // remainder has the balance of delay not set by the relay delay sections
}

float HWIO_REL_SetupAndSet_X(float delay_value)
{
    //  Desc:       Determines which relays to turn on or off for given delay_value delay setting
    //  Args:       delay_value has delay setting
    //  Returns:    None. Sets up global variable HW_RELAYS.RELAY_ON_OFF[1..16] to 1 ON or 0 OFF
    //  Prereq:     hsRELAY_VALUE[1..16] is pre-filled with set Delay Line values.
    //  Globals:    None.
    //  Side E:     None.
    //  Notes:      None.
    //
    //  HWIO_REL_SetupAndSet_X should be used in CPDL cases where the LAST STEP is MAXIMUM value
    //  e.g. in CPDL-255NS-1NS-8, the last step is 127NS so it should be turned ON or activated
    //

    short i;
    unsigned int relaysON_OFF;
    unsigned char n1, n2, n3, n4; // four bits corresponding to n1:n2:n3:n4
    float remainder;
    float _Delta;

    remainder = delay_value; // remainder and delay_value are FLOATs
    for (i = 16; i > 0; i--)
    {
        if (HW_RELAYS.RELAY_DELAY_VALUE[i] == 0)
        {
            HW_RELAYS.RELAY_ON_OFF[i] = OFF; // turn OFF this relay
        }                                    // end-if
        else
        {
// 10.01.15 HANDLE TEN_X CORRECTLY
#ifdef TEN_X
            if (remainder >= (HW_RELAYS.RELAY_DELAY_VALUE[i] * 10.0))
            {
                // TURN ON THIS RELAY
                HW_RELAYS.RELAY_ON_OFF[i] = ON;
                // 10.01.15
                remainder = remainder - (HW_RELAYS.RELAY_DELAY_VALUE[i] * 10.0);
#else
            // 02.21.2017 handle the case where 1.25 is not the same as 1.250 because of the resolution
            _Delta = remainder - (float)HW_RELAYS.RELAY_DELAY_VALUE[i];

// 08.17.21
#ifdef DEVICE_XR100
            // FOR DEVICE_XR100
            if ((_Delta) < 0.0)
            {
                _Delta = -1.0 * _Delta;
            }

            if ((_Delta <= 1.0) || (remainder >= HW_RELAYS.RELAY_DELAY_VALUE[i])) // 02.21.2017
            {
                // TURN ON THIS RELAY
                HW_RELAYS.RELAY_ON_OFF[i] = ON;
                remainder = remainder - HW_RELAYS.RELAY_DELAY_VALUE[i];
#else
            // FOR DEVICE_XT100 AND DEVICE_XT200
            // if the remainder is positive, turn on this relay
            if (remainder >= HW_RELAYS.RELAY_DELAY_VALUE[i])
            {
                // TURN ON THIS RELAY
                HW_RELAYS.RELAY_ON_OFF[i] = ON;
                remainder = remainder - HW_RELAYS.RELAY_DELAY_VALUE[i];
#endif
#endif
            } // end-if
            else
            {
                HW_RELAYS.RELAY_ON_OFF[i] = OFF; // make sure it is OFF
            }                                    // end-else-if

        } // end else-if
    }     // end for

    // HW_RELAYS.RELAY_ON_OFF[] contains which relays to turn off or on and
    // relaysON_OFF contains which bits corresponding to which relays

    // 05.31.18 remainder IS zero but rounding error reports a negative value so make it ZERO
    if ((remainder <= 0) && (remainder >= -0.0500))
    {
        remainder = 0;
    }

    relaysON_OFF = 0x0000;

    // 16, 15, 14, 13 ...
    //  FOR SEQUENTIAL RELAYS NO CHANGE HERE...

    // n1 = (HW_RELAYS.RELAY_ON_OFF[16]) + (HW_RELAYS.RELAY_ON_OFF[15] << 1) + (HW_RELAYS.RELAY_ON_OFF[14] << 2) + (HW_RELAYS.RELAY_ON_OFF[13] << 3);
    // n2 = (HW_RELAYS.RELAY_ON_OFF[12]) + (HW_RELAYS.RELAY_ON_OFF[11] << 1) + (HW_RELAYS.RELAY_ON_OFF[10] << 2) + (HW_RELAYS.RELAY_ON_OFF[9] << 3);
    // n3 = (HW_RELAYS.RELAY_ON_OFF[8]) + (HW_RELAYS.RELAY_ON_OFF[7] << 1) + (HW_RELAYS.RELAY_ON_OFF[6] << 2) + (HW_RELAYS.RELAY_ON_OFF[5] << 3);
    // n4 = (HW_RELAYS.RELAY_ON_OFF[4]) + (HW_RELAYS.RELAY_ON_OFF[3] << 1) + (HW_RELAYS.RELAY_ON_OFF[2] << 2) + (HW_RELAYS.RELAY_ON_OFF[1] << 3);

    // 06.22.21 FOR XT-100 SYSTEM // LOW ORDER BIT IS TO THE FAR RIGHT !

    n4 = (HW_RELAYS.RELAY_ON_OFF[13]) + (HW_RELAYS.RELAY_ON_OFF[14] << 1) + (HW_RELAYS.RELAY_ON_OFF[15] << 2) + (HW_RELAYS.RELAY_ON_OFF[16] << 3);
    n3 = (HW_RELAYS.RELAY_ON_OFF[9]) + (HW_RELAYS.RELAY_ON_OFF[10] << 1) + (HW_RELAYS.RELAY_ON_OFF[11] << 2) + (HW_RELAYS.RELAY_ON_OFF[12] << 3);
    n2 = (HW_RELAYS.RELAY_ON_OFF[5]) + (HW_RELAYS.RELAY_ON_OFF[6] << 1) + (HW_RELAYS.RELAY_ON_OFF[7] << 2) + (HW_RELAYS.RELAY_ON_OFF[8] << 3);
    n1 = (HW_RELAYS.RELAY_ON_OFF[1]) + (HW_RELAYS.RELAY_ON_OFF[2] << 1) + (HW_RELAYS.RELAY_ON_OFF[3] << 2) + (HW_RELAYS.RELAY_ON_OFF[4] << 3);

    relaysON_OFF = n1 + (n2 << 4) + (n3 << 8) + (n4 << 12);
    HWIO_REL_SetRelays_X_SER(relaysON_OFF);

    return remainder; // remainder has the balance of delay (to be provided by trombone)

} // end HWIO_REL_SetupAndSet_X

nodebug root interrupt void HWIO_my_isr1()
{
    // SIGNAL THAT THE INTERRUPT WAS TRIGGERED
    INSTRUMENT.stateEXT_HW_INT_TRIGGERED = TRUE;
}

/*** BeginHeader */
#endif //#define SHIFT_REG_INPUT_LIB
       /*** EndHeader */