/* START LIBRARY DESCRIPTION ***************************************************
 *	File		: X_SER_SYS_COMMANDS.LIB
 *	Description	: Library of INST_COMMANDS for HW3 VER 1 HARDWARE
 *	Project		: Colby Instruments Programmable Delay Line X SERIES
 *	Date		: MAY 17, 2021
 *				: Copyright(c) 2021 Colby Instruments, Bellevue, WA
 *	NOTES:		: Library of INST_COMMANDS for HW3 VER 1 HARDWARE
 *END DESCRIPTION ***************************************************************/
//

// BUILD 2106 ******************************************************************
// BUILD 2106 ******************************************************************
// BUILD 2106 ******************************************************************

// 02.15.21	SPLIT COMMANDS.LIB INTO MOTOR_COMMANDS.LIB (11 APIS) AND INST_COMMANDS.LIB (7 APIS)
// 02.18.21	REMOVED GPIB CODE: cmdTMO,cmdESE, cmdESEQ, cmdSRE, cmdSREQ, cmdSTBQ, cmdESRQ, cmdADDRQ, cmdSET_ADDR

// 05.17.21 XT SYSTEM BUILD - INST_COMMANDS_B2106_HW3RD01.LIB TO X_SER_SYS_COMMANDS_B2109.LIB
// 05.17.21 XT SYSTEM BUILD - INST_COMMANDS_B2106_HW3RD01.LIB TO X_SER_SYS_COMMANDS_B2109.LIB
// 05.17.21 XT SYSTEM BUILD - INST_COMMANDS_B2106_HW3RD01.LIB TO X_SER_SYS_COMMANDS_B2109.LIB

// 05.19.21	COMBINE SYS_COMMANDS.LIB AND REFACTOR_BASE.LIB TO FORM SYSTEM.LIB
// 05.19.21 REMOVE DELAY_TIMEQ, *HISTORY and DEVOPS?
// 05.26.21 REMOVE checkGPIB_HW_ADDR_MSG
// 06.08.21 REFACTOR TO SYSTEM_XXXXX API LIBRARY METHOD PROTOTYPES
// 06.23.21 added stateOPC_CHAR_RECEIVED_CH2 and handling
// 07.26.21 added UNITS and UNITS? to replace MODE NS MODE PS
// 07.28.21 changed 12.6e to 12.4e in del? response for XT-100
// 08.02.21 DHCP SHOULD BE DEFAULT TO TRUE IN NVPARAMETERS
// 08.16.21 add HWFD
// 07.26.21	X SERIES FINAL PRODUCTION CODE VERSION 1.00 BUILD 2109 --------------------------------------------------
// 07.30.21 RD073021 BUILD
// 08.04.21	X SERIES FINAL PRODUCTION CODE VERSION 1.00 BUILD 2109 --------------------------------------------------
// 08.06.21 RD080621 BUILD
// 08.17.21 UPDATES TO HWIO_REL APIS, ROUND DOWN BUG AT LAST SECTION (SECTION NOW TURNS OFF FOR TROBONE TO DO REMAINDER)

// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------
// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------
// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------

// 10.06.21 RD081621 BUILD
// 10.06.21 added handle #ifdef DEVICE_XT100_312P
// 10.06.21 HOT FIX - overshoot default should be 5 ps
// 10.14.21 display only 2 digits of precision on command prompt for DEVICE_XT_312P
//
// 10.21.21 BUILD RD102121
// 10.22.21 added cmdREL_UL, cmdRELQ_UL for DEVICE_XT100_200N
// 10.27.21 FOR DEVICE_XT100_200N AND DEL?, DISPLAY IN PS OR NS UNITS (NOT E NOTATION) // decided not needed since change E to display more digits of precision
// 11.07.21 RENAME #define DEVICE_XT100_200N to #define USE_DELAY_UL_TABLE
// 11.09.21 SYSTEM_ExecuteCommand : // 11.09.21 change to .6e in sprintf(BUFFERS.DISPLAY_LINE) for "DEL?" display display more digits of precision

// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------
// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------
// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------

// 11.11.21 BUILD2112_RD102121_RD111121
// 11.15.21 SYSTEM_OutputPrompt: HANDLE DEVICE_XT200_312P TO DISPLAY IN PARALLEL MODE NS and PS
// 11.14.21 COMMENTED OUT / REMOVED CODE WHERE "LIMIT" MESSAGE WAS BEING SENT TO MT100A
// 11.15.21 HANDLE DEVICE_XT200_312P IN DEL? QUERY RETURN
// 11.17.21 SYSTEM_OutputPrompt: CORRECT S AND C OUTPUT PROMPT DISPLAY

// 11.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------
// 11.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------
// 11.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------

// 11.18.21 BUILD 2203
// 11.18.21 REMOVE "INVALID COMMAND" TEXT FROM DISPLAYING OVER SERIAL PORT
// 11.18.21 SYSTEM_ServiceSerialPortE_Char: HANDLE MT-100A OR PUTTY/TELNET TERMINAL OVER RS-232
// 11.18.21 SYSTEM_ServiceSerialPortE_Char: AUTO SET THE CORRECT INSTRUMENT.stateDEVICE_MT100A MODE
// 11.18.21 SYSTEM_OutputPrompt: DO NOT SEND PROMPT OVER RS-232 IF MT-100A NOT ATTACHED
//
// 11.19.21 ADDED cmdTERM "TERM" AND cmdTERMQ "TERM?" COMMAND AND QUERY TO MENU
// 11.19.21 SYSTEM_OutputPrompt: ALWAYS UPDATE THE BAR GRAPH DISPLAY

// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------
// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------
// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------

// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------
// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------
// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------

// 11.20.21 // BUILD2203_RD112021  if (strcmp(cmdARG1, "MEM") == 0)
// 11.24.21 add cmdMEMPTRWRAP, cmdMEMPTRWRAPQ, cmdMEMPTR, cmdMEMPTRQ, cmdMEMQ, cmdTRIGGER
// 11.25.21 SYSTEM_ExtractOneCommand: ADD ADDITIONAL CHARACTERS TO FILTER OUT/IGNORE ASCII (ALL CHARS 0x80 TO 0xFF)
// 11.25.21 added cmdTRIGGERQ, cmdMEMPTRW, cmdMEMPTRWQ
// 12.11.21 SYSTEM_MethodInvalidEntry: remove INVALID ENTRY display on Microterminal

// 01.25.22 SYSTEM_OutputPrompt: FOR XT-200-312P IN DEVICE_PARALLEL MODE, DISPLAY BARGRAPH CORRECTLY
// 01.27.22 IF DEVICE_XT200, DO NOT SAVE TO FLASH ELSE LOSE CONNECTION TO SEC TROMBONE ON CALL TO SYSTEM_SaveNVParametersXT();
// 02.02.22 SYSTEM_SaveNVParametersXT: PRESERVE SERIAL PORT B WHEN WRITING TO USER BLOCK VER 1.14

// 02.07.22 SECONDARY_TROMBONE IGNORE OVERRUN BUFFER CHARACTERS WHEN FLASH UPDATING
// 02.08.22 IF SECONDARY_TROMBONE THEN DONT BEEP MICROTERMINAL
// 02.11.22 VERSION 1.14 UPDATE
// 02.14.22 SYSTEM_SetDelaySecTrombone: ADD '>' CHAR FROM PRI TROMBONE
// 02.14.22 SYSTEM_SetOvershootSecTrombone: ADD '>' CHAR FROM PRI TROMBONE
// 02.16.22 SYSTEM_ServiceSerialPortB_Char: DETECT '>' CHAR FOR SECONDARY TROMBONE AND SET FLAG
// 02.16.22 VERSION 1.15 FOR SECONDARY_TROMBONE CODE

// 03.21.22 ADD SUPPORT FOR TFT DISPLAY
// 03.24.22 SYSTEM_OutputPrompt: ADD SUPPORT FOR XT_BOARD_REV3 WITH NETWORK LED ON PA5 XS_LED
// 04.07.22 ADDED _TFT_DISPLAY_UPDATE TO DISPLAY ON TFT SCREEN
// 04.25.22 SYSTEM_OutputPrompt: add support for DEVICE_XS100
// 04.26.22 SYSTEM_ExecuteCommand,SYSTEM_HandleMenuMode: add support for DEVICE_XS100
// 04.29.22 REMOVED: SYSTEM_DeviceSetDelayParallel
// 05.06.22 REMOVED: SYSTEM_ServiceSerialPortC_Char
// 05.06.22 REMOVED: SYSTEM_ServiceOPC_Response_CH3
// 05.20.22 ADDED: _DetermineX_Offset(float _Value) to right justify displayed value in TFT_DISPLAY
// 06.01.22 RENAMED _TFT_DISPLAY_UPDATE TO SYSTEM_TFT_DISPLAY_UPDATE
// 06.06.22 SYSTEM_LoadNVParametersXT: added 06.06.22 SET DEFAULT OVERSHOOT VALUE TO 5 PS

// 08.19.22 SYSTEM_ExecuteCommand: add XSPDM_cmdRELPD for "PIN" command parser
// 08.23.22 COMPARED/MERGED TO B2203 AND TIMING_TEST VERSIONS AND SOURCE CODE VER 1.17 


/*** BeginHeader */
#ifndef X_SER_SYSTEM_LIB
#define X_SER_SYSTEM_LIB

#use IDBLOCK_API.LIB
/*** EndHeader */

/*** BeginHeader

SYSTEM_CheckNumericAndSetup,
SYSTEM_CheckNumericOnly,
SYSTEM_DeviceSetDelayNoOVS,
SYSTEM_HandleMenuMode,
SYSTEM_ExtractOneCommand,
SYSTEM_MethodInvalidEntry,
SYSTEM_OutputQueryResponse,
SYSTEM_OutputTerminal,
SYSTEM_OutputSecTrombone,
SYSTEM_SetDelaySecTrombone,
SYSTEM_SetOvershootSecTrombone,
SYSTEM_FindFirstSpace,
SYSTEM_FindSecondSpace,
SYSTEM_ParseInputCommand,
SYSTEM_OutputPrompt,

SYSTEM_AdjustNVParametersXT,
SYSTEM_BeepInvalidEntry,
SYSTEM_ExecuteCommand,
SYSTEM_ExecuteTromboneCalibration,
SYSTEM_LoadNVParametersXT,
SYSTEM_SaveNVParametersXT,
SYSTEM_ServiceSerialPortB_Char,
SYSTEM_ServiceSerialPortE_Char,
//SYSTEM_ServiceSerialPortC_Char,
SYSTEM_ServiceOPC_Response_CH2,
//SYSTEM_ServiceOPC_Response_CH3,
SYSTEM_TFT_DISPLAY_FLOAT_IN_CH_TEXT,
SYSTEM_TFT_DISPLAY_UPDATE

*/
#define NONE 0

/* Variables and functions in here are public access */

int SYSTEM_CheckNumericOnly(char *_cmdARG);
int SYSTEM_CheckNumericAndSetup(char _SETUP_CMDARGS);
unsigned char SYSTEM_DeviceSetDelayNoOVS(float delay_setting);
// unsigned char SYSTEM_DeviceSetDelayParallel(float delay_setting);
void SYSTEM_ExtractOneCommand(void);
void SYSTEM_HandleMenuMode(void);
void SYSTEM_MethodInvalidEntry(void);
void SYSTEM_OutputQueryResponse();
short SYSTEM_OutputTerminal(char *TextToTerminal);
short SYSTEM_OutputSecTrombone(char *TextToTerminal);
short SYSTEM_SetDelaySecTrombone(float position);
short SYSTEM_SetOvershootSecTrombone(int truefalse);
short SYSTEM_FindFirstSpace(char *input_line);
short SYSTEM_FindSecondSpace(char *input_line);
void SYSTEM_ParseInputCommand(char *cmd_line);
void SYSTEM_OutputPrompt(void);

void SYSTEM_AdjustNVParametersXT(void);
void SYSTEM_BeepInvalidEntry(void);
void SYSTEM_ExecuteTromboneCalibration(void);
void SYSTEM_ExecuteCommand(void);
void SYSTEM_LoadNVParametersXT(void);
void SYSTEM_SaveNVParametersXT(void);
void SYSTEM_ServiceSerialPortB_Char(void);
void SYSTEM_ServiceSerialPortE_Char(void);
// void SYSTEM_ServiceSerialPortC_Char(void);

void SYSTEM_ServiceOPC_Response_CH2(void);
// void SYSTEM_ServiceOPC_Response_CH3(void);
void SYSTEM_TFT_DISPLAY_FLOAT_IN_CH_TEXT(float _DisplayValue, int _ViewportNumber, int _Color);
void SYSTEM_TFT_DISPLAY_UPDATE(void);
/*** EndHeader */


//
// START OF ALL LIBRARY SUBROUTINE AND FUNCTION CALLS
// PUBLIC INTERFACE

int SYSTEM_CheckNumericOnly(char *_cmdARG)
{
    //
    // evaluates _cmdARG to see if input is a valid numeric entry
    // return 0 if valid else -1 if not

    float _numARG;
    int _ErrorCodeToReturn;
    int _i;
    char _AllNumeric;

    _numARG = -1.0;
    _ErrorCodeToReturn = -1;
    _i = 0;
    _AllNumeric = FALSE;
    // when using atof(), function returns 0 and errno == 0 even when cmdARG1 is NOT numeric digits
    // therefore need to scan cmdARG1 for non-numeric digits though decimal point "." is OK
    // ensure all input is numeric digits or period
    if (strlen(_cmdARG) != 0)
    {
        for (_i = 0; _i < strlen(_cmdARG); _i++)
        {
            if (((_cmdARG[_i] >= '0') && (_cmdARG[_i] <= '9')) || (_cmdARG[_i] == '.') ||
                (_cmdARG[_i] == 'E') || (_cmdARG[_i] == '+') || (_cmdARG[_i] == '-') || (_cmdARG[_i] == ' '))
            { // 04.19.18 added space
                _AllNumeric = TRUE;
                _ErrorCodeToReturn = 0;
            } // end-if
            else
            {
                _AllNumeric = FALSE;
                _ErrorCodeToReturn = -1;
                break;
            }
        } // end-for
    }     // end-if
    return _ErrorCodeToReturn;
}

int SYSTEM_CheckNumericAndSetup(char _SETUP_CMDARGS)
{

    //
    // evaluates cmdARG1 to see if input is a valid numeric entry
    // return 0 if valid else -1 if not
    // _SETUP_CMDARGS == TRUE also includes SETUP to
    // cmdARG1 = "DEL ", cmdARG2 = XXX, cmdARG3 = "NS" | "PS"
    //

    float numARG1;
    int _ErrorCodeToReturn;
    int _i;
    char _AllNumeric;

    numARG1 = -1.0;
    _ErrorCodeToReturn = -1;
    _i = 0;
    _AllNumeric = FALSE;

    // when using atof(), function returns 0 and errno == 0 even when cmdARG1 is NOT numeric digits
    // therefore need to scan cmdARG1 for non-numeric digits though decimal point "." is OK
    // ensure all input is numeric digits or period

    if (strlen(cmdARG1) != 0)
    {
        for (_i = 0; _i < strlen(cmdARG1); _i++)
        {
            if (((cmdARG1[_i] >= '0') && (cmdARG1[_i] <= '9')) || (cmdARG1[_i] == '.') ||
                (cmdARG1[_i] == 'E') || (cmdARG1[_i] == '+') || (cmdARG1[_i] == '-'))
            {
                _AllNumeric = TRUE;
            } // end-if
            else
            {
                _AllNumeric = FALSE;
                break;
            }
        } // end-for
    }     // end-if

    if (_AllNumeric)
    {
        numARG1 = atof(cmdARG1);
        if ((errno == 0) && (numARG1 == -1.0))
        {
            INSTRUMENT.stateERROR = TRUE;
            INSTRUMENT.stateERROR_CODE = INVALID_COMMAND; // invalid command
            _ErrorCodeToReturn = -1;
        }
        else
        {
            if (_SETUP_CMDARGS == TRUE)
            { // SETUP cmdARG1, 2, and 3 ?
                // the digits are valid so add the units to the end
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS)
                    sprintf(cmdARG3, "NS");
                else
                    sprintf(cmdARG3, "PS");
                // numARG1 has the argument
                strcpy(cmdARG2, cmdARG1);
                strcpy(cmdARG1, "DEL ");
            }
            _ErrorCodeToReturn = 0;
        }
    }
    else
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_COMMAND; // invalid command
        _ErrorCodeToReturn = -1;
    }

    return _ErrorCodeToReturn;
}

unsigned char SYSTEM_DeviceSetDelayNoOVS(float delay_setting)
{
    //
    // SETS THE DELAY IF DEVICE IS IN SERIAL MODE
    // DOES NOT CHECK FOR OVERSHOOT
    //
    // Description:   Sets the actual delay (sets Relays and Trombone settings)
    // Args:          delay_setting
    // Returns:       If there is an error in setting the trombone or relays, then
    //                INSTRUMENT.stateERROR_CODE contains error code and SYSTEM_DeviceSetDelay returns FALSE.
    //                CurrentDelay global is set to delay setting.
    // Prereq:        None.
    // Globals:
    // Notes:         Assumes that deviceMAX_DELAY_PS has either 625 or total delay in # of picoseconds.

    int j;
    unsigned long temp, temp2;
    float temp_f;
    float delay_remainder;              // starting at desired delay, contains remainder or balance of
                                        // of delay needed after subtracting successive values of fixed
                                        // delays from the RELAY DELAY EXTENSIONS
    float delay_set_PRI, delay_set_SEC; // 03.28.18 XT-200-1.25NS 11.30.05 PRIMARY 06.29.06 and 03.27.07

    // check if requested delay is in range of device AND is different from current delay
    // for XT-100-OEM or XT-100-000 (no relays) then 625ps is handled with trombone
    // for XT-100-0X0 models, 625ps is handled with relays and MAX DELAY, e.g. 0X0 ns,
    //     is handled when trombone is at maximum delay (625ps) extension.

    // MUST SELECT BETWEEN PDL100A DEVICE OR CPDL DEVICE
    // BY ENABLING #ifdef PDL100A or #ifdef CPDL

#ifdef DEVICE_XT100
    if ((delay_setting <= PARAMETERS.deviceMAX_DELAY_PS) && (delay_setting != INSTRUMENT_SETTINGS.CURRENT_DELAY))
    {
        //
        // for delay_setting >= 0.0 and < 625.0 //
        //

        if ((delay_setting >= 0.0) && (delay_setting < 625.0))
        {
            if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = MOTOR_MoveToPosition(delay_setting, FALSE)) != -1)
            {
                // AND TURN OFF ALL RELAYS because delay setting is all handled by TROMBONE
                if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                {
                    HWIO_REL_SetRelays_X_SER(0x0000); // TURNS OFF ALL RELAYS!!
                    for (j = 1; j <= 16; j++)
                    {
                        HW_RELAYS.RELAY_ON_OFF[j] = OFF;
                    } // end-for
                }
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            } // end-if
            else
            {
                INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
            }
        } // endif

        //
        // for delay_setting == 625.0 //
        //

        if (delay_setting == 625.0)
        {
            if ((strcmp(deviceOPTION, "000") == 0) || (strcmp(deviceOPTION, "OEM") == 0) || (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL))
            {
                // this is a XT-100-000 or XT-100-OEM TROMBONE ONLY
                // therefore 625 ps delay in handled in all of the trombone
                if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = MOTOR_MoveToPosition(delay_setting, FALSE)) != -1)
                {
                    HWIO_REL_SetRelays_X_SER(0x0000);
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                }
                else
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
            } // end-if
            else
            {
                // this is a XT-100-0X0 therefore set 625.00 ps with RELAYS
                //  ORG delay_remainder = HWIO_REL_SetupRelaysAndSet(delay_setting);    // only the 0.625 relay ON
                //  VER 1.07C -- BUG FIX call HWIO_REL_SetupAndSet_X instead of HWIO_REL_SetupRelaysAndSet to turn ON the 625 ps section relay
                delay_remainder = HWIO_REL_SetupAndSet_X(delay_setting); // only the 0.625 relay ON
                if (MOTOR_MoveToPosition(0, FALSE) == -1)
                { // set trombone to ZERO
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
                else
                {
                    INSTRUMENT.stateERROR_CODE = NO_ERROR; // still need to set rest of relays
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = 625.00;
                }
            } // end-else-if
        }     // end-if delay_setting == 625.00

        //
        // for delay_setting > 625.0 //
        //

        if (delay_setting > 625.0)
        {
            // normally cycle through each of the relays if in SERIAL mode
            // but if in PARALLEL mode then can't set delay (out of range)

            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {
                // Cycle through each of the relay sections from 16 to 1 and
                // determine which relays to turn ON by calling HWIO_REL_SetupRelaysAndSet
                // 05.16.05
                // check desired delay value
                // if desired delay is less than the sum of all the relays (except for last one) then use HWIO_REL_SetupAndSet_X
                // else if desired delay requires turning on the last relay;then use HWIO_REL_SetupRelaysAndSet to turn it ON!!
                //

                temp = (unsigned long)delay_setting;
                temp2 = (unsigned long)PARAMETERS.deviceMAX_DELAY_PS;

                if ((temp > GLOBAL_SETTINGS.SUM_RELAYS_LESS_1) || (temp == temp2))
                {
                    delay_remainder = HWIO_REL_SetupAndSet_X(delay_setting); // successive subtraction but handle the last section differently
                }                                                            // HWIO_REL_SetupAndSet_X does NOT turn on the last section
                else
                {
                    // turn on the last relay
                    delay_remainder = HWIO_REL_SetupRelaysAndSet(delay_setting); // HWIO_REL_SetupRelaysAndSet DOES turn on the last section
                }                                                                // turn ON the last section because desired delay is high enough

                if ((delay_remainder >= 0) && (delay_remainder <= 625.0))
                {
                    // pdlStepToDelay(delay_remainder,FALSE);   //balance must be <= 625ps
                    // there is a balance left after setting the fixed relay delays
                    // balance must be set in the TROMBONE
                    if (MOTOR_MoveToPosition(delay_remainder, FALSE) != -1)
                    { // balance <= 625ps
                        INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    }
                    else
                    {
                        INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                    } // end-if
                }     // end-if
                else
                {
                    // ERROR -- last step is > 625ps, shouldn't be here
                    //  delay requested is BEYOND range of this device
                    //  11.11.21 BUILD2112_RD102121_RD111121
                    //  11.15.21 REMOVE - DO NOT DISPLAY LIMIT MESSAGE
                    //  if ((INSTRUMENT.stateCMD_FROM_TERM) && !(INSTRUMENT.stateDEVICE_MODE_MT100A))
                    //  {
                    //      SYSTEM_OutputTerminal("LIMIT\r\n");
                    //  } //endif
                    INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
                }                                                  // end else-if
                INSTRUMENT_SETTINGS.CURRENT_DELAY = delay_setting; // set global CurrentDelay to reflect new value
            }                                                      // end DEVICE_SERIAL
            else
            {
                // in PARALLEL MODE ...
                if (delay_setting > 630.0)
                {
                    // 11.11.21 BUILD2112_RD102121_RD111121
                    // 11.15.21 REMOVE - DO NOT DISPLAY LIMIT MESSAGE
                    // if above 312.50 in PARALLEL MODE; then can't set delay -- out of range
                    // if ((INSTRUMENT.stateCMD_FROM_TERM) && !(INSTRUMENT.stateDEVICE_MODE_MT100A))
                    // {
                    //     SYSTEM_OutputTerminal("LIMIT\r\n");
                    // } //endif

                    INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
                }
                else
                {
                    if (MOTOR_MoveToPosition(delay_setting, FALSE) != -1) // move it out to max of 630
                        INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    else
                        INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                } // <= 630.0
            }     // end DEVICE_PARALLEL

        } // end - if
        else
        {
            if (delay_setting == INSTRUMENT_SETTINGS.CURRENT_DELAY)
            {
                // requested delay is same as current delay ... so do nothing!
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            }
            else
            {
                // 11.11.21 BUILD2112_RD102121_RD111121
                // 11.15.21 REMOVE - DO NOT DISPLAY LIMIT MESSAGE
                // delay requested is BEYOND range of this device
                // ignore or set to max ? NO. Don't set at all.
                // printf ("\n\rRequested delay is beyond range of device.");
                // if (INSTRUMENT.stateCMD_FROM_TERM)
                // {
                //     SYSTEM_OutputTerminal("LIMIT\r\n");
                // } //endif

                INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
            } // end else-if
        }     // end else-if
    }         // end else-if
#endif

// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    if ((delay_setting <= PARAMETERS.deviceMAX_DELAY_PS) && (delay_setting != INSTRUMENT_SETTINGS.CURRENT_DELAY))
    {
        //
        // for delay_setting >= 0.0 and < 625.0 //
        //

        if ((delay_setting >= 0.0) && (delay_setting < 625.0))
        {
            if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = MOTOR_MoveToPosition(delay_setting, FALSE)) != -1)
            {
                // AND TURN OFF ALL RELAYS because delay setting is all handled by TROMBONE
                if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                {
                    HWIO_REL_SetRelays_X_SER(0x0000); // TURNS OFF ALL RELAYS!!
                    for (j = 1; j <= 16; j++)
                    {
                        HW_RELAYS.RELAY_ON_OFF[j] = OFF;
                    } // end-for
                }
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            } // end-if
            else
            {
                INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
            }
        } // endif

        //
        // for delay_setting == 625.0 //
        //

        if (delay_setting == 625.0)
        {
            if ((strcmp(deviceOPTION, "000") == 0) || (strcmp(deviceOPTION, "OEM") == 0) || (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL))
            {
                // this is a XT-100-000 or XT-100-OEM TROMBONE ONLY
                // therefore 625 ps delay in handled in all of the trombone
                if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = MOTOR_MoveToPosition(delay_setting, FALSE)) != -1)
                {
                    HWIO_REL_SetRelays_X_SER(0x0000);
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                }
                else
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
            } // end-if
            else
            {
                // this is a XT-100-0X0 therefore set 625.00 ps with RELAYS
                //  ORG delay_remainder = HWIO_REL_SetupRelaysAndSet(delay_setting);    // only the 0.625 relay ON
                //  VER 1.07C -- BUG FIX call HWIO_REL_SetupAndSet_X instead of HWIO_REL_SetupRelaysAndSet to turn ON the 625 ps section relay
                delay_remainder = HWIO_REL_SetupAndSet_X(delay_setting); // only the 0.625 relay ON
                if (MOTOR_MoveToPosition(0, FALSE) == -1)
                { // set trombone to ZERO
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
                else
                {
                    INSTRUMENT.stateERROR_CODE = NO_ERROR; // still need to set rest of relays
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = 625.00;
                }
            } // end-else-if
        }     // end-if delay_setting == 625.00

        //
        // for delay_setting > 625.0 //
        //

        if (delay_setting > 625.0)
        {
            // normally cycle through each of the relays if in SERIAL mode
            // but if in PARALLEL mode then can't set delay (out of range)

            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {
                // Cycle through each of the relay sections from 16 to 1 and
                // determine which relays to turn ON by calling HWIO_REL_SetupRelaysAndSet
                // 05.16.05
                // check desired delay value
                // if desired delay is less than the sum of all the relays (except for last one) then use HWIO_REL_SetupAndSet_X
                // else if desired delay requires turning on the last relay;then use HWIO_REL_SetupRelaysAndSet to turn it ON!!
                //

                temp = (unsigned long)delay_setting;
                temp2 = (unsigned long)PARAMETERS.deviceMAX_DELAY_PS;

                if ((temp > GLOBAL_SETTINGS.SUM_RELAYS_LESS_1) || (temp == temp2))
                {
                    delay_remainder = HWIO_REL_SetupAndSet_X(delay_setting); // successive subtraction but handle the last section differently
                }                                                            // HWIO_REL_SetupAndSet_X does NOT turn on the last section
                else
                {
                    // turn on the last relay
                    delay_remainder = HWIO_REL_SetupRelaysAndSet(delay_setting); // HWIO_REL_SetupRelaysAndSet DOES turn on the last section
                }                                                                // turn ON the last section because desired delay is high enough

                if ((delay_remainder >= 0) && (delay_remainder <= 625.0))
                {
                    // pdlStepToDelay(delay_remainder,FALSE);   //balance must be <= 625ps
                    // there is a balance left after setting the fixed relay delays
                    // balance must be set in the TROMBONE
                    if (MOTOR_MoveToPosition(delay_remainder, FALSE) != -1)
                    { // balance <= 625ps
                        INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    }
                    else
                    {
                        INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                    } // end-if
                }     // end-if
                else
                {
                    // 11.11.21 BUILD2112_RD102121_RD111121
                    // 11.15.21 REMOVE - DO NOT DISPLAY LIMIT MESSAGE
                    // ERROR -- last step is > 625ps, shouldn't be here
                    // delay requested is BEYOND range of this device
                    // if ((INSTRUMENT.stateCMD_FROM_TERM) && !(INSTRUMENT.stateDEVICE_MODE_MT100A))
                    // {
                    //     SYSTEM_OutputTerminal("LIMIT\r\n");
                    // } //endif

                    INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
                }                                                  // end else-if
                INSTRUMENT_SETTINGS.CURRENT_DELAY = delay_setting; // set global CurrentDelay to reflect new value
            }                                                      // end DEVICE_SERIAL
            else
            {
                // in PARALLEL MODE ...
                if (delay_setting > 630.0)
                {
                    // 11.11.21 BUILD2112_RD102121_RD111121
                    // 11.15.21 REMOVE - DO NOT DISPLAY LIMIT MESSAGE
                    // if above 312.50 in PARALLEL MODE; then can't set delay -- out of range
                    // if ((INSTRUMENT.stateCMD_FROM_TERM) && !(INSTRUMENT.stateDEVICE_MODE_MT100A))
                    // {
                    //     SYSTEM_OutputTerminal("LIMIT\r\n");
                    // } //endif

                    INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
                }
                else
                {
                    if (MOTOR_MoveToPosition(delay_setting, FALSE) != -1) // move it out to max of 630
                        INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    else
                        INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                } // <= 630.0
            }     // end DEVICE_PARALLEL

        } // end - if
        else
        {
            if (delay_setting == INSTRUMENT_SETTINGS.CURRENT_DELAY)
            {
                // requested delay is same as current delay ... so do nothing!
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            }
            else
            {
                // 11.11.21 BUILD2112_RD102121_RD111121
                // 11.15.21 REMOVE - DO NOT DISPLAY LIMIT MESSAGE
                // delay requested is BEYOND range of this device
                // ignore or set to max ? NO. Don't set at all.
                // printf ("\n\rRequested delay is beyond range of device.");
                // if (INSTRUMENT.stateCMD_FROM_TERM)
                // {
                //     SYSTEM_OutputTerminal("LIMIT\r\n");
                // } //endif

                INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
            } // end else-if
        }     // end else-if
    }         // end else-if
#endif

// 04.19.18
#ifdef DEVICE_XR100

    if (delay_setting <= PARAMETERS.deviceMAX_DELAY_PS)
    {

        // && (delay_setting != CurrentDelay)) {
        temp = (unsigned long)delay_setting;
        temp2 = (unsigned long)PARAMETERS.deviceMAX_DELAY_PS;

        //
        // Cycle through each of the relay sections from 16 to 1 and
        // use sucessive subtraction to determine which relays to turn off or on
        // EXCEPT in the case where the total delay does not align on an even boundary of smallest resolution step sizes.
        // In that instance, g_LAST_RELAY_SECTION_ODD is set to TRUE
        // if g_LAST_RELAY_SECTION_ODD is TRUE, then handle delay settings with call to HWIO_REL_SetupRelaysAndSet(delay_setting) for
        // all delay settings UP TO the sum of all the sections (except for the last section).
        //

        // 05.23.18
        // 10.01.15
        // HWIO_REL_SetupAndSet_X should be used in CPDL cases where the LAST STEP is MAXIMUM value
        // e.g. in CPDL-255NS-1NS-8, the last step is 127NS so it should be turned ON or activated

        // NEED TO FIX AND CHANGE HERE 08.10.21 //

#ifdef TEN_X

        // 08.10.21 FOR XR-100-100NS-010P-14, THE LAST SECTION IS ODD SO HANDLE DIFFERENTLY
        // 08.10.21 ODD MEANS THAT THE LAST SECTION IS NOT A FULL BINARY STEP TO MAKE THE TOTAL RANGE

        if (GLOBAL_SETTINGS.LAST_RELAY_SECTION_ODD == TRUE)
        {
            delay_remainder = HWIO_REL_SetupAndSet_X_ODD(delay_setting); // successive subtraction but handle the last section differently
        }
        else
        {
            // NORMAL BEFORE 08.10.21
            delay_remainder = HWIO_REL_SetupAndSet_X(delay_setting); // successive subtraction but handle the last section differently
        }
#else
        if ((temp > GLOBAL_SETTINGS.SUM_RELAYS_LESS_1) || (temp == temp2))
        {
            delay_remainder = HWIO_REL_SetupAndSet_X(delay_setting); // successive subtraction but handle the last section differently
        }
        else
        {
            // turn on the last relay
            delay_remainder = HWIO_REL_SetupRelaysAndSet(delay_setting);
        }

#endif

        //
        // for CPDL; if delay_remainder is > 0 then it "SHOULD" be less than the
        // smallest step size amount unless the max limit does not fall on a binary
        // multiplier of the smallest step size
        //

        if (delay_remainder >= 0)
        {
            //
            // there is a balance left after setting the fixed relay delays
            // balance is normally set by the TROMBONE but since this is a CPDL
            // then must account for this last amount
            //

        } // end-if

        DISPLAY_SETTINGS.CURRENT_DELAY_F = delay_setting - delay_remainder; // set global CurrentDelay_F to display new value
        INSTRUMENT_SETTINGS.CURRENT_DELAY = delay_setting - delay_remainder;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    }
    else
    {
        // 11.11.21 BUILD2112_RD102121_RD111121
        // 11.15.21 REMOVE - DO NOT DISPLAY LIMIT MESSAGE
        // if ((INSTRUMENT.stateCMD_FROM_TERM) && !(INSTRUMENT.stateDEVICE_MODE_MT100A))
        // {
        //     SYSTEM_OutputTerminal("LIMIT\r\n");
        // } //endif

        INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
    } // endif

#endif

    // 03.28.18

#ifdef DEVICE_XT200
    // check if requested delay is in range of device AND is different from current delay
    if (delay_setting <= PARAMETERS.deviceMAX_DELAY_PS)
    {
        switch (INSTRUMENT.stateDEL_CHANNEL)
        {
        case CHANNEL_ONE:
            // 11.26.2011   if ((delay_setting >= 0.0) && (delay_setting <= 1250.0) && (delay_setting != g_CURRENT_DELAY_ONE)) {  //XT-200-1.25NS 11.30.05
            if ((delay_setting >= 0.0) && (delay_setting <= 625.0) && (delay_setting != INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS))
            { // XT-200-1.25NS 11.30.05
                delay_set_PRI = delay_setting;
                if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = MOTOR_MoveToPosition(delay_set_PRI, FALSE)) != -1)
                { // XT-200-1.25NS // 03.28.18 replace pdlGOTOPOSN
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS = delay_setting;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = delay_setting;
                } // end-if
                else
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
            } // stateDEL_CHANNEL == 1
            else
            {
                // requested delay setting is the same as current one //07.21.08
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            }
            break;
        case CHANNEL_TWO:
            if ((delay_setting >= 0.0) && (delay_setting <= 625.0) && (delay_setting != INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS))
            { // XT-200-1.25NS 11.30.05
                // 10.26.2011
                delay_set_SEC = delay_setting;
                if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = SYSTEM_SetDelaySecTrombone(delay_set_SEC)) != -1)
                { // SET THE TROMBONE PORTION
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = delay_setting;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = delay_setting;
                } // end-if
                else
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
                // command SECONDARY TROMBONE to MOVE
            } // stateDEL_CHANNEL == 2
            else
            {
                // requested delay setting is the same as current one //07.21.08
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            }
            break;
        case CHANNEL_BOTH:
            if ((delay_setting >= 0.0) && (delay_setting <= 625.0) && (delay_setting != INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS))
            { // XT-200-1.25NS 11.30.05 // 10.26.2011 set the delay no matter what the previous was for either
                // 10.26.2011
                delay_set_SEC = delay_setting;
                if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = SYSTEM_SetDelaySecTrombone(delay_set_SEC)) != -1)
                { // SET THE TROMBONE PORTION
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = delay_setting;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = delay_setting;
                } // end-if
                else
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
                // command SECONDARY TROMBONE to MOVE
            } // stateDEL_CHANNEL == 2
            // end set channel 2

            if ((delay_setting >= 0.0) && (delay_setting <= 625.0) && (delay_setting != INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS))
            { // XT-200-1.25NS 11.30.05
                // 10.26.2011
                delay_set_PRI = delay_setting;
                if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = MOTOR_MoveToPosition(delay_set_PRI, FALSE)) != -1)
                { // XT-200-1.25NS
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS = delay_setting;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = delay_setting;
                } // end-if
                else
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
            } // stateDEL_CHANNEL == 1
            break;
        default:
            break;
        } // end-switch
    }     // end else-if
    else
    {
        // DELAY SETTING SPECIFIED IS NOT WITHIN LIMIT OF DEVICE
        INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
    }
#endif

    // Delay should be set.  If not, then INSTRUMENT.stateERROR_CODE contains error code.

    if (INSTRUMENT.stateERROR_CODE == NO_ERROR)
        return TRUE;
    else
        return FALSE;

} // end SYSTEM_DeviceSetDelay

#if defined(NOTUSED)
unsigned char SYSTEM_DeviceSetDelayParallel(float delay_setting)
{
    // SETS THE DELAY IF DEVICE IS IN PARALLEL MODE
    // THIS IS THE SAME CODE FOR SERIAL DEVICE MODE deviceSET_DELAY_SERIAL
    // EXCEPT THE ONLY VALID BAND is 0 to 312.50 ps
    // USE RELAY COMMAND TO TURN ON/OFF INDIVIDUAL RELAYS for additional delay
    //
    // Description:   Sets the actual delay only for TROMBONE
    // Args:          delay_setting
    // Returns:       If there is an error in setting the trombone or relays, then
    //                INSTRUMENT.stateERROR_CODE contains error code and SYSTEM_DeviceSetDelay returns FALSE.
    //                CurrentDelay global is set to delay setting.
    // Prereq:        None.
    // Globals:
    // Notes:         Assumes that deviceMAX_DELAY_PS has either 625 or total delay in # of picoseconds.

    float delay_remainder; // starting at desired delay, contains remainder or balance of
                           // of delay needed after subtracting successive values of fixed
                           // delays from the RELAY DELAY EXTENSIONS

    // check if requested delay is in range of device AND is different from current delay
    // there is a bug in pdlStepToDelay (array out of bounds if called with same .5 step value twice)

    // 11-22-04 PARALLEL

    if ((delay_setting >= 0.0) && (delay_setting <= 312.50))
    {
        // 021505    if ((CurrentDelay = pdlStepToDelay(delay_setting * 2.0, FALSE)) != -1) {
        if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = MOTOR_MoveToPosition(delay_setting * 2.0, FALSE)) != -1)
        {
            // AND TURN OFF ALL RELAYS
            HWIO_REL_SetRelays_X_SER(0x0000); // TURNS OFF ALL RELAYS!!
            INSTRUMENT.stateERROR_CODE = NO_ERROR;
        } // end-if
        else
        {
            INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
        }
    } // endif

    // Delay should be set.  If not, then INSTRUMENT.stateERROR_CODE contains error code.
    // CurrentDelay has delay setting.

    if (INSTRUMENT.stateERROR_CODE == NO_ERROR)
        return TRUE;
    else
        return FALSE;

} // end SYSTEM_DeviceSetDelayParallel
#endif

void SYSTEM_ExtractOneCommand(void)
{
    //
    // DESCRIPTION : Reduces the command string to return just the next ONE command from the global var GLOBAL_SETTINGS.INPUT_COMMAND_LINE[]
    //               to support multiple commands in input line via semicolon delimeter
    //               1. BUFFERS.INPUT_COMMAND_LINE[] contains entire command line input from BUFFERS.gpibBUFFER_IN or BUFFERS.tcpipBUFFER_IN
    //               2. SYSTEM_ExtractOneCommand scans thru BUFFERS.INPUT_COMMAND_LINE[] for ';' char
    //               3. if ';' found, place ONE command string of text into COMMAND[]
    //               4. and put balance back into BUFFERS.INPUT_COMMAND_LINE while setting GLOBAL_SETTINGS.COMMAND_CONTINUE to TRUE to indicate more
    // ARGUMENTS   : None.
    // RETURNS     : place ONE command string into COMMAND[]
    //               and put balance into BUFFERS.INPUT_COMMAND_LINE while setting GLOBAL_SETTINGS.COMMAND_CONTINUE == TRUE
    // PRE-REQ     : rndDELAYhi[0..RAND_ARRAY_LIMIT] and rndDELAYlo[0..RAND_ARRAY_LIMIT]
    // GLOBALS     : RAND_ARRAY_LIMIT defined as array limit.
    // NOTES       : None.

    // BUFFERS.INPUT_COMMAND_LINE [] has the current entire command line as read in from GPIB,ENET,-or-SERIAL
    // scans BUFFERS.INPUT_COMMAND_LINE [] until it finds a semicolon and returns its position

    short index, i, j;
    char copyCOMMAND[BUFFER_MAX];
    int i1, i2;
    char COMMAND_COPY[BUFFER_MAX]; // 06.03.08 for cleaning up \b chars
    int _debugLen1, _debugLen2;

    index = 0;
    i = 0;

    // 06.03.08 FIRST CLEAN UP BUFFERS.INPUT_COMMAND_LINE for any \b chars
    // 06.02.08 REMOVE ALL BACKSPACE CHARACTERS AND SHIFT

    i1 = 0;
    memset(COMMAND_COPY, 0x00, sizeof(COMMAND_COPY)); // clear out this space

    _debugLen1 = strlen(BUFFERS.INPUT_COMMAND_LINE);
    _debugLen2 = strlen(COMMAND_COPY);

    // COMMAND_COPY has copy of cmd_line but without the \b (if any) chars
    for (j = 0; j < strlen(BUFFERS.INPUT_COMMAND_LINE); j++)
    {
    	// 11.25.21 ADD ADDITIONAL CHARACTERS TO FILTER OUT at 0x80 and above
        if ((BUFFERS.INPUT_COMMAND_LINE[j] != '\b') &&
            (BUFFERS.INPUT_COMMAND_LINE[j] < 0x80))
        {
            COMMAND_COPY[i1] = BUFFERS.INPUT_COMMAND_LINE[j];
            i1++;
        } // end-if
        else
        {
            i1 = i1 - 1;
            if (i1 < 0)
            {
                i1 = 0;
            }
            COMMAND_COPY[i1] = 0; // put a null char into the space
        }                         // end-else-if
    }                             // end-for

    // COMMAND_COPY has copy of cmd_line but without the \b (if any) chars
    // so put the copy into cmd_line so can parse and process it...
    // 06.03.08
    // i1 = strlen(BUFFERS.INPUT_COMMAND_LINE);
    // i2 = strlen(COMMAND_COPY);
    // printf ("g_INPUT_COMMAND_LINE [%d]    :-->%s<--\n\r",i1,BUFFERS.INPUT_COMMAND_LINE);
    // printf ("COMMAND_COPY [%d]:-->%s<--\n\r",i2,COMMAND_COPY);

    strcpy(BUFFERS.INPUT_COMMAND_LINE, COMMAND_COPY);

    // 06,03.08
    // i1 = strlen(BUFFERS.INPUT_COMMAND_LINE);
    // printf ("after copy: BUFFERS.INPUT_COMMAND_LINE [%d]    :-->%s<--\n\r",i1,BUFFERS.INPUT_COMMAND_LINE);
    // i1 = strlen(COMMAND_COPY);
    // printf ("after copy: COMMAND_COPY [%d]    :-->%s<--\n\r",i1,COMMAND_COPY);

    // 06.03.08 REPLACE ANY \n or \r with SPACE char
    for (j = 0; j < strlen(BUFFERS.INPUT_COMMAND_LINE); j++)
    {
        if ((BUFFERS.INPUT_COMMAND_LINE[j] == '\r') || (BUFFERS.INPUT_COMMAND_LINE[j] == '\n'))
        {
            BUFFERS.INPUT_COMMAND_LINE[j] = ' ';
        } // end-if
    }     // end-for

    for (index = 0; index < strlen(BUFFERS.INPUT_COMMAND_LINE); index++)
    {
        if (BUFFERS.INPUT_COMMAND_LINE[index] == ';')
        {
            break;
        }
    } // end for

    memset(cmdCOMMAND, 0x00, sizeof(cmdCOMMAND)); // clear out buffer

    // copy one command worth of input (up to ;) into COMMAND[]
    for (i = 0; i < index; i++)
    {
        cmdCOMMAND[i] = BUFFERS.INPUT_COMMAND_LINE[i];
    } // end for

    memset(copyCOMMAND, 0x00, sizeof(copyCOMMAND));
    strcpy(copyCOMMAND, BUFFERS.INPUT_COMMAND_LINE);
    // if (index-1) == strlen(BUFFERS.INPUT_COMMAND_LINE) then no semi was found
    if (index == strlen(BUFFERS.INPUT_COMMAND_LINE))
    {
        GLOBAL_SETTINGS.COMMAND_CONTINUE = FALSE;
    }
    else
    {
        // semicolon was found!
        GLOBAL_SETTINGS.COMMAND_CONTINUE = TRUE;
        memset(BUFFERS.INPUT_COMMAND_LINE, 0x00, sizeof(BUFFERS.INPUT_COMMAND_LINE));
        for (i = index + 1; i < strlen(copyCOMMAND); i++)
        {
            BUFFERS.INPUT_COMMAND_LINE[i - index - 1] = copyCOMMAND[i];
        } // end for
    }     // end else

} // end function SYSTEM_ExtractOneCommand

void SYSTEM_HandleMenuMode(void)
{
    // handles the MENU MODE input and forms the commands as necessary

    int response;
    char IP_BUFFER[20];
    char GW_BUFFER[20];
    char NM_BUFFER[20];

    long IP_ADDRESS;
    long GW_ADDRESS;
    long NM_ADDRESS;
    unsigned int PORT_ADDRESS;

    int r[18];
    int i;
    unsigned int b;
    unsigned int wait, wait_loops;

    char answer[18];
    char version_string[20];

    char MAC_ID_buffer[6]; // 10.28.10

    if (strlen(cmdARG1) >= 0)
    { // 03.28.18 change from >= 0 to just > 0

        response = atoi(cmdARG1);

        if (strcmp(cmdARG1, "\x15") == 0) // ns/ps was hit so return to main menu
            INSTRUMENT.stateMENU_MODE = 0;
        if (strcmp(cmdARG1, "\x13") == 0) // SETUP was hit so return to main menu
            INSTRUMENT.stateMENU_MODE = 0;
        if (strcmp(cmdARG1, "\x16") == 0) // DIAG was hit so return to main menu
            INSTRUMENT.stateMENU_MODE = 0;

        switch (INSTRUMENT.stateMENU_MODE)
        {
        case 0:
            // shouldn't be here ... do nothing
            INSTRUMENT.stateMENU_MODE = 0;
            break;

        // stateMENU_MODE == 1
        case 1: // from 1=ADDR,2=MODE,3=TERM and 4=OVER? prompt
            switch (response)
            {
            case 1: // OPTION 1 ADDR
                // prompt 1=GPIB,2=IP, 3=NET?
                //  05.27.21 REMOVE #1=GPIB
                sprintf(BUFFERS.DISPLAY_LINE, "#2=VER,3=NET? ");
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

                INSTRUMENT.stateMENU_MODE = 2; // or 3
                break;
            case 2: // OPTION 2 MODE
#ifdef DEVICE_XT100
                    // prompt 1=PS,2=NS ?
                sprintf(BUFFERS.DISPLAY_LINE, "#TROMBONE ONLY\t1=SER,2=PAR ? ");
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 10;
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                // ALL 312P UNITS ARE PARALLEL MODE ONLY
                sprintf(BUFFERS.DISPLAY_LINE, "#TROMBONE ONLY\tPARALLEL ");
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 3; // OR 18 NEW ONE ?
#endif

// 03.28.18 handle differently if this is a XT-200 or CPDL-200A-1.25NS
// 03.28.18 #ifdef CANNOT HANDLE OR (DEVICE_XT200 || DEVICE_xxDL200A)
// 03.28.18 Cycle thru CHANNEL ONE, TWO, or BOTH
#ifdef DEVICE_XT200
                switch (INSTRUMENT.stateDEL_CHANNEL)
                {
                case CHANNEL_ONE:
                    INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
                    if (INSTRUMENT.stateDEVICE_DISPLAY_NS)
                    {
                        INSTRUMENT.stateMT100A_DISPLAY = CHAN_TWO_NS;
                    }
                    else
                    {
                        INSTRUMENT.stateMT100A_DISPLAY = CHAN_TWO_PS;
                    }
                    break;
                case CHANNEL_TWO:
                    INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH;
                    if (INSTRUMENT.stateDEVICE_DISPLAY_NS)
                    {
                        INSTRUMENT.stateMT100A_DISPLAY = CHAN_BOTH_NS;
                    }
                    else
                    {
                        INSTRUMENT.stateMT100A_DISPLAY = CHAN_BOTH_PS;
                    }
                    break;
                case CHANNEL_BOTH:
                    INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
                    if (INSTRUMENT.stateDEVICE_DISPLAY_NS)
                    {
                        INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_NS;
                    }
                    else
                    {
                        INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_PS;
                    }
                    break;
                }
                INSTRUMENT.stateERROR_CODE = NONE;
                INSTRUMENT.stateMENU_MODE = 0;
#endif

#ifdef DEVICE_XR100
                INSTRUMENT.stateERROR_CODE = NONE;
                INSTRUMENT.stateMENU_MODE = 0;
#endif
                break;
            case 3: // OPTION 3 TERM
                // TOGGLE THE MT-100A or TERMINAL MODE        // added 5.24.05
                if (INSTRUMENT.stateDEVICE_MODE_MT100A)
                {
                    INSTRUMENT.stateDEVICE_MODE_MT100A = FALSE; // set MT-100A MODE to FALSE
                    g_NVParameters.nv_terminal_mode = TRUE;     // means RS-232 connected to TERMINAL (PC)
                    SYSTEM_SaveNVParametersXT();                // 02.02.22 PRESERVE SERIAL PORT B
                }
                else
                {
                    INSTRUMENT.stateDEVICE_MODE_MT100A = TRUE; // set MT-100A MODE to TRUE
                    g_NVParameters.nv_terminal_mode = FALSE;   // means RS-232 connected to MT-100A
                    SYSTEM_SaveNVParametersXT();               // 02.02.22 PRESERVE SERIAL PORT B
                }
                INSTRUMENT.stateMENU_MODE = 0;
                break;

            case 4: // OPTION 4 - OVERSHOOT ON OR OFF
#ifdef DEVICE_XT100
                if (GLOBAL_SETTINGS.userOVERSHOOT == FALSE)
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#OVERSHOOT=OFF\t1=ON, 2=OFF ? ");
                }
                else
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#OVERSHOOT=ON \t1=ON, 2=OFF ? ");
                }
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 15;
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                if (GLOBAL_SETTINGS.userOVERSHOOT == FALSE)
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#OVERSHOOT=OFF\t1=ON, 2=OFF ? ");
                }
                else
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#OVERSHOOT=ON \t1=ON, 2=OFF ? ");
                }
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 15;
#endif

#ifdef DEVICE_XT200
#ifdef PRIMARY_TROMBONE
                if (GLOBAL_SETTINGS.userOVERSHOOT == FALSE)
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#OVERSHOOT=OFF\t1=ON, 2=OFF ? ");
                }
                else
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#OVERSHOOT=ON \t1=ON, 2=OFF ? ");
                }
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 15;
#endif
#endif

#ifdef DEVICE_XR100
                INSTRUMENT.stateMENU_MODE = 0;
#endif
                break;
            case 5: // added 03.28.18 // can only be here if is a XT-200
                switch (INSTRUMENT.stateCYCLE_MODE)
                {
                case CYCLE_SEQ:
                    sprintf(BUFFERS.DISPLAY_LINE, "#NS/PS CYCLE=SEQ \t1SEQ,2UNT,3CHN?");
                    break;
                case CYCLE_UNIT:
                    sprintf(BUFFERS.DISPLAY_LINE, "#NS/PS CYCLE=UNT \t1SEQ,2UNT,3CHN?");
                    break;
                case CYCLE_CHANNEL:
                    sprintf(BUFFERS.DISPLAY_LINE, "#NS/PS CYCLE=CHN \t1SEQ,2UNT,3CHN?");
                    break;
                }
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 16;
                break;
            default:
                SYSTEM_BeepInvalidEntry();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            }      // end switch
            break; // case 1 //

        // MENU_MODE == 2
        case 2:
            // select between 2=VER,3=NET?
            switch (response)
            {
            case 1: // OPTION 1 - SELECTED ... INVALID
                // 05.27.21
                SYSTEM_BeepInvalidEntry();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
                // added 05.16.06
            case 2:
                // 06.05.06 concatenate VERSION #
                strcpy(version_string, "#SW VERSION ");
                strcat(version_string, swVERSION);
                strcat(version_string, "\t");
                sprintf(BUFFERS.DISPLAY_LINE, version_string);
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                // 04.18.07 changed! sprintf(BUFFERS.DISPLAY_LINE,"COLBYINSTRUMENTS");
                sprintf(BUFFERS.DISPLAY_LINE, "SN %s", deviceSN);
                // ORG sprintf(BUFFERS.DISPLAY_LINE,"COLBYINSTRUMENTS");
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 3;
                break;
            case 3:
                //#ifdef ETHERNET_ENABLED
                // display current IP address
                sprintf(BUFFERS.DISPLAY_LINE, "#1=IP,2=GW,3=NM\t4=DH,5=PO,6=MI?"); // 10.28.10 MAC_ID MENU CHANGE
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

                INSTRUMENT.stateMENU_MODE = 4;
                //#endif

                break;
            default:
                SYSTEM_BeepInvalidEntry();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            } // end switch
            break;
        case 3:
            // 10.07.21 CHANGE
            INSTRUMENT.stateERROR = FALSE;     // WAS TRUE
            INSTRUMENT.stateERROR_CODE = NONE; // WAS invalid_arg
            INSTRUMENT.stateMENU_MODE = 0;
            break;
        case 4:
            switch (response)
            {
            case 1:
                // display current IP address
                IP_ADDRESS = ENET_GetIP();
                sprintf(BUFFERS.DISPLAY_LINE, "#%s?\t", inet_ntoa(IP_BUFFER, IP_ADDRESS)); // put cursor on next line
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                sprintf(cmdARG1, ""); // clear this out so will handle properly when getting to mode#9
                INSTRUMENT.stateMENU_MODE = 5;
                break;
            case 2:
                // display current GW gateway
                GW_ADDRESS = g_NVParameters.nv_gateway;
                sprintf(BUFFERS.DISPLAY_LINE, "#%s?\t", inet_ntoa(GW_BUFFER, GW_ADDRESS));
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                sprintf(cmdARG1, ""); // clear this out so will handle properly when getting to mode#9
                INSTRUMENT.stateMENU_MODE = 6;
                break;
            case 3:
                // display current NM
                NM_ADDRESS = g_NVParameters.nv_netmask;
                sprintf(BUFFERS.DISPLAY_LINE, "#%s?\t", inet_ntoa(NM_BUFFER, NM_ADDRESS));
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                sprintf(cmdARG1, ""); // clear this out so will handle properly when getting to mode#9
                INSTRUMENT.stateMENU_MODE = 7;
                break;
            case 4:
                // display current DHCP, then query
                if (g_NVParameters.nv_useDHCP == TRUE)
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#ON ,1=ON,2=OFF?\t");
                }
                else
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#OFF,1=ON,2=OFF?\t");
                }
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 8;
                break;
            case 5:
                // display current netmask
                PORT_ADDRESS = g_NVParameters.nv_port;
                sprintf(BUFFERS.DISPLAY_LINE, "#PORT= %d?\t", PORT_ADDRESS);
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                sprintf(cmdARG1, ""); // clear this out so will handle properly when getting to mode#9
                INSTRUMENT.stateMENU_MODE = 9;
                break;
            case 6: // add MAC_ID to MENU MODE // 10.28.10
                // display current MAC_ID
                pd_getaddress(0, MAC_ID_buffer);
                sprintf(BUFFERS.DISPLAY_LINE, "#MAC_ID=\t%02X%02X-%02X%02X-%02X%02X\r\n",
                        MAC_ID_buffer[0], MAC_ID_buffer[1], MAC_ID_buffer[2], MAC_ID_buffer[3],
                        MAC_ID_buffer[4], MAC_ID_buffer[5]);
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 3; // all done // 10.28.10 MAC_ID CAN ONLY BE READ NOT SET
                break;
            default:
                SYSTEM_BeepInvalidEntry();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            } // end switch
            break;
        case 5:
            // SET THE IP address from (cmdARG1);
            if (strlen(cmdARG1) != 0)
            {
                IP_ADDRESS = inet_addr(cmdARG1);
                sprintf(cmdARG1, "NET");
                sprintf(cmdARG2, "IP");
                sprintf(cmdARG3, "%s", inet_ntoa(IP_BUFFER, IP_ADDRESS));
                cmdNET();
            } // endif
            INSTRUMENT.stateMENU_MODE = 0;
            break;
        case 6:
            // SET THE GW address from (cmdARG1);
            if (strlen(cmdARG1) != 0)
            {
                GW_ADDRESS = inet_addr(cmdARG1);
                sprintf(cmdARG1, "NET");
                sprintf(cmdARG2, "GW");
                sprintf(cmdARG3, "%s", inet_ntoa(GW_BUFFER, GW_ADDRESS));
                cmdNET();
            } // endif
            INSTRUMENT.stateMENU_MODE = 0;
            break;
        case 7:
            // SET THE NM from (cmdARG1);
            if (strlen(cmdARG1) != 0)
            {
                NM_ADDRESS = inet_addr(cmdARG1);
                sprintf(cmdARG1, "NET");
                sprintf(cmdARG2, "NM");
                sprintf(cmdARG3, "%s", inet_ntoa(NM_BUFFER, NM_ADDRESS)); // put cursor on next line
                cmdNET();
            } // endif
            INSTRUMENT.stateMENU_MODE = 0;
            break;
        case 8:
            // SET THE DHCP (on or off) from (cmdARG1);
            // if response = 1 set DHCP ON, else if response = 0 set DHCP Off, else ignore
            if (response == 1)
            {
                // response = 1, set DHCP ON
                sprintf(cmdARG1, "NET");
                sprintf(cmdARG2, "DHCP");
                sprintf(cmdARG3, "ON");
                cmdNET();
            }
            else
            {
                if (response == 2)
                {
                    // response = 2, set DHCP OFF
                    sprintf(cmdARG1, "NET");
                    sprintf(cmdARG2, "DHCP");
                    sprintf(cmdARG3, "OFF");
                    cmdNET();
                }
            }
            INSTRUMENT.stateMENU_MODE = 0;
            break;
        case 9:
            // SET THE PORT from (cmdARG1);   //5 if hit enter, else port# in cmdARG1
            if (strlen(cmdARG1) != 0)
            {
                PORT_ADDRESS = atoi(cmdARG1);
                sprintf(cmdARG1, "NET");
                sprintf(cmdARG2, "PORT");
                sprintf(cmdARG3, "%d", PORT_ADDRESS);
                cmdNET();
            }
            INSTRUMENT.stateMENU_MODE = 0;
            break;
        case 10:
            // parallel or serial mode or term just entered
            switch (response)
            {
            case 1:
                // set mode SERIAL
                sprintf(cmdARG1, "MODE");
                sprintf(cmdARG2, "SER");
                cmdMODE();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            case 2:
                // set mode PARALLEL
                sprintf(cmdARG1, "MODE");
                sprintf(cmdARG2, "PAR");
                cmdMODE();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            default:
                SYSTEM_BeepInvalidEntry();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            } // end switch
            break;
        case 11:
            // set the relay

            sprintf(BUFFERS.DISPLAY_LINE, "#");
            SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

            for (i = 1; i <= 16; i++)
            {
                if (HW_RELAYS.RELAY_ON_OFF[i])
                {
                    answer[16 - i] = '1';
                }
                else
                {
                    answer[16 - i] = '0';
                }
            }
            for (wait_loops = 0; wait_loops < 2; wait_loops++)
            {
                for (wait = 0; wait < 25000; wait++)
                {
                }
            }

#if defined(DEVICE_XS100)
            sprintf(BUFFERS.DISPLAY_LINE, "%s\tPIN=?", answer);
#else
            sprintf(BUFFERS.DISPLAY_LINE, "%s\tREL=?", answer);
#endif
            SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
            INSTRUMENT.stateMENU_MODE = 12;

            sprintf(cmdARG1, ""); // added 06.03.05
            break;
        case 12:
            // relay number is in response
            //  VER 1.05 FEATURE CHANGE -- TOGGLE THE RELAY
            // store the relay # into a global var so can process in case 13...

            INSTRUMENT.stateMENU_MODE_LAST_RELAY = response;
            if (response == 0)
            {

                if (HW_RELAYS.RELAY_ON_OFF[INSTRUMENT.stateMENU_MODE_LAST_RELAY] == TRUE)
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#ON ,1=ON,2=OFF?\t");
                }
                else
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#OFF,1=ON,2=OFF?\t");
                }

                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 13;
            }
            else
            {

                //            if ((response > 0) && (response <= HW_RELAYS.NUM_OF_SECTIONS))

                if ((response > 0) && (response <= 16)) // 06.22.21 CHANGE TO 16 MAX
                {                                       // 05.10.05 added check for valid # of relay sections installed
// 04.26.22 SUPPORT XS-100
#if !defined(DEVICE_XS100)
                    sprintf(cmdARG1, "REL");
#else
                    sprintf(cmdARG1, "PIN");
#endif
                    sprintf(cmdARG2, "%d", INSTRUMENT.stateMENU_MODE_LAST_RELAY);
                    if ((HW_RELAYS.RELAY_ON_OFF[INSTRUMENT.stateMENU_MODE_LAST_RELAY] == TRUE) ||
                        (response > HW_RELAYS.NUM_OF_SECTIONS)) // 06.22.21 OFF FOR RELAYS NOT INSTALLED
                    {                                           // if relay is already ON then turn it OFF
                        sprintf(cmdARG3, "OFF");
                        HW_RELAYS.RELAY_ON_OFF[INSTRUMENT.stateMENU_MODE_LAST_RELAY] = FALSE;
                    }
                    else
                    { // if relay is already OFF then turn it ON
                        sprintf(cmdARG3, "ON");
                        HW_RELAYS.RELAY_ON_OFF[INSTRUMENT.stateMENU_MODE_LAST_RELAY] = TRUE;
                    }
// BUILD RD102221
// 11.07.21 #ifdef DEVICE_XT100_200N
#ifdef USE_DELAY_UL_TABLE
                    cmdREL_UL();
#else
// 04.26.22 ADD SUPPORT XS-100
#if defined(DEVICE_XS100)
                    XSPDM_cmdRELPD(); // 02.20.09
#else
                    cmdREL();
#endif
#endif

                    if (INSTRUMENT.stateMENU_MODE_LAST_RELAY == 0)
                    {
                        for (i = 0; i <= 16; i++)
                        {
                            if (response == 1)
                                HW_RELAYS.RELAY_ON_OFF[16 - i] = TRUE;
                            else
                                HW_RELAYS.RELAY_ON_OFF[16 - i] = FALSE;
                        }
                    } // only applies to ALL relays if relay#0 was specified

                    INSTRUMENT.stateMENU_MODE = 11; // back to REL? command mode
                    INSTRUMENT.statePARSE = TRUE;
                }
                else
                {
// 04.26.22 ADD SUPPORT XS-100
#if defined(DEVICE_XS100)
                    // PIN # IS INVALID ... ASK AGAIN

                    sprintf(BUFFERS.DISPLAY_LINE, "#");
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

                    sprintf(BUFFERS.DISPLAY_LINE, "%s\tPIN=?", answer);
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

                    sprintf(BUFFERS.DISPLAY_LINE, "*"); // BEEP the buzzer!!
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

                    INSTRUMENT.stateMENU_MODE = 12;
                    sprintf(cmdARG1, ""); // added 06.24.05

#else

                    // 08.25.09 use relay number to set # of cycles to toggles relays off/on/off
                    // setup the answer array to display 1=rel on or 0=rel off
                    for (i = 1; i <= 16; i++)
                    {
                        if (HW_RELAYS.RELAY_ON_OFF[i])
                        {
                            answer[16 - i] = '1';
                        }
                        else
                        {
                            answer[16 - i] = '0';
                        }
                    }

                    sprintf(BUFFERS.DISPLAY_LINE, "#"); // clear the LCD screen
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                    for (wait_loops = 0; wait_loops < 2; wait_loops++)
                    {
                        for (wait = 0; wait < 25000; wait++)
                        {
                        }
                    } // wait for LCD clear screen
                    sprintf(BUFFERS.DISPLAY_LINE, "%s\tREL=?", answer);
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE); // display relay status and query

                    // 08.25.09 cycle the relays
                    for (i = 0; i < response; i++)
                    {
                        // Initialize Hardware Relays
                        HW_RELAYS.SETTINGS = 0x0000; // hardware Relay Settings
                        HWIO_Initialize_RelaysXT();
                        HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // turn them all OFF
                        for (wait_loops = 0; wait_loops < 1; wait_loops++)
                        {
                            for (wait = 0; wait < 25000; wait++) // shorten time to 25K
                            {
                            }
                        }
                        HW_RELAYS.SETTINGS = 0xFFFF;                  // turn them all ON
                        HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // turn them all ON
                        for (wait_loops = 0; wait_loops < 1; wait_loops++)
                        {
                            for (wait = 0; wait < 25000; wait++) // shorten time to 25K
                            {
                            }
                        }
                        HW_RELAYS.SETTINGS = 0x0000;                  // turn them all OFF
                        HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // turn them all OFF
                    }                                                 // end - for

                    sprintf(cmdARG1, "DEL"); // added 06.24.05
                    sprintf(cmdARG2, "0");
                    cmdDEL();
                    INSTRUMENT.stateMENU_MODE = 0;
                    INSTRUMENT.statePARSE = FALSE;

#endif
                }  // end-else
            }      // end-else
            break; // case 12
        case 13:
// set the relay off or on
// relay number determined in case 12
#if defined(DEVICE_XS100)
            sprintf(cmdARG1, "PIN");
#else
            sprintf(cmdARG1, "REL");
#endif
            sprintf(cmdARG2, "%d", INSTRUMENT.stateMENU_MODE_LAST_RELAY);

            switch (response)
            {
            case 1:
                sprintf(cmdARG3, "ON");
                HW_RELAYS.RELAY_ON_OFF[INSTRUMENT.stateMENU_MODE_LAST_RELAY] = TRUE;
                for (i = 0; i <= 16; i++)
                {
                    HW_RELAYS.RELAY_ON_OFF[16 - i] = TRUE;
                }
                break;
            case 2:
                sprintf(cmdARG3, "OFF");
                HW_RELAYS.RELAY_ON_OFF[INSTRUMENT.stateMENU_MODE_LAST_RELAY] = FALSE;
                for (i = 0; i <= 16; i++)
                {
                    HW_RELAYS.RELAY_ON_OFF[16 - i] = FALSE;
                }
                break;
            default:
                break;
            }
// BUILD RD102221
// 11.07.21 #ifdef DEVICE_XT100_200N
#ifdef USE_DELAY_UL_TABLE
            cmdREL_UL();
#else
// 04.26.22 ADD SUPPORT XS-100
#if defined(DEVICE_XS100)
            XSPDM_cmdRELPD(); // 02.20.09
#else
            cmdREL();
#endif
#endif
            INSTRUMENT.stateMENU_MODE = 11; // back to REL? command mode
            INSTRUMENT.statePARSE = TRUE;
            break;
        case 14:
            switch (response)
            {
            //"#1=REL,2=CAL,\t3=RST,4=CTS?" // 04.30.18
            //"#1=PIN,      \t3=RST,4=CTS?" FOR DEVICE_XS100 // 04.26.22
            case 1:
                if (HW_RELAYS.NUM_OF_SECTIONS != 0)
                {
                    // set the relay
                    for (i = 1; i <= 16; i++)
                    {
                        if (HW_RELAYS.RELAY_ON_OFF[i])
                        {
                            answer[16 - i] = '1';
                        }
                        else
                        {
                            answer[16 - i] = '0';
                        }
                    }
                    sprintf(BUFFERS.DISPLAY_LINE, "\n\r#");
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                    for (wait_loops = 0; wait_loops < 2; wait_loops++)
                    {
                        for (wait = 0; wait < 25000; wait++)
                        {
                        }
                    }
                    sprintf(BUFFERS.DISPLAY_LINE, "%s", answer);
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

                    for (wait_loops = 0; wait_loops < 1; wait_loops++)
                    {
                        for (wait = 0; wait < 25000; wait++)
                        {
                        }
                    }
#if !defined(DEVICE_XS100)
                    sprintf(BUFFERS.DISPLAY_LINE, "\tREL=?");
#else
                    sprintf(BUFFERS.DISPLAY_LINE, "\tPIN=?");
#endif
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                    INSTRUMENT.stateMENU_MODE = 12;
                    sprintf(cmdARG1, ""); // added 06.03.05
                }
                else
                {
                    // NO RELAYS ARE INSTALLED SO IGNORE ...
                    INSTRUMENT.stateMENU_MODE = 0;
                    sprintf(cmdARG1, "");
                }
                break;

            case 2:
                // 04.20.18 // perform a calibration self test
                sprintf(BUFFERS.DISPLAY_LINE, "#CALIBRATION\tSELF-TEST...");
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                sprintf(cmdARG1, "*CAL");
                cmdCAL();
                INSTRUMENT.stateMENU_MODE = 0;
                break;

            case 3:
                // 04.18.07
                cmdRST(1); // full hardware reset
                INSTRUMENT.stateMENU_MODE = 0;
                break;

            case 4:
// 04.30.18 CTSTORE ON OR OFF
#ifndef DEVICE_XR100
                if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#CTSTORE ON\t1=ON,2=OFF? ");
                }
                else
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "#CTSTORE OFF\t1=ON,2=OFF? ");
                }
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                INSTRUMENT.stateMENU_MODE = 17;
                break;
#endif
            default:
                SYSTEM_BeepInvalidEntry();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            } // end switch for case = 14
            break;
        case 15: // added 04.18.07
            switch (response)
            {
            case 1:
                GLOBAL_SETTINGS.userOVERSHOOT = TRUE;
                g_NVParameters.nv_overshoot = TRUE;
// 01.27.22 IF DEVICE_XT200, DO NOT SAVE TO FLASH ELSE LOSE CONNECTION TO SEC TROMBONE
#ifndef DEVICE_XT200
                SYSTEM_SaveNVParametersXT();
#endif
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            case 2:
                GLOBAL_SETTINGS.userOVERSHOOT = FALSE;
                g_NVParameters.nv_overshoot = FALSE;
                SYSTEM_SaveNVParametersXT(); // 02.02.22 PRESERVE SERIAL PORT B
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            case 4: // user just hit ENTER ...
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            default:
                SYSTEM_BeepInvalidEntry();
                INSTRUMENT.stateMENU_MODE = 0;
                break;
            } // end switch
            break;
            // 03.28.18 added for XT-200 / CPDL-200A

        case 16:
            switch (response)
            {
            case CYCLE_SEQ:
                INSTRUMENT.stateCYCLE_MODE = CYCLE_SEQ;
                break;
            case CYCLE_UNIT:
                INSTRUMENT.stateCYCLE_MODE = CYCLE_UNIT;
                break;
            case CYCLE_CHANNEL:
                INSTRUMENT.stateCYCLE_MODE = CYCLE_CHANNEL;
                break;
            default:
                INSTRUMENT.stateCYCLE_MODE = CYCLE_UNIT;
                break;
            } // end-switch
            INSTRUMENT.stateMENU_MODE = 0;
            g_NVParameters.nv_nsps_cycle_mode = INSTRUMENT.stateCYCLE_MODE;
            SYSTEM_SaveNVParametersXT(); // 02.02.22 PRESERVE SERIAL PORT B
            break;

        case 17:
            // 04.30.18 // handle CTSTORE 1=ON or 2=OFF
            switch (response)
            {
            case 1:
                sprintf(cmdARG1, "CTSTORE"); // added 06.24.05
                sprintf(cmdARG2, "ON");
                cmdCTSTORE();
                INSTRUMENT.stateMENU_MODE = 0;
                INSTRUMENT.statePARSE = FALSE;
                break;
            case 2:
                sprintf(cmdARG1, "CTSTORE"); // added 06.24.05
                sprintf(cmdARG2, "OFF");
                cmdCTSTORE();
                INSTRUMENT.stateMENU_MODE = 0;
                INSTRUMENT.statePARSE = FALSE;
                break;
            case 4:
                INSTRUMENT.stateMENU_MODE = 0;
                INSTRUMENT.statePARSE = FALSE;
                break;

            default:
                INSTRUMENT.stateMENU_MODE = 0;
                INSTRUMENT.statePARSE = FALSE;
                break;
            } // end-switch
            INSTRUMENT.stateMENU_MODE = 0;
            break;

        default:
            INSTRUMENT.stateMENU_MODE = 0;
            break;

        } // end switch
    }     // handle only if cmdARG1 != zero length!

    else
    { // cmdARG1 length == 0 so do nothing ...
    } // if (strlen(cmdARG1) >= 0) //

    return;
} // end SYSTEM_HandleMenuMode

void SYSTEM_MethodInvalidEntry(void)
{

    unsigned int wait, wait_loops;

    sprintf(BUFFERS.DISPLAY_LINE, "\tINVALID ENTRY   ");
    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

// 02.08.22 IF SECONDARY_TROMBONE THEN DONT BEEP MICROTERMINAL
#ifndef SECONDARY_TROMBONE
    sprintf(BUFFERS.DISPLAY_LINE, "*");
    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

    for (wait_loops = 0; wait_loops < 1; wait_loops++)
    {
        for (wait = 0; wait < 50000; wait++)
        {
        }
    }
#endif

    INSTRUMENT.stateMENU_MODE = 0;
}

void SYSTEM_OutputQueryResponse()
{
    //
    // SYSTEM_OutputQueryResponse determines where the command came from then sends BUFFERS.DISPLAY_LINE to that device
    //
    // Description:   Direct char string TextToTerminal to the Serial Port of the Micro-Terminal
    // Args:          TextToTerminal (char array)
    // Returns:       None.
    // Prereq:        BUFFERS.DISPLAY_LINE already has the preformed response text to be send.
    // Globals:
    // Notes:         None.

#ifdef DEVICE_XT200
    // PRIMARY_TROMBONE HANDLE AS NORMAL
    if (INSTRUMENT.stateCMD_FROM_TERM) // if from Terminal, then print to it
        SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

    if (INSTRUMENT.stateCMD_FROM_LAN)
    {
        memset(BUFFERS.tcpipBUFFER_OUT, 0x00, sizeof(BUFFERS.tcpipBUFFER_OUT)); // clear it out
        strcpy(BUFFERS.tcpipBUFFER_OUT, BUFFERS.DISPLAY_LINE);                  // copy it in
        INSTRUMENT.stateTCPIP_DATA_OUT = TRUE;                                  // notify that data is available
    }

    // COPY THE RESPONSE OUT TO THE WEB SERVER MESSAGE DISPLAY AREA
    _f_strcpy(INSTRUMENT.WEB_MESSAGE_DISPLAY, BUFFERS.DISPLAY_LINE);

#endif

#ifndef SECONDARY_TROMBONE
    // NOT A DEVICE_XT200 SECONDARY_TROMBONE SO HANDLE AS NORMAL
    if (INSTRUMENT.stateCMD_FROM_TERM) // if from Terminal, then print to it
        SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

    if (INSTRUMENT.stateCMD_FROM_LAN)
    {
        memset(BUFFERS.tcpipBUFFER_OUT, 0x00, sizeof(BUFFERS.tcpipBUFFER_OUT)); // clear it out
        strcpy(BUFFERS.tcpipBUFFER_OUT, BUFFERS.DISPLAY_LINE);                  // copy it in
        INSTRUMENT.stateTCPIP_DATA_OUT = TRUE;                                  // notify that data is available
    }

    // COPY THE RESPONSE OUT TO THE WEB SERVER MESSAGE DISPLAY AREA
    _f_strcpy(INSTRUMENT.WEB_MESSAGE_DISPLAY, BUFFERS.DISPLAY_LINE);

#else
    // AS A SECONDARY TROMBONE, SEND THE *opc BACK OUT TO THE MASTER VIA SERIAL PORT B
    if (INSTRUMENT.stateCMD_FROM_TERM) // 07.02.21 // IF THIS CAME FROM THE MASTER PRIMARY
    {
        SYSTEM_OutputSecTrombone(BUFFERS.DISPLAY_LINE);
    }

    // COMMAND COME FROM LAN DURING CALIBRATION
    if (INSTRUMENT.stateCMD_FROM_LAN)
    {
        memset(BUFFERS.tcpipBUFFER_OUT, 0x00, sizeof(BUFFERS.tcpipBUFFER_OUT)); // clear it out
        strcpy(BUFFERS.tcpipBUFFER_OUT, BUFFERS.DISPLAY_LINE);                  // copy it in
        INSTRUMENT.stateTCPIP_DATA_OUT = TRUE;                                  // notify that data is available
    }

#endif

    return;

} // end prtQUERYRESPONSE

short SYSTEM_OutputTerminal(char *TextToTerminal)
{
    // Description:   Direct char string TextToTerminal to the Serial Port of the Micro-Terminal
    // Args:          TextToTerminal (char array)
    // Returns:       None.
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    if ((strcmp(INSTRUMENT.deviceOPTION, "OEM") == 0))
    { // get from NVRAM settings
      //  do NOT SEND THIS OUT ON SERIAL B on HW1 VER 2 (not needed)
      //  if we're running the OEM version, then send this out the serial port B
      //	serBputs(TextToTerminal);   //SERIAL PORT B on XT-100 BOARD WITH MAX232 IC
    }
    serEputs(TextToTerminal); // SERIAL PORT E on POWER/RELAY BOARD
    return 0;

} // end SYSTEM_OutputTerminal

short SYSTEM_OutputSecTrombone(char *TextToTerminal)
{
    //	Description:	Direct char string TextToTerminal to the SECONDARY Serial Port
    //	Args:		  	TextToTerminal (char array)
    //	Returns:       	None.
    //	Prereq:			None.
    //	Globals:
    //	Notes:			This is used in XT-200 and CPDL-200A to send commands to (SECONDARY_TROMBONE)

    // 04.30.21

    // while (1) { 	// testing forever loop // send data out
    serBputs(TextToTerminal); // SERIALPORT on XT-100 BOARD  EIA/TTL LEVEL
    //           }
    return 0;

} // end SYSTEM_OutputSecTrombone

short SYSTEM_SetDelaySecTrombone(float position)
{
    // DESCRIPTION: SEND A COMMAND TO THE SECONDARY TROMBONE UNIT
    // INPUTS:	stateDEL_CHANNEL (SYSTEM_SetDelaySecTrombone has either 0 or 625)
    // RETURNS:	result		error code
    // 02.14.22 ADD '>' TO INDICATE DELAY SETTING IS FROM PRIMARY TROMBONE COMMAND

    char SEC_TROMBONE_COMMAND[32];

    if ((position - 625.0) <= 0)
    {
        // send command over Serial port to secondary trombone
        memset(SEC_TROMBONE_COMMAND, 0x00, sizeof(SEC_TROMBONE_COMMAND));
        if ((position - 9.99) <= 0.00)
            sprintf(SEC_TROMBONE_COMMAND, ">%4.2f\r\n", position); // 02.14.22 ADD '>' CHAR
        else
        {
            if ((position - 99.99) <= 0)
                sprintf(SEC_TROMBONE_COMMAND, ">%5.2f\r\n", position); // 02.14.22 ADD '>' CHAR
            else
            {
                sprintf(SEC_TROMBONE_COMMAND, ">%6.2f\r\n", position); // 02.14.22 ADD '>' CHAR
            }
        }
        SYSTEM_OutputSecTrombone(SEC_TROMBONE_COMMAND);
        return 0;
    }
    else
    {
        // should not be here...sending command to secondary unit with >625 ps delay
        return -1;
    }

} // end SYSTEM_SetDelaySecTrombone

short SYSTEM_SetOvershootSecTrombone(int truefalse)
{

    // DESCRIPTION: FOR CPDL-200A, SEND OVERSHOOT COMMAND TO THE SECONDARY TROMBONE UNIT
    //
    // INPUTS:	TRUEFALSE = 1 to set OVERSHOOT ON or = 0 to set OVERSHOOT OFF
    //
    // RETURNS:	result		error code
    //

    char SEC_TROMBONE_COMMAND[32];

    // send command over Serial port to secondary trombone
    memset(SEC_TROMBONE_COMMAND, 0x00, sizeof(SEC_TROMBONE_COMMAND));
    if (truefalse)
    {
        sprintf(SEC_TROMBONE_COMMAND, ">OVER ON\r\n"); // 02.14.22 ADD '>' CHAR FROM PRI TROMBONE
    }
    else
    {
        sprintf(SEC_TROMBONE_COMMAND, ">OVER OFF\r\n"); // 02.14.22 ADD '>' CHAR FROM PRI TROMBONE
    }
    SYSTEM_OutputSecTrombone(SEC_TROMBONE_COMMAND);
    return 0;
} // end SYSTEM_SetOvershootSecTrombone

short SYSTEM_FindFirstSpace(char *input_line)
{
    // scans *input_line until it finds the 1st space and returns its position
    short index;

    index = 0;
    for (index = 0; index <= strlen(input_line); index++)
    {
        if (input_line[index] == ' ')
        {
            break;
        }
    } // end for
    // if went through string and no space found, then place one artificially at end
    if (index == (strlen(input_line) + 1))
        index--;

    return index;
} // end function SYSTEM_FindFirstSpace

short SYSTEM_FindSecondSpace(char *input_line)
{
    // scans *input_line until it finds the 2nd space and returns its position
    short index;
    short first_sp_found, second_sp_found;

    first_sp_found = FALSE;
    second_sp_found = FALSE;
    index = 0;
    while ((input_line[index] != ' ') && (index < strlen(input_line)))
    {
        index++;
    } // end while
    if (input_line[index] == ' ')
    {
        first_sp_found = TRUE;
        if (index < strlen(input_line))
        {
            index++; // get index ready to start at next position to scan for 2nd space
        }
        else
        {
            return 0;
        } // end else-if
    }
    else
    {
        return 0;
    } // end else-if

    if (first_sp_found == TRUE)
    {
        while ((input_line[index] != ' ') && (index <= strlen(input_line)))
        {
            index++;
        } // end while
        second_sp_found = TRUE;
    } // end if
    else
    {
        // first space is NOT found so return ERROR //
        return 0;
    } // end else-if
    if (second_sp_found == TRUE)
        return index;
} // end SYSTEM_FindSecondSpace

void SYSTEM_OutputPrompt(void)
{
    //
    // Description:   Display the command prompt onto BOTH serial ports.
    // Args:          None.
    // Returns:       None.
    // Prereq:        None.
    // Globals:       COMMAND_PROMPT[];
    // Notes:         None.
    //

    float CurrentDelay_F_PARALLEL;
    float Display_F;
    float Display_F_ONE, Display_F_TWO; // added 03.28.18

    unsigned long _BarGraphDisplay;
    unsigned long _BarGraphMask;
    float _Percentage;
    int _NumberOfBarsOn_i;
    unsigned long _IndividualBit;
    int _Index;
    float _ValueToUseForDisplay;

    int _NumBars_i; // 05.25.18 determine integer boundary for LED display
    float _NumBars_f;
    float _NumBarsInt_f;
    float _Diff;

    // 03.30.22 added for TFT support
    char _TFT_DisplayLine[30];
    long _IP_ADDRESS;
    char _IP_BUFFER[20];
    unsigned int _PORT_ADDRESS;

    int _i, _Outer;

    _BarGraphDisplay = 0x00FFFFFF;
    _Percentage = 0;
    _IndividualBit = 0x00000001;

    _NumBars_i = 0;
    _NumBars_f = 0;
    _NumBarsInt_f = 0;
    _Diff = 0;

    // 11.18.21 BUILD_2203
    // DETERMINE IF RUNNING IN SERIAL MODE OR PARALLEL MODE TO DETERMINE CORRECT CHAR TO DISPLAY
    // Precision of display increased to display addtional digit (femtoseconds)
    // 06.27.2017 add support for DEVICE_HYBRID == NEW MOTOR FOR XT-100 HW1 VER 2 (NOT USED??) 03.28.18

    // 11.18.21 DISPLAY OUT[PUT PROMPT ONLY IF IN LOCAL MODE AND MT-100A IS CONNECTED (WHEN TERMINAL_MODE == FALSE)
    // 11.19.21 UPDATE BAR GRAPH
    // if (GLOBAL_SETTINGS.REMOTE_LOCAL_MODE == LOCAL)
    if ((GLOBAL_SETTINGS.REMOTE_LOCAL_MODE == LOCAL) && (INSTRUMENT.stateDEVICE_MODE_MT100A == TRUE))
    {

        switch (INSTRUMENT.stateDEVICE_MODE)
        {

        case DEVICE_SERIAL:
        case DEVICE_HYBRID:

            if (INSTRUMENT.stateDEVICE_MODE_MT100A)
            { // display text formatted to MT-100A
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
                {
// 03.28.18 -- CODE WORKAROUND BECAUSE CANT DO IFDEF (DEVICE_XT100 || DEVICE_XR100)
#ifdef DEVICE_XT100
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.2fps|S|%1d\t", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE); // 04.19.18 change 9.3 to 9.2
                    SYSTEM_OutputTerminal("#");                                                                                      // clear the LCD display
                    HWIO_msDelay(100);
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.2fps|S|%1d\t", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE); // 04.19.18 change 9.3 to 9.2
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.2fps|S|%1d\t", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE); // 04.19.18 change 9.3 to 9.2
                    SYSTEM_OutputTerminal("#");                                                                                      // clear the LCD display
                    HWIO_msDelay(100);
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.2fps|S|%1d\t", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE); // 04.19.18 change 9.3 to 9.2
#endif
#ifdef DEVICE_XR100
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.2fps|C|%1d\t", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE); // 04.19.18 change 9.3 to 9.2
                    SYSTEM_OutputTerminal("#");                                                                                      // clear the LCD display
                    HWIO_msDelay(100);
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.2fps|C|%1d\t", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE); // 04.19.18 change 9.3 to 9.2
#endif
#ifdef DEVICE_XT200
                    switch (INSTRUMENT.stateDEL_CHANNEL)
                    {
                    case CHANNEL_ONE:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.1fps|1|\x7F  E%d\t%6.1fps|2| ", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F);
                        break;
                    case CHANNEL_TWO:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.1fps|1|   E%d,\t%6.1fps|2|\x7F", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F);
                        break;
                    case CHANNEL_BOTH:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.1fps|1|\x7F  E%d\t%6.1fps|2|\x7F", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F);
                        break;
                    } // end-switch
#endif
// 04.25.22 ADD SUPPORT FOR XS-100
#ifdef DEVICE_XS100
                    sprintf(BUFFERS.COMMAND_LINE, "# %9.2fps|D|%1d\t", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE); // 05.12.09 P to D
#endif
                }
                else
                {
#ifdef DEVICE_XT100
                    Display_F = DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.00;
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.4fns|S|%1d\t", Display_F, INSTRUMENT.stateERROR_CODE);
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                    Display_F = DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.00;
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.4fns|S|%1d\t", Display_F, INSTRUMENT.stateERROR_CODE);
#endif
#ifdef DEVICE_XR100
                    Display_F = DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.00;
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.3fns|C|%1d\t", Display_F, INSTRUMENT.stateERROR_CODE); // 04.19.18 change 9.5 to 9.3
#endif
#ifdef DEVICE_XT200
                    switch (INSTRUMENT.stateDEL_CHANNEL)
                    {
                    case CHANNEL_ONE:
                        Display_F_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.00;
                        Display_F_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.4fns|1|\x7F  E%d\t%6.4fns|2| ", Display_F_ONE, INSTRUMENT.stateERROR_CODE, Display_F_TWO);
                        break;
                    case CHANNEL_TWO:
                        Display_F_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.00;
                        Display_F_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.4fns|1|   E%d\t%6.4fns|2|\x7F", Display_F_ONE, INSTRUMENT.stateERROR_CODE, Display_F_TWO);
                        break;
                    case CHANNEL_BOTH:
                        Display_F_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.00;
                        Display_F_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.4fns|1|\x7F  E%d\t%6.4fns|2|\x7F", Display_F_ONE, INSTRUMENT.stateERROR_CODE, Display_F_TWO);
                        break;
                    } // end-switch
#endif
// 04.25.22 ADD SUPPORT FOR XS-100
#if defined(DEVICE_XS100)
                    Display_F = DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.00;
                    sprintf(BUFFERS.COMMAND_LINE, "# %9.4fns|D|%1d\t", Display_F, INSTRUMENT.stateERROR_CODE); // 05.12.09 P to D
#endif
                } // end-else
            }
            else
            { // display text formatted to Serial Port
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
                {
#ifdef DEVICE_XT100
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%8.2fps|S|%1d]:", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE);
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%8.2fps|S|%1d]:", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE);
#endif
#ifdef DEVICE_XR100
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%8.2fps|C|%1d]:", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE);
#endif
#ifdef DEVICE_XT200
                    switch (INSTRUMENT.stateDEL_CHANNEL)
                    {
                    case CHANNEL_ONE:
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.1fps |S|%1d]:", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT.stateERROR_CODE);
                        break;
                    case CHANNEL_TWO:
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.1fps |S|%1d]:", INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F, INSTRUMENT.stateERROR_CODE);
                        break;
                    case CHANNEL_BOTH:
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.1fps|1|\x7F\t%6.1fps|2|\x7F%1d]", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F, INSTRUMENT.stateERROR_CODE);
                        break;
                    } // end-switch
#endif
// 04.25.22 ADD SUPPORT FOR XS-100
#if defined(DEVICE_XS100)
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%8.2fps|D|%1d]:", DISPLAY_SETTINGS.CURRENT_DELAY_F, INSTRUMENT.stateERROR_CODE); // 05.12.09 P to D
#endif
                }
                else
                {
#ifdef DEVICE_XT100
                    Display_F = DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.00;
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%9.4fns|S|%1d]:", Display_F, INSTRUMENT.stateERROR_CODE);
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                    Display_F = DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.00;
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%9.4fns|S|%1d]:", Display_F, INSTRUMENT.stateERROR_CODE);
#endif
#ifdef DEVICE_XR100
                    Display_F = DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.00;
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%9.3fns|C|%1d]:", Display_F, INSTRUMENT.stateERROR_CODE); // 04.19.18 change 9.4 to 9.3
#endif
#ifdef DEVICE_XT200
                    switch (INSTRUMENT.stateDEL_CHANNEL)
                    {
                    case CHANNEL_ONE:
                        Display_F_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.4fns |1|%1d]", Display_F_ONE, INSTRUMENT.stateERROR_CODE);
                        break;
                    case CHANNEL_TWO:
                        Display_F_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.4fns |2|%1d]", Display_F_TWO, INSTRUMENT.stateERROR_CODE);
                        break;
                    case CHANNEL_BOTH:
                        Display_F_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.00;
                        Display_F_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.4fns|1|\x7F\t%6.4fns|2|\x7F%1d]", Display_F_ONE, Display_F_TWO, INSTRUMENT.stateERROR_CODE);
                        break;
                    } // end-switch
#endif
// 04.25.22 ADD SUPPORT FOR XS-100
#if defined(DEVICE_XS100)
                    Display_F = DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.00;
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%9.4fns|D|%1d]:", Display_F, INSTRUMENT.stateERROR_CODE); // 05.12.09 P to D
#endif
                } // end-else
            }     // end-else
            break;

        case DEVICE_PARALLEL: // THIS CAN ONLY EXIST FOR XT-100 CONFIGURATION // 11.15.21 EXCEPT FOR XT-200-312P IS PARALLEL MODE XT-200-625P
#ifdef DEVICE_XT100
            CurrentDelay_F_PARALLEL = (DISPLAY_SETTINGS.CURRENT_DELAY_F);
            if (INSTRUMENT.stateDEVICE_MODE_MT100A)
            {
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
                {
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.3fps|P|%1d\t", CurrentDelay_F_PARALLEL, INSTRUMENT.stateERROR_CODE);
                }
                else
                {
                    Display_F = CurrentDelay_F_PARALLEL / 1000;
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.5fns|P|%1d\t", Display_F, INSTRUMENT.stateERROR_CODE);
                }
            }
            else
            {
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
                {
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%9.3fps|P|%1d]:", CurrentDelay_F_PARALLEL, INSTRUMENT.stateERROR_CODE);
                }
                else
                {
                    Display_F = CurrentDelay_F_PARALLEL / 1000;
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%9.5fns|P|%1d]:", Display_F, INSTRUMENT.stateERROR_CODE);
                }
            }
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
            CurrentDelay_F_PARALLEL = (DISPLAY_SETTINGS.CURRENT_DELAY_F);
            if (INSTRUMENT.stateDEVICE_MODE_MT100A)
            {
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
                {
                    // 10.14.21 THIS IS A 312.50 PS DEVICE...ONLY 2 DIGITS AFTER DEC POINT
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.2fps|P|%1d\t", CurrentDelay_F_PARALLEL, INSTRUMENT.stateERROR_CODE);
                }
                else
                {
                    Display_F = CurrentDelay_F_PARALLEL / 1000;
                    sprintf(BUFFERS.COMMAND_LINE, "#%9.5fns|P|%1d\t", Display_F, INSTRUMENT.stateERROR_CODE);
                }
            }
            else
            {
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
                {
                    // 10.14.21 THIS IS A 312.50 PS DEVICE...ONLY 2 DIGITS AFTER DEC POINT
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%9.2fps|P|%1d]:", CurrentDelay_F_PARALLEL, INSTRUMENT.stateERROR_CODE);
                }
                else
                {
                    Display_F = CurrentDelay_F_PARALLEL / 1000;
                    sprintf(BUFFERS.COMMAND_LINE, "Command[%9.5fns|P|%1d]:", Display_F, INSTRUMENT.stateERROR_CODE);
                }
            }
#endif

// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
            if (INSTRUMENT.stateDEVICE_MODE_MT100A) // DISPLAY ON MT-100A MICROTERMINAL
            {
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
                {
                    // DISPLAY IN PS
                    switch (INSTRUMENT.stateDEL_CHANNEL)
                    {
                    case CHANNEL_ONE:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.2fps|1|\x7F  E%d\t%6.2fps|2| ", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F);
                        break;
                    case CHANNEL_TWO:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.2fps|1|   E%d,\t%6.2fps|2|\x7F", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F);
                        break;
                    case CHANNEL_BOTH:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.2fps|1|\x7F  E%d\t%6.2fps|2|\x7F", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F);
                        break;
                    } // end-switch
                }
                else
                {
                    // DISPLAY IN NS
                    switch (INSTRUMENT.stateDEL_CHANNEL)
                    {
                    case CHANNEL_ONE:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.2fns|1|\x7F  E%d\t%6.2fns|2| ", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.0, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.0);
                        break;
                    case CHANNEL_TWO:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.2fns|1|   E%d,\t%6.2fns|2|\x7F", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.0, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.0);
                        break;
                    case CHANNEL_BOTH:
                        sprintf(BUFFERS.COMMAND_LINE, "#%6.2fns|1|\x7F  E%d\t%6.2fns|2|\x7F", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.0, INSTRUMENT.stateERROR_CODE, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.0);
                        break;
                    } // end-switch
                }
            }
            else
            {
                if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
                {
#ifdef DEVICE_XT200_312P
                    switch (INSTRUMENT.stateDEL_CHANNEL)
                    {
                    // 10.14.21 THIS IS A 312.50 PS DEVICE...ONLY 2 DIGITS AFTER DEC POINT
                    case CHANNEL_ONE:
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.2fps |S|%1d]:", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT.stateERROR_CODE);
                        break;
                    case CHANNEL_TWO:
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.2fps |S|%1d]:", INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F, INSTRUMENT.stateERROR_CODE);
                        break;
                    case CHANNEL_BOTH:
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.2fps|1|\x7F\t%6.2fps|2|\x7F%1d]", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F, INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F, INSTRUMENT.stateERROR_CODE);
                        break;
                    } // end-switch
#endif
                }
                else
                {
#ifdef DEVICE_XT200_312P
                    switch (INSTRUMENT.stateDEL_CHANNEL)
                    {
                    case CHANNEL_ONE:
                        Display_F_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.4fns |1|%1d]", Display_F_ONE, INSTRUMENT.stateERROR_CODE);
                        break;
                    case CHANNEL_TWO:
                        Display_F_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.4fns |2|%1d]", Display_F_TWO, INSTRUMENT.stateERROR_CODE);
                        break;
                    case CHANNEL_BOTH:
                        Display_F_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.00;
                        Display_F_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.00;
                        sprintf(BUFFERS.COMMAND_LINE, "Command[%6.4fns|1|\x7F\t%6.4fns|2|\x7F%1d]", Display_F_ONE, Display_F_TWO, INSTRUMENT.stateERROR_CODE);
                        break;
                    } // end-switch
#endif
                }
            }
#endif
            break;

        default:
            break;
        } // end switch //

        // BUFFERS.COMMAND_LINE is formed; send it out over the serial ports
        SYSTEM_OutputTerminal(BUFFERS.COMMAND_LINE);
    } // end if REMOTE_LOCAL_MODE == LOCAL

    // 11.19.21 // ALWAYS UPDATE THE BAR GRAPH WHETHER IN LOCAL OR REMOTE

    // 04.10.18 - determine the device type to determine which bars to light up
#ifdef DEVICE_XT100
    _ValueToUseForDisplay = DISPLAY_SETTINGS.CURRENT_DELAY_F;
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    _ValueToUseForDisplay = DISPLAY_SETTINGS.CURRENT_DELAY_F;
#endif
#ifdef DEVICE_XR100
    _ValueToUseForDisplay = DISPLAY_SETTINGS.CURRENT_DELAY_F;
#endif
#ifdef DEVICE_XT200
    _ValueToUseForDisplay = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F;
#endif

    // EITHER A BARGRAPH_ATTACHED, TFT_DISPLAY, OR XS_PDM BOARD IS ATTACHED
    // DETERMINE IF THIS IS A (XT_BOARD_REV2 WITH BARGRAPH ATTACHED) OR
    // XT_BOARD_REV3 WITH EITHER TFT_ATTACHED OR XSPDM_ATTACHED

#if !defined(XT_BOARD_REV3) // THIS IS ONLY FOR XT_BOARD_REV2 WITH BARGRAPH ATTACHED
    // 02.13.2017 add support to display BarGraphDisplay
    // BarGraphDisplay is a 20x LED display indicating delay setting/total delay
    // DISPLAY_SETTINGS.CURRENT_DELAY_F has the number of picoseconds of delay
    // PARAMETERS.deviceMAX_DELAY_PS has max number of picoseconds of delay
    // 04.10.18 _Percentage = (DISPLAY_SETTINGS.CURRENT_DELAY_F / PARAMETERS.deviceMAX_DELAY_PS);

    _Percentage = (_ValueToUseForDisplay / PARAMETERS.deviceMAX_DELAY_PS);
#if defined(DEVICE_XT200_312P) || defined(DEVICE_XT100_312P)
    // 01.25.22 IF DEVICE_MODE IS PARALLEL IN XT-200-312P OR XT-100-312P, THEN CHANGE TO SHOW BARS CORRECTLY
    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)
    {
        _Percentage = (_ValueToUseForDisplay / (PARAMETERS.deviceMAX_DELAY_PS / 2.0));
    }
#endif

    if (_ValueToUseForDisplay != 0.0)
    {
        // 05.25.18
        if (_Percentage <= 0.050)
        {
            _NumberOfBarsOn_i = 1; // casting _Percentage to integer doesn't work if _Percentage is <= 0.10
        }
        else
        {

            // 05.25.18 Determine if on an INTEGER BOUNDARY for the LED to display or not
            _NumBars_i = (int)(_Percentage * 20);
            _NumBars_f = (float)(_Percentage * 20);
            _NumBarsInt_f = (float)_NumBars_i;
            _Diff = _NumBars_f - _NumBarsInt_f;

            if (_Diff <= 0.001)
            {
                _NumberOfBarsOn_i = (int)(_Percentage * 20); // 05.25.18 BELOW or EQUAL TO integer boundary
            }
            else
            {
                _NumberOfBarsOn_i = ((int)(_Percentage * 20)) + 1; // 05.25.18 ABOVE integer boundary
                if (_NumberOfBarsOn_i > 20)
                {
                    _NumberOfBarsOn_i = 20;
                }
            }
        }
    }
    else
    {
        _NumberOfBarsOn_i = 0;
    }

    switch (_NumberOfBarsOn_i)
    {
    case 0:
        _BarGraphDisplay = 0x00000000;
        break;
    case 1:
        _BarGraphDisplay = 0x00080000;
        break;
    case 20:
        _BarGraphDisplay = 0x000FFFFF;
        break;
    default:
        _BarGraphDisplay = 0x000FFFFF;
        _BarGraphMask = 0x00000000;
        // turn OFF all the LEDS from LED # _NumberOfBarsOn_i
        for (_Index = (19 - _NumberOfBarsOn_i); _Index > 0; _Index--)
        {
            _IndividualBit = 0x00000001;
            _IndividualBit = (_IndividualBit << _Index);
            _BarGraphMask = _BarGraphMask + _IndividualBit; // turn off individual bit
        }
        _BarGraphMask = _BarGraphMask + 0x00000001; // make sure to turn OFF the last bit LSB
        _BarGraphDisplay = (0x000FFFFF & _BarGraphMask);
        _BarGraphDisplay = ~_BarGraphDisplay;
        break;
    }

#ifndef TOP_TO_BOTTOM_NEW_LED
    // THIS IS FOR THE NORMAL FRONT FACING LEFT TO RIGHT
    // 02.05.21 RD03 Make _BarGraphDisplay a GLOBAL Variable
    INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH = _BarGraphDisplay;
    shiftRegBarGraphOutputXT(INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH);
#endif

#ifdef TOP_TO_BOTTOM_NEW_LED
    // THIS IS FOR NEW LED BAR GRAPH WITH TOP TO BOTTOM ORIENTATION FOR NEW XT-200-CHASSIS
    INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH = HWIO_Flip_UL_Word(_BarGraphDisplay);
    HWIO_ShiftRegBarGraphOutputXT(INSTRUMENT_SETTINGS.CURRENT_BAR_GRAPH);
#endif

// 02.08.22 IF SECONDARY_TROMBONE THEN DONT BEEP MICROTERMINAL
#ifndef SECONDARY_TROMBONE
    if ((INSTRUMENT.stateERROR_CODE != 0) && (INSTRUMENT.stateDEVICE_MODE_MT100A))
        SYSTEM_OutputTerminal("*"); // beep the terminal if error code is not ZERO
#endif

#else

    // 03.21.22 XT_BOARD_REV3 ONLY

#if defined(XSPDM_ATTACHED)
    // UPDATE THE NETWORK LED
    if (INSTRUMENT_SETTINGS.CURRENT_LAN_LED_STATUS)
    {
        // TURN ON NETWORK LED WITH A LOW SIGNAL
        BitWrPortI(PADR, &PADRShadow, LOW, XS_LED); // PA5 FOR LED in XS-100
    }
    else
    {
        // TURN OFF NETWORK LED WITH A HIGH SIGNAL
        BitWrPortI(PADR, &PADRShadow, HIGH, XS_LED); // PA5 FOR LED in XS-100
    }
#endif

#if defined(TFT_ATTACHED)

    // IF THE TFT DISPLAY IS ATTACHED, UPDATE THE DISPLAYED VALUES AND UPDATE THE NETWORK INFORMATION
    // DISPLAY_SETTINGS.CURRENT_DELAY_F
    // UPDATE THE TFT SCREEN BASED ON DEVICE TYPE
    SYSTEM_TFT_DISPLAY_UPDATE();

    gselvp(VIEWPORT_NET);

    _IP_ADDRESS = ENET_GetIP(); // GET THE ACTUAL IP ADDRESS
    _PORT_ADDRESS = g_NVParameters.nv_port;
    sprintf(_TFT_DisplayLine, "%s %d", inet_ntoa(_IP_BUFFER, _IP_ADDRESS), _PORT_ADDRESS);
    // IP ADDRESS
    gsetpos(NET_LINE1_X, NET_LINE1_Y);
    gsetcolorf(G_WHITE);
    gsetcolorb(G_BLACK);
    gputs(_TFT_DisplayLine);

    // URL ADDRESS AND HOSTNAME
    gsetpos(NET_LINE2_X, NET_LINE2_Y);
    gsetcolorf(G_WHITE);
    gsetcolorb(G_BLACK);

    sprintf(_TFT_DisplayLine, "%s", g_NVParameters.nv_hostname);
    gputs(_TFT_DisplayLine);

#endif

#endif

} /* end SYSTEM_OutputPrompt */

void SYSTEM_ParseInputCommand(char *cmd_line)
{
    //
    // Parses the input Command line and places up to three arguments into
    // each of cmdARG1, cmdARG2, and cmdARG3.
    //
    //--------------------------------------------------------------------
    // Globals     :  COMMAND_PROMPT[];
    //              cmdARG1  argument #1
    //              cmdARG2  argument #2
    //              cmdARG3  argument #3
    //
    // NAME        : SYSTEM_ParseInputCommand
    // DESCRIPTION : Parses *cmd_line and returns three character arrays.
    // ARGUMENTS   : *cmd_line pointer to command string received
    // RETURNS     : cmdARG1, cmdARG2, and cmdARG3
    // PREREQ      : *cmd_line must contain text of received input
    // GLOBALS     : COMMAND[100], cmdARG1, cmdARG2, and cmdARG3
    // NOTES       :
    //--------------------------------------------------------------------

    short i, j, k, l; // 03.19.18 added k and l
    short i1, i2;     // i1 = index into COMMAND of 1st space
                      // i2 = index into COMMAND of 2nd space
    char COMMAND_COPY[COMMAND_MAX];
    // scans *cmd_line and breaks it up into three arguments, ARG1,ARG2,ARG3
    // assumes ' ' SPACE is used as a delimeter between arguments

    // replace any CR with a space
    for (j = 0; j < strlen(cmd_line); j++)
    {
        if (cmd_line[j] == '\r')
        {
            cmd_line[j] = ' ';
        } // end-if
    }     // end-for

    // FIX FOR VERSION 1.32 ignore \n also!
    for (j = 0; j < strlen(cmd_line); j++)
    {
        if (cmd_line[j] == '\n')
        {
            cmd_line[j] = ' ';
        } // end-if
    }     // end-for

    // 06.02.08 REMOVE ALL BACKSPACE CHARACTERS AND SHIFT
    i1 = 0;
    memset(COMMAND_COPY, 0x00, sizeof(COMMAND_COPY));

    // COMMAND_COPY has copy of cmd_line but without the \b (if any) chars
    for (j = 0; j < strlen(cmd_line); j++)
    {
        if (cmd_line[j] != '\b')
        {
            COMMAND_COPY[i1] = cmd_line[j];
            i1++;
        } // end-if
        else
        {
            i1 = i1 - 1;
            if (i1 < 0)
            {
                i1 = 0;
            }
            COMMAND_COPY[i1] = 0; // put a null char into the space
        }                         // end-else-if
    }                             // end-for

    // COMMAND_COPY has copy of cmd_line but without the \b (if any) chars
    // so put the copy into cmd_line so can parse and process it...

    // CODE RESTORED - 03.19.2018
    // GLOBAL_SETTINGS.COMMAND_LINE_COPY is used to replace g_COMMAND_LINE_COPY

    strcpy(GLOBAL_SETTINGS.COMMAND_LINE_COPY, COMMAND_COPY);

    k = strlen(COMMAND_COPY); // 02.06.09
    l = strlen(GLOBAL_SETTINGS.COMMAND_LINE_COPY);

    // CODE RESTORED 03.19.2018 -- needed because this is for XT-100 HW2 (has GPIB)
    // 10.22.17 if data is from GPIB, then DATA_COUNT is not zero
    // 10.22.17 place an end of line character into the g_COMMAND_LINE_COPY
    // 10.22.17 NOT NEEDED SINCE NO GPIB

    // clear out the three arguments
    memset(cmdARG1, 0x00, sizeof(cmdARG1));
    memset(cmdARG2, 0x00, sizeof(cmdARG2));
    memset(cmdARG3, 0x00, sizeof(cmdARG3));

    i1 = 0;
    i2 = 0;
    i1 = SYSTEM_FindFirstSpace(cmdCOMMAND);  // scan to find 1st space char
    i2 = SYSTEM_FindSecondSpace(cmdCOMMAND); // scan to find 2nd space char

    if ((i1 != 0) && (i2 != 0))
    {
        // printf ("two spaces found i1 = %d, i2 = %d \n\r", i1, i2);
        //  ARG1 is found between 0 and i1
        //  copy COMMAND into cmdARG1 up to the first space
        for (i = 0; i < i1; i++)
        {
            if (i < cmdARG1_MAX)
            { // added 06.03.08
                cmdARG1[i] = cmdCOMMAND[i];
            } // end-if for buffer max protection
        }     // end for

        j = 0;
        // ARG2 is found between i1 and i2
        for (i = i1 + 1; i < i2; i++)
        {
            if (j < cmdARG2_MAX)
            { // added 06.03.08
                cmdARG2[j] = cmdCOMMAND[i];
                j++;
            } // end-if for buffer max protection
        }     // end for

        j = 0;
        // ARG3 is found between i2 and strlen(COMMAND)
        if (strlen(cmdCOMMAND) > i2)
        {
            for (i = i2 + 1; i < strlen(cmdCOMMAND); i++)
            {
                // 01-24-05 -- ignore spaces, cr and lf at the end of arg3
                if ((cmdCOMMAND[i] != ' ') && (cmdCOMMAND[i] != '\r') && (cmdCOMMAND[i] != '\n'))
                {
                    if (j < cmdARG3_MAX)
                    { // added 06.03.08
                        cmdARG3[j] = cmdCOMMAND[i];
                        j++;
                    } // end-if for buffer max protection check
                }     /* end if */
            }         // end for
        }             // endif
                      // printf ("cmdARG1 =>%s<=, cmdARG2 =>%s<=, cmdARG3 =>%s<=, Length = %d", cmdARG1, cmdARG2, cmdARG3, strlen(COMMAND));
    }                 // end if clause
    else if ((i1 != 0) && (i2 == 0))
    {
        // printf ("one space found i1 = %d, i2 = %d \n\r", i1, i2);
        //  ARG1 is found between 0 and i1
        for (i = 0; i < i1; i++)
        {
            if (i < cmdARG1_MAX)
            { // added 06.03.08
                cmdARG1[i] = cmdCOMMAND[i];
            } // end-if for buffer max protection check
        }     // end for
    }         // end-else-if

    cmdARG1[cmdARG1_MAX - 1] = 0x00; // 06.03.08
    cmdARG2[cmdARG2_MAX - 1] = 0x00; // always ensure an end!
    cmdARG3[cmdARG3_MAX - 1] = 0x00; // 06.03.08

    /*i1 = strlen(cmdARG1);
   printf ("strlen(cmdARG1)[%d]:-->%s<--\n\r",i1,cmdARG1);
   i1 = strlen(cmdARG2);
   printf ("strlen(cmdARG2)[%d]:-->%s<--\n\r",i1,cmdARG2);
   i1 = strlen(cmdARG3);
   printf ("strlen(cmdARG3)[%d]:-->%s<--\n\r",i1,cmdARG3);
   */

} // SYSTEM_ParseInputCommand

void SYSTEM_AdjustNVParametersXT(void)
{
    //  --------------------------------------------------------------
    //  Function: AdjustNVParametersXSUM(void)
    //  --------------------------------------------------------------
    //  Purpose: Adjusts the XORsum of the RAM parameter structure
    //  to be correct. This is called by SaveNVParameters
    //  to correct the XORsum before saving to the User
    //  Block.
    //  --------------------------------------------------------------

    unsigned char *tptr;
    unsigned char tXSUM;
    int i;

    g_NVParameters.nv_XSUM = 0;

    tptr = (unsigned char *)&g_NVParameters;
    tXSUM = 0;
    for (i = 0; i < sizeof(DEVICE_NVPARAMETERS); i++)
        tXSUM ^= tptr[i];
    tXSUM ^= MAGIC_XSUM_BYTE;
    g_NVParameters.nv_XSUM = tXSUM;

    #if defined(DEBUG_WEB)
    printf("AdjustNVParameters tXSUM = %3d \r\n", tXSUM);
    #endif
}

void SYSTEM_BeepInvalidEntry(void)
{

    unsigned int wait, wait_loops;

    sprintf(BUFFERS.DISPLAY_LINE, "\tINVALID ENTRY   ");
    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

    sprintf(BUFFERS.DISPLAY_LINE, "*");
    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

    for (wait_loops = 0; wait_loops < 1; wait_loops++)
    {
        for (wait = 0; wait < 50000; wait++)
        {
        }
    }
}

void SYSTEM_ExecuteTromboneCalibration(void)
{

#if (defined(DEVICE_XT100) || defined(DEVICE_XT200))
    //
    // internal function to perform Trombone Calibration
    //

    if (MOTOR_Calibration() == TRUE)
    {
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
        INSTRUMENT_SETTINGS.CURRENT_DELAY = 0.0;
        DISPLAY_SETTINGS.CURRENT_DELAY_F = 0.0;
        DISPLAY_SETTINGS.CURRENT_DELAY_E = 0.0;
        INSTRUMENT.stateERROR = FALSE;
    }
    else
    {
        INSTRUMENT.stateERROR_CODE = NO_CALIBRATION;
        INSTRUMENT.stateERROR = TRUE;
    }
#endif
}

void SYSTEM_ExecuteCommand(void)
{
    //
    //	Description:	Execute ONE command (in cmdARG1,cmdARG2, and cmdARG3)
    //	Arguments:		cmdARG1,cmdARG2, and cmdARG3
    //	Returns:		None.
    //	Pre-req:		cmdARG1,cmdARG2, and cmdARG3 has been parsed and is in RAW format.
    //	Globals:
    //	Notes:
    //

    int i;
    // 06.08.08 Upconvert any lower case alpha chars to upper case to simplify
    if (strlen(cmdARG1) != 0)
    {
        for (i = 0; i < strlen(cmdARG1); i++)
        {
            if ((cmdARG1[i] >= 'a') && (cmdARG1[i] <= 'z'))
            {
                cmdARG1[i] = cmdARG1[i] - 0x20;
            } // end-if
        }     // end-for
    }         // end-if

    if (strlen(cmdARG2) != 0)
    {
        for (i = 0; i < strlen(cmdARG2); i++)
        {
            if ((cmdARG2[i] >= 'a') && (cmdARG2[i] <= 'z'))
            {
                cmdARG2[i] = cmdARG2[i] - 0x20;
            } // end-if
        }     // end-for
    }         // end-if

    if (strlen(cmdARG3) != 0)
    {
        for (i = 0; i < strlen(cmdARG3); i++)
        {
            if ((cmdARG3[i] >= 'a') && (cmdARG3[i] <= 'z'))
            {
                cmdARG3[i] = cmdARG3[i] - 0x20;
            } // end-if
        }     // end-for
    }         // end-if

    switch (strlen(cmdARG1))
    { // switch based on # of chars in command line

    case 1: // 1 character was entered //
        if ((strcmp(cmdARG1, "+") == 0))
        {
            cmdSTEP_INC();
        } // end-if
        else
        {
            if ((strcmp(cmdARG1, "-") == 0))
            {
                cmdSTEP_DEC();
            } // end-if
            else
            {
                if ((strcmp(cmdARG1, "\x13") == 0))
                { //@F -- SETUP KEY
// FUNCTION MENU // 03.29.18 add additional config options
#ifdef DEVICE_XT100
                    sprintf(BUFFERS.DISPLAY_LINE, "#1=ADDR,2=MODE, \t3=TERM,4=OVER?");
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                    sprintf(BUFFERS.DISPLAY_LINE, "#1=ADDR,2=MODE, \t3=TERM,4=OVER?");
#endif
#ifdef DEVICE_XR100
                    sprintf(BUFFERS.DISPLAY_LINE, "#1=ADDR,2=MODE, \t3=TERM?");
#endif
#ifdef DEVICE_XT200
                    sprintf(BUFFERS.DISPLAY_LINE, "#1=ADDR,2=CH1/2/B\t3=TM,4=OS,5=CY?");
#endif
// 04.26.22
#if defined(DEVICE_XS100)
                    sprintf(BUFFERS.DISPLAY_LINE, "#1=ADDR,2=TERM, \t3=SET,4=SWEEP?");
#endif
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                    INSTRUMENT.stateMENU_MODE = 1;
                } // end-if
                else
                {
                    if ((strcmp(cmdARG1, "\x15") == 0))
                    { //@D -- ns/ps KEY
#ifdef DEVICE_XT100
                      // DELAY - TOGGLE between NS and PS display
                        // toggle between PS and NS display modes
                        sprintf(cmdARG1, "UNITS"); // 07.26.21 replaces MODE with UNITS
                        if (INSTRUMENT.stateDEVICE_DISPLAY_NS)
                        {
                            INSTRUMENT.stateDEVICE_DISPLAY_NS = FALSE;
                            sprintf(cmdARG2, "PS");
                        }
                        else
                        {
                            INSTRUMENT.stateDEVICE_DISPLAY_NS = TRUE;
                            sprintf(cmdARG2, "NS");
                        } // end-if
                        cmdUNITS();
                        INSTRUMENT.stateMENU_MODE = 0;
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                        // DELAY - TOGGLE between NS and PS display
                        // toggle between PS and NS display modes
                        sprintf(cmdARG1, "UNITS"); // 07.26.21 replaces MODE with UNITS
                        if (INSTRUMENT.stateDEVICE_DISPLAY_NS)
                        {
                            INSTRUMENT.stateDEVICE_DISPLAY_NS = FALSE;
                            sprintf(cmdARG2, "PS");
                        }
                        else
                        {
                            INSTRUMENT.stateDEVICE_DISPLAY_NS = TRUE;
                            sprintf(cmdARG2, "NS");
                        } // end-if
                        cmdUNITS();
                        INSTRUMENT.stateMENU_MODE = 0;
#endif
#if (defined(DEVICE_XR100) || defined(DEVICE_XS100))
                        // DELAY - TOGGLE between NS and PS display
                        // toggle between PS and NS display modes
                        sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                        if (INSTRUMENT.stateDEVICE_DISPLAY_NS)
                        {
                            INSTRUMENT.stateDEVICE_DISPLAY_NS = FALSE;
                            sprintf(cmdARG2, "PS");
                        }
                        else
                        {
                            INSTRUMENT.stateDEVICE_DISPLAY_NS = TRUE;
                            sprintf(cmdARG2, "NS");
                        } // end-if
                        cmdUNITS();
                        INSTRUMENT.stateMENU_MODE = 0;
#endif
#ifdef DEVICE_XT200
                        // DELAY - TOGGLE between NS and PS display
                        // toggle between PS and NS display modes
                        switch (INSTRUMENT.stateMT100A_DISPLAY)
                        {
                        case CHAN_ONE_PS:
                            switch (INSTRUMENT.stateCYCLE_MODE)
                            {
                            case CYCLE_SEQ:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "NS");
                                cmdUNITS();
                                break;
                            case CYCLE_UNIT:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
                                sprintf(cmdARG1, "UNITS"); //// 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "NS");
                                cmdUNITS();
                                break;
                            case CYCLE_CHANNEL:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_TWO_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
                                break;
                            }      // end switch
                            break; // end CHAN_ONE_PS
                        case CHAN_ONE_NS:
                            switch (INSTRUMENT.stateCYCLE_MODE)
                            {
                            case CYCLE_SEQ:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_TWO_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "PS");
                                cmdUNITS();
                                break;
                            case CYCLE_UNIT:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "PS");
                                cmdUNITS();
                                break;
                            case CYCLE_CHANNEL:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_TWO_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
                                break;
                            }      // end switch
                            break; // end CHAN_ONE_NS
                        case CHAN_TWO_PS:
                            switch (INSTRUMENT.stateCYCLE_MODE)
                            {
                            case CYCLE_SEQ:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_TWO_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "NS");
                                cmdUNITS();
                                break;
                            case CYCLE_UNIT:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_TWO_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "NS");
                                cmdUNITS();
                                break;
                            case CYCLE_CHANNEL:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_BOTH_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH;
                                break;
                            }      // end switch
                            break; // end CHAN_TWO_PS
                        case CHAN_TWO_NS:
                            switch (INSTRUMENT.stateCYCLE_MODE)
                            {
                            case CYCLE_SEQ:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_BOTH_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "PS");
                                cmdUNITS();
                                break;
                            case CYCLE_UNIT:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_TWO_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "PS");
                                cmdUNITS();
                                break;
                            case CYCLE_CHANNEL:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_BOTH_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH;
                                break;
                            }      // end switch
                            break; // end CHAN_TWO_NS
                        case CHAN_BOTH_PS:
                            switch (INSTRUMENT.stateCYCLE_MODE)
                            {
                            case CYCLE_SEQ:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_BOTH_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "NS");
                                cmdUNITS();
                                break;
                            case CYCLE_UNIT:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_BOTH_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "NS");
                                cmdUNITS();
                                break;
                            case CYCLE_CHANNEL:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
                                break;
                            } // end switch
                            break;
                        case CHAN_BOTH_NS:
                            switch (INSTRUMENT.stateCYCLE_MODE)
                            {
                            case CYCLE_SEQ:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "PS");
                                cmdUNITS();
                                break;
                            case CYCLE_UNIT:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_BOTH_PS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH;
                                sprintf(cmdARG1, "UNITS"); // 07.26.21 replace MODE with UNITS
                                sprintf(cmdARG2, "PS");
                                cmdUNITS();
                                break;
                            case CYCLE_CHANNEL:
                                INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_NS;
                                INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
                                break;
                            } // end switch
                            break;
                        } // end switch
                        INSTRUMENT.stateMENU_MODE = 0;
#endif
                    } // end-if
                    else
                    {
                        if ((strcmp(cmdARG1, "\x16") == 0))
                        { // was @R
                          //  DIAG MENU // 04.26.22 ADD SUPPORT FOR XS-100
#if !defined(DEVICE_XS100)
                            sprintf(BUFFERS.DISPLAY_LINE, "#1=REL,2=CAL,\t3=RST,4=CTS?");
#else
                            sprintf(BUFFERS.DISPLAY_LINE, "#1=PIN,       \t3=RST,4=CTS?");
#endif
                            SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);
                            sprintf(cmdARG1, "");
                            INSTRUMENT.stateMENU_MODE = 14;
                        }
                        else
                        {
                            if (INSTRUMENT.stateMENU_MODE == 0)
                            {
                                if ((SYSTEM_CheckNumericAndSetup(TRUE) == 0) ||
                                    (strcmp(cmdARG1, "0") == 0))
                                {
                                    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                    cmdSET_DELAY();
                                }
                            }
                            else
                            {
                                SYSTEM_HandleMenuMode();
                            } // end-if
                        }     // end-if
                    }
                }
            }
        }
        break;

    case 2: // 2 characters were entered //
#if (!defined(DEVICE_XR100) && !defined(DEVICE_XS100))
        if ((strcmp(cmdARG1, "ML") == 0))
        {
            MOTOR_MoveLeft(); // COMMAND MOVE LEFT ARG2 STEPS
        }                     // end-if
        else
        {
            if ((strcmp(cmdARG1, "MR") == 0))
            {
                MOTOR_MoveRight(); // COMMAND MOVE RIGHT ARG2 STEPS
            }                      // end-if
            else
            {
                if ((strcmp(cmdARG1, "IP") == 0))
                {
                    MOTOR_Command(IP_COMMAND, 0, WAIT); // GET ENCODER POSITION
                    SYSTEM_OutputQueryResponse();
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                } // end-if
                else
                {
                    if ((strcmp(cmdARG1, "MO") == 0))
                    {
                        MOTOR_Command(MO, 0, WAIT); // COMMAND MOVE TO OPTO DETECTOR SIGNAL HIGH
                    }                               // end-if
                    else
                    {
                        if ((strcmp(cmdARG1, "AR") == 0))
                        {
                            MOTOR_Command(AR, 0, WAIT); // SET ALARM RESET
                        }                               // end-if
                        else
                        {
                            if ((strcmp(cmdARG1, "SC") == 0))
                            {
                                MOTOR_Command(SC, 0, WAIT); // GET STATUS CODE
                                SYSTEM_OutputQueryResponse();
                                INSTRUMENT.stateERROR_CODE = NO_ERROR;
                            } // end-if
                            else
                            {
                                if ((strcmp(cmdARG1, "DI") == 0))
                                {
                                    MOTOR_Command(DI, 0, WAIT); // GET SET DISTANCE/POSITION
                                    SYSTEM_OutputQueryResponse();
                                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                } // end-if
                                else
                                {
                                    if ((strcmp(cmdARG1, "AL") == 0))
                                    {
                                        MOTOR_Command(AL, 0, WAIT); // GET ALARM CODE
                                        SYSTEM_OutputQueryResponse();
                                        INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                    } // end-if
                                    else
                                    {
                                        if ((strcmp(cmdARG1, "IS") == 0))
                                        {
                                            MOTOR_Command(IS, 0, WAIT); // GET INPUT STATUS
                                            SYSTEM_OutputQueryResponse();
                                            INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                        } // end-if
                                        else
                                        {
                                            if ((strcmp(cmdARG1, "RE") == 0))
                                            {
                                                MOTOR_Command(RE, 0, WAIT); // SET RESET DRIVE
                                            }                               // end-if
                                            else
                                            {
                                                if ((strcmp(cmdARG1, "VE") == 0))
                                                {
                                                    MOTOR_Command(VE, 0, WAIT); // GET VELOCITY
                                                    SYSTEM_OutputQueryResponse();
                                                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                                } // end-if
                                                else
                                                {
                                                    if ((strcmp(cmdARG1, "AC") == 0))
                                                    {
                                                        MOTOR_Command(AC, 0, WAIT); // GET ALARM CODE
                                                        SYSTEM_OutputQueryResponse();
                                                        INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                                    } // end-if
                                                    else
                                                    {
                                                        if ((strcmp(cmdARG1, "DE") == 0))
                                                        {
                                                            MOTOR_Command(DE, 0, WAIT); // GET DECELERATION RATE
                                                            SYSTEM_OutputQueryResponse();
                                                            INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                                        } // end-if
                                                        else
                                                        {
                                                            if ((strcmp(cmdARG1, "ER") == 0))
                                                            {
                                                                MOTOR_Command(ER, 0, WAIT); // GET ENCODER RESOLUTION
                                                                SYSTEM_OutputQueryResponse();
                                                                INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                                            } // end-if
                                                            else
                                                            {
                                                                if ((strcmp(cmdARG1, "MD") == 0))
                                                                {
                                                                    MOTOR_SetDI(); // COMMAND SET DISTANCE ARG2 STEPS
                                                                }                  // end-if
                                                                else
                                                                {
                                                                    if ((strcmp(cmdARG1, "ME") == 0))
                                                                    {
                                                                        MOTOR_Command(ME, 0, WAIT); // SET MOTOR ENABLE
                                                                    }                               // end-if
                                                                    else
                                                                    {
                                                                        if ((strcmp(cmdARG1, "SZ") == 0))
                                                                        {
                                                                            MOTOR_SetZero(); // COMMAND SET ZERO POSITION,EP=0,SP=0
                                                                        }                    // end-if
                                                                        else
                                                                        {
                                                                            if ((strcmp(cmdARG1, "IV") == 0))
                                                                            {
                                                                                MOTOR_Command(IV, 0, WAIT);
                                                                                SYSTEM_OutputQueryResponse();
                                                                                INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                                                            } // end-if
                                                                            else
                                                                            {
                                                                                if ((strcmp(cmdARG1, "RS") == 0))
                                                                                {
                                                                                    MOTOR_Command(RS, 0, WAIT); // GET REQUEST STATUS
                                                                                    SYSTEM_OutputQueryResponse();
                                                                                    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
                                                                                }                                          // end-if
                                                                                else
                                                                                {
#endif
                                                                                    if ((SYSTEM_CheckNumericAndSetup(TRUE) == 0) ||
                                                                                        (strcmp(cmdARG1, "00") == 0) ||
                                                                                        (strcmp(cmdARG1, "0.") == 0) ||
                                                                                        (strcmp(cmdARG1, ".0") == 0))
                                                                                    {
                                                                                        INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                                                                        cmdSET_DELAY();
                                                                                    } // end-if
#if (!defined(DEVICE_XR100) && !defined(DEVICE_XS100))
                                                                                } // "RS"
                                                                            }     // "IV"
                                                                        }         // "SZ"
                                                                    }             // "MD" to set DI
                                                                }                 // "ME" Motor Enable
                                                            }                     // "ER"
                                                        }                         // "DE"
                                                    }                             // "AC"
                                                }                                 // "VE"
                                            }                                     // "RE"
                                        }                                         // "IS"
                                    }                                             // "AL"
                                }                                                 // "DI"
                            }                                                     // "SC"
                        }                                                         // "AR"
                    }                                                             // "MO"
                }                                                                 // "IP"
            }                                                                     // "MR"
        }                                                                         // "ML"
#endif
        break;

    case 3:
        // check all three letter commands
        if (strcmp(cmdARG1, "DEL") == 0)
        {
            // DEL or del matched
            if (strlen(cmdARG2) != 0)
            {
                INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                cmdSET_DELAY();
            }
            else
            {
                // DEL commands with no arguments so IGNORE it
                INSTRUMENT.stateERROR = TRUE;
                if (INSTRUMENT.stateCMD_FROM_TERM)
                {
                    SYSTEM_OutputTerminal("INVALID ARGUMENT\r\n");
                    INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
                }
            } // end else
        }     // end-if
        else
        {
#ifndef DEVICE_XT200
            if (strcmp(cmdARG1, "REL") == 0)
            {
                INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
// BUILD RD102221
//#ifdef DEVICE_XT100_200N
#ifdef USE_DELAY_UL_TABLE
                cmdREL_UL();
#else
                cmdREL();
#endif
            } // end if
            else
            {
#endif
                if (strcmp(cmdARG1, "INC") == 0)
                {
                    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                    cmdSTEP_INC();
                } // end if
                else
                {
                    if (strcmp(cmdARG1, "DEC") == 0)
                    {
                        INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                        cmdSTEP_DEC();
                    } // end if
                    else
                    {
                        if (strcmp(cmdARG1, "NET") == 0)
                        {
                            cmdNET();
                        } // end if
                        else
                        {
#ifndef DEVICE_XR100
                            if (strcmp(cmdARG1, "OVS") == 0)
                            {
                                // OVS set overshoot amount into NVRAM
                                cmdOVS();
                            } // end if
                            else
                            {
#endif
                                if (strcmp(cmdARG1, "REM") == 0)
                                {
                                    // set REMOTE MODE
                                    cmdREMOTE();
                                } // end if
                                else
                                {
                                    if (strcmp(cmdARG1, "NL?") == 0)
                                    {
                                        // get NET LED QUERY RD03
                                        cmdNETSTATEQ();
                                    } // end if
                                    else
                                    {
                                        // BUILD2203_RD112021
                                        if (strcmp(cmdARG1, "MEM") == 0)
	                                    {
	                                        // store delay settings in memory array
	                                        cmdMEMSTORE();
	                                    } // end if
	                                    else
                                        {
#if defined(DEVICE_XS100)
	                                        // added 08.19.22
	                                        if (strcmp(cmdARG1, "PIN") == 0)
	                                        {
	                                            XSPDM_cmdRELPD(); // TURN ON EACH PIN DIODE
	                                        } // end if
	                                        else
	                                        {
#endif
	                                        if ((SYSTEM_CheckNumericAndSetup(TRUE) == 0) ||
	                                            (strcmp(cmdARG1, "000") == 0) ||
	                                            (strcmp(cmdARG1, "0.0") == 0) ||
	                                            (strcmp(cmdARG1, ".00") == 0) ||
	                                            (strcmp(cmdARG1, "00.") == 0))
	                                        {
	                                            cmdSET_DELAY();
	                                        } // end-if
#if defined(DEVICE_XS100)
											} // PIN command
#endif
                                        } // MEM command
                                    }     // NETSTATEQ
                                }         // REMOTE_MODE
#ifndef DEVICE_XR100
                            } // OVS
#endif
                        } // net
                    }     // dec
                }         // inc
#ifndef DEVICE_XT200
            } // rel
#endif
        } // del
        break;

    case 4:
        if (strcmp(cmdARG1, "*RST") == 0)
        {
            //*RST or *rst matched
            cmdRST(2); // 04.10.18
        }              // end *RST or *rst (RESET)
        else
        {
            if (strcmp(cmdARG1, "*CAL") == 0)
            {
                INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                //*CAL or *cal matched
                cmdCAL();
            } // end if
            else
            {
                if (strcmp(cmdARG1, "*OPC") == 0)
                {
                    // CLEAR OPERATION COMPLETE BIT
                    cmdOPC();
                } // end if
                else
                {
                    if (strcmp(cmdARG1, "*CLS") == 0)
                    {
                        // EVENT STATUS BIT SET
                        cmdCLS();
                    } // end if
                    else
                    {
                        if (strcmp(cmdARG1, "STEP") == 0)
                        {
                            // STEP or step matched
                            cmdSTEP();
                        } // end if
                        else
                        {
                            if (strcmp(cmdARG1, "DEL?") == 0)
                            {
// 03.29.18 handle additional model types
#ifdef DEVICE_XT100
#ifndef DEVICE_XT100_200N

                                if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                                {
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 1.0E-12;
                                }
                                else
                                {
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 0.50E-12;
                                }
                                INSTRUMENT.stateERROR = FALSE;
                                INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                // 11.09.21 was .4e
                                // sprintf(BUFFERS.DISPLAY_LINE, "%12.4e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_E);
                                // 11.09.21 change to .6e
                                sprintf(BUFFERS.DISPLAY_LINE, "%12.6e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_E);

                                SYSTEM_OutputQueryResponse();
#else
                                // 10.27.21 BUILD 102121
                                // FOR DEVICE_XT100_200N, CANNOT DISPLAY USING EXPONENT NOTATION
                                if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                                {
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 1.0E-12;
                                }
                                else
                                {
// 11.11.21 BUILD2112_RD102121_RD111121
// 11.15.21 PARALLEL MODE
#ifndef DEVICE_XT200_312P
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 0.50E-12;
#else
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 1.0E-12;
#endif
                                }
                                INSTRUMENT.stateERROR = FALSE;
                                INSTRUMENT.stateERROR_CODE = NO_ERROR;

                                // 10.27.21 DETERMINE THE MODE TO DETERMINE WHAT TO DISPLAY
                                // ORG FOR EXP NOTATION -- NEED TO REPLACE THIS
                                // sprintf(BUFFERS.DISPLAY_LINE, "%12.4e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_E);

                                if (INSTRUMENT_SETTINGS.CURRENT_UNITS == NS)
                                { // display NS: nnn.pppf to four digits of precision
                                    sprintf(BUFFERS.DISPLAY_LINE, "%12.6e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_E);
                                }
                                else
                                { // display ps: pppppp.ff to two digits of precision
                                    sprintf(BUFFERS.DISPLAY_LINE, "%12.7e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_E);
                                }

                                SYSTEM_OutputQueryResponse();

#endif
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
                                if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                                {
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 1.0E-12;
                                }
                                else
                                {
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 0.50E-12;
                                }
                                INSTRUMENT.stateERROR = FALSE;
                                INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                sprintf(BUFFERS.DISPLAY_LINE, "%12.4e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_E);

                                SYSTEM_OutputQueryResponse();
#endif

#if (defined(DEVICE_XR100) || defined(DEVICE_XS100))
                                if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                                {
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 1.0E-12;
                                }
                                else
                                {
                                    DISPLAY_SETTINGS.CURRENT_DELAY_E = INSTRUMENT_SETTINGS.CURRENT_DELAY * 0.50E-12;
                                }
                                INSTRUMENT.stateERROR = FALSE;
                                INSTRUMENT.stateERROR_CODE = NO_ERROR;
                                sprintf(BUFFERS.DISPLAY_LINE, "%12.4e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_E);

                                SYSTEM_OutputQueryResponse();
#endif

#ifdef DEVICE_XT200
                                cmdDEL_ONE_TWO_Q();
#endif
                            } // end if
                            else
                            {
                                if (strcmp(cmdARG1, "ERR?") == 0)
                                {
                                    cmdERR();
                                }
                                else
                                {
                                    if (strcmp(cmdARG1, "NET?") == 0)
                                    {
                                        cmdNETQ();
                                    }
                                    else
                                    {
#ifndef DEVICE_XR100
                                        if (strcmp(cmdARG1, "OVER") == 0)
                                        {
                                            cmdOVER();
                                        }
                                        else
                                        {
#endif
#ifndef DEVICE_XT200
                                            if (strcmp(cmdARG1, "REL?") == 0)
                                            {
// BUILD RD102221
// 11.07.21 #ifdef DEVICE_XT100_200N
#ifdef USE_DELAY_UL_TABLE
                                                cmdQUERYR_UL();
#else
                                                cmdRELQ();
#endif
                                            }
                                            else
                                            {
#endif
                                                if (strcmp(cmdARG1, "NET?") == 0)
                                                {
                                                    cmdNETQ();
                                                }
                                                else
                                                {
#ifndef DEVICE_XT200
                                                    if (strcmp(cmdARG1, "RELC") == 0)
                                                    {
                                                        INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                                        cmdRELC();
                                                    }
                                                    else
                                                    {
#endif
#ifndef DEVICE_XR100
                                                        if (strcmp(cmdARG1, "MODE") == 0)
                                                        { // added for compatability for XT-100 05/19/17
                                                            cmdMODE();
                                                        }
                                                        else
                                                        {
                                                            if (strcmp(cmdARG1, "OVS?") == 0)
                                                            { // 07.27.17 OVS ? overshoot query
                                                                // OVS? query overshoot amount from NVRAM
                                                                cmdOVSQ();
                                                            } // end if
                                                            else
                                                            {
#endif
                                                                if (strcmp(cmdARG1, "REM?") == 0)
                                                                {
                                                                    // query REMOTE_LOCAL_MODE
                                                                    cmdREMQ();
                                                                } // end if
                                                                else
                                                                {
#ifdef DEVICE_XT200
                                                                    if (strcmp(cmdARG1, "DEL1") == 0)
                                                                    { // 04.10.18 added
                                                                        INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                                                        cmdDEL_ONE();
                                                                    } // end if
                                                                    else
                                                                    {
                                                                        if (strcmp(cmdARG1, "DEL2") == 0)
                                                                        { // 04.10.18 added
                                                                            INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                                                            cmdDEL_TWO();
                                                                        } // end if
                                                                        else
                                                                        {
#endif
                                                                            if (strcmp(cmdARG1, "TERM") == 0) // 11.19.21 BUILD_2203
                                                                            {
                                                                                cmdTERM();
                                                                            }
                                                                            else
                                                                            {
                                                                                if (strcmp(cmdARG1, "HWFD") == 0)
                                                                                { // 8.16.21
                                                                                    cmdHWFD();
                                                                                }
                                                                                else
                                                                                {
#if defined(DEVICE_XS100)
                                                                                    if (strcmp(cmdARG1, "PINR") == 0)
                                                                                    { // 04.27.22 FOR XS-100
                                                                                        XSPDM_cmdPINR();
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        if (strcmp(cmdARG1, "PIN?") == 0)
                                                                                        { // 04.27.22 FOR XS-100
                                                                                            XSPDM_cmdPINQ();
                                                                                        }
                                                                                        else
                                                                                        {
#endif

#ifdef DEVICE_XR100
	                                                                                if (strcmp(cmdARG1, "MEM?") == 0)
	                                                                                { // 8.16.21
	                                                                                    cmdMEMQ();
	                                                                                }
	                                                                                else
	                                                                                {
#endif
                                                                                            if ((SYSTEM_CheckNumericAndSetup(TRUE) == 0) ||
                                                                                                (strcmp(cmdARG1, "0000") == 0) ||
                                                                                                (strcmp(cmdARG1, "0.00") == 0) ||
                                                                                                (strcmp(cmdARG1, ".000") == 0) ||
                                                                                                (strcmp(cmdARG1, "000.") == 0) ||
                                                                                                (strcmp(cmdARG1, "00.0") == 0))
                                                                                            {
                                                                                                INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                                                                                cmdSET_DELAY();
                                                                                            } // checkNumeric
#ifdef DEVICE_XR100
																					} // cmdMEMQ
#endif

#if defined(DEVICE_XS100)
                                                                                        } // PIN?
                                                                                    }     // PINR
#endif
                                                                                } // cmdHWFD
                                                                            }     // cmdTERM
#ifdef DEVICE_XT200
                                                                        } // cmdDEL_TWO
                                                                    }     // cmdDEL_ONE
#endif
                                                                } // query REMOTE_LOCAL_MODE
#ifndef DEVICE_XR100
                                                            } // OVS?
                                                        }     // mode
#endif
#ifndef DEVICE_XT200
                                                    } // RELC
#endif
                                                } // NET?
#ifndef DEVICE_XT200
                                            } // REL?
#endif

#ifndef DEVICE_XR100
                                        } // OVER
#endif
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        break;

    case 5:
        if (strcmp(cmdARG1, "*IDN?") == 0)
        {
            cmdIDN();
        } // end *IDN? or *idn?
        else
        {
            if (strcmp(cmdARG1, "*CAL?") == 0)
            {
                //*CAL? or *cal? matched
                cmdCAL();
                cmdERR();
            } // end *CAL? or *cal?
            else
            {
                if (strcmp(cmdARG1, "*ERR?") == 0)
                {
                    //*ERR? or *err? matched
                    cmdERR();
                } // end *ERR? or *err?
                else
                {
                    if (strcmp(cmdARG1, "STEP?") == 0)
                    {
                        // STEP? or step? matched
                        cmdSTEPQ();
                    } // end STEP? or step?
                    else
                    {
                        if (strcmp(cmdARG1, "NETM?") == 0)
                        {
                            cmdNETMQ();
                        }
                        else
                        {
#ifndef DEVICE_XR100
                            if (strcmp(cmdARG1, "OVER?") == 0)
                            {
                                cmdOVERQ();
                            }
                            else
                            {
#endif
                                if (strcmp(cmdARG1, "*TST?") == 0)
                                {
                                    cmdTSTQ();
                                    cmdCAL();
                                    cmdERR();
                                }
                                else
                                {
                                    if (strcmp(cmdARG1, "*OPC?") == 0)
                                    {
                                     	cmdOPCQ();
                                    }
                                    else
                                    {
                                        if (strcmp(cmdARG1, "MODE?") == 0)
                                        {
                                            // MODE? or mode? matched
                                            cmdMODEQ();
                                        } // end MODE? or mode?
                                        else
                                        {
#ifdef DEVICE_XT200
                                            if (strcmp(cmdARG1, "DEL1?") == 0)
                                            {
                                                cmdDEL_ONE_Q(); // added 04.10.18
                                            }
                                            else
                                            {
                                                if (strcmp(cmdARG1, "DEL2?") == 0)
                                                {
                                                    cmdDEL_TWO_Q(); // added 04.10.18
                                                }
                                                else
                                                {
#endif
                                                    if (strcmp(cmdARG1, "TERM?") == 0) // 11.19.21 BUILD_2203
                                                    {
                                                        cmdTERMQ(); // added 04.10.18
                                                    }
                                                    else
                                                    {
                                                        if (strcmp(cmdARG1, "UNITS") == 0)
                                                        {
                                                            cmdUNITS(); // added 04.10.18
                                                        }
                                                        else
                                                        {

#if defined(DEVICE_XS100)
                                                            if (strcmp(cmdARG1, "SWCYC") == 0)
                                                            {
                                                                XSPDM_cmdSW_SET_CYCLES(); // 05.06.22
                                                            }
                                                            else
                                                            {
                                                                if (strcmp(cmdARG1, "SWEEP") == 0)
                                                                {
                                                                    XSPDM_cmdXS_SWEEP(); // 05.06.22
                                                                }
                                                                else
                                                                {

#endif
                                                                    if (SYSTEM_CheckNumericAndSetup(TRUE) == 0)
                                                                    {
                                                                        INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                                                        cmdSET_DELAY();
                                                                    } // check numeric
#if defined(DEVICE_XS100)
                                                                } // XSPDM_cmdXS_SWEEP
                                                            }     // XSPDM_cmdSW_SET_CYCLES
#endif

                                                        } // added 07.26.21 cmdUNITS
                                                    }     // cmdTERMQ
#ifdef DEVICE_XT200
                                                } // cmdDEL_TWOQ
                                            }     // cmdDEL_ONEQ
#endif
                                        } // MODEQ
                                    }     // *OPC?
                                }         // *TST?
#ifndef DEVICE_XR100
                            } // OVER?
#endif
                        } // NETM?
                    }     // STEP?
                }         // *ERR?
            }             // *CAL?
        }                 // *IDN?

        break;

    case 6:

        if (strcmp(cmdARG1, "UNITS?") == 0)
        {
            cmdUNITSQ(); // added 04.10.18
        }
        else
        {
#if defined(DEVICE_XS100)
            if (strcmp(cmdARG1, "SWCYC?") == 0)
            {
                XSPDM_cmdSW_CYCLESQ(); // 05.06.22
            }
            else
            {
                if (strcmp(cmdARG1, "SWSTOP") == 0)
                {
                    XSPDM_cmdSW_STOP(); // 05.06.22
                }
                else
                {
                    if (strcmp(cmdARG1, "SWTRIG") == 0)
                    {
                        INSTRUMENT.stateEXT_HW_TRIGGER = TRUE; // SOFTWARE TRIGGER SAME AS HARDWARE TRIGGER 05.06.22
                    }
                    else
                    {
                        if (strcmp(cmdARG1, "SWROLL") == 0)
                        {
                            XSPDM_cmdSW_SET_ROLL(); // 05.06.22
                        }
                        else
                        {
                            if (strcmp(cmdARG1, "SWTYPE") == 0)
                            {
                                XSPDM_cmdSW_SET_TYPE(); // 05.06.22
                            }
                            else
                            {
#endif

#ifdef DEVICE_XR100
	        if (strcmp(cmdARG1, "MEMPTR") == 0)
	        {
	            cmdMEMPTR(); // added 04.10.18
	        }
	        else
	        {
#endif


                                if (SYSTEM_CheckNumericAndSetup(TRUE) == 0)
                                {
                                    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                    cmdSET_DELAY();
                                } // checkNumeric

#if defined(DEVICE_XS100)
                            } // XSPDM_cmdSW_SET_TYPE
                        }     // XSPDM_cmdSW_SET_ROLL //
                    }         // SWTRIG //
                }             // XSPDM_cmdSW_STOP //
            }                 // XSPDM_cmdSW_CYCLESQ //
#endif

#ifdef DEVICE_XR100
			} // cmdMEMPTR
#endif

        } // added 07.26.21 cmdUNITSQ
        break;

    case 7:
#if !defined(DEVICE_XR100)
        if (strcmp(cmdARG1, "CTSTORE") == 0)
        {
#if defined(DEVICE_XS100)
            XSPDM_cmdCTSTORE();
#else
            cmdCTSTORE();
#endif
        }
        else
        {
#endif

#if defined(DEVICE_XS100)
            if (strcmp(cmdARG1, "SWROLL?") == 0)
            {
                XSPDM_cmdSW_ROLLQ(); // 05.06.22
            }
            else
            {
                if (strcmp(cmdARG1, "SWDSTOP") == 0)
                {
                    XSPDM_cmdSWD_SET_STOP(); // 05.06.22
                }
                else
                {
                    if (strcmp(cmdARG1, "SWDSTEP") == 0)
                    {
                        XSPDM_cmdSWD_SET_STEP(); // 05.06.22
                    }
                    else
                    {
                        if (strcmp(cmdARG1, "SWDRATE") == 0)
                        {
                            XSPDM_cmdSWD_SET_RATE(); // 05.06.22
                        }
                        else
                        {
                            if (strcmp(cmdARG1, "SWTYPE?") == 0)
                            {
                                XSPDM_cmdSW_TYPEQ(); // 05.10.22
                            }
                            else
                            {
#endif

#ifdef DEVICE_XR100
	        if (strcmp(cmdARG1, "MEMPTR?") == 0)
	        {
	            cmdMEMPTRQ();
	        }
	        else
	        {
	            if (strcmp(cmdARG1, "MEMWRAP") == 0)
	            {
	                cmdMEMWRAP();
	            }
	            else
	            {
	                if (strcmp(cmdARG1, "TRIGGER") == 0)
	                {
	                    cmdTRIGGER();
	                }
	                else
	                {
	                    if (strcmp(cmdARG1, "MEMPTRW") == 0)
	                    {
	                        cmdMEMPTRW();
	                    }
	                    else
	                    {
#endif

                                if (SYSTEM_CheckNumericAndSetup(TRUE) == 0)
                                {
                                    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                    cmdSET_DELAY();
                                } // check numeric

#ifdef DEVICE_XR100
						} // cmdMEMPTRW
					} // cmdTRIGGER
				} // cmdMEMPTRQ
       		} // cmdMEMPTRWRAP
#endif

#if defined(DEVICE_XS100)
                            } // XSPDM_cmdSW_TYPEQ
                        }     // XSPDM_cmdSWD_SET_RATE
                    }         // XSPDM_cmdSWD_SET_STEP
                }             // XSPDM_cmdSWD_SET_STOP
            }                 // XSPDM_cmdSW_ROLLQ
#endif

#ifndef DEVICE_XR100
        } // CTSTORE
#endif


        break;

    case 8:

#if !defined(DEVICE_XR100)
        if (strcmp(cmdARG1, "CTSTORE?") == 0)
        {
// 04.27.22
#if defined(DEVICE_XS100)
            XSPDM_cmdCTSTRQ();
#else
            cmdCTSTRQ();
#endif
        }
        else
        {
            if ((strcmp(cmdARG1, "CTSTOREM") == 0))
            {
#if defined(DEVICE_XS100)
                XSPDM_cmdCTSTOREM();
#else
                cmdCTSTOREM();
#endif
            }
            else
            {
#endif

#if defined(DEVICE_XS100)
                if (strcmp(cmdARG1, "SWDSTART") == 0)
                {
                    XSPDM_cmdSWD_SET_START(); // 05.06.22
                }
                else
                {
                    if (strcmp(cmdARG1, "SWDSTEP?") == 0)
                    {
                        XSPDM_cmdSWD_STEPQ(); // 05.06.22
                    }
                    else
                    {
                        if (strcmp(cmdARG1, "SWDSTOP?") == 0)
                        {
                            XSPDM_cmdSWD_STOPQ(); // 05.06.22
                        }
                        else
                        {
                            if (strcmp(cmdARG1, "SWDRATE?") == 0)
                            {
                                XSPDM_cmdSWD_RATEQ(); // 05.06.22
                            }
                            else
                            {
#endif

// BUILD_2203_RD112021
#ifdef DEVICE_XR100
	            if ((strcmp(cmdARG1, "MEMWRAP?") == 0))
	            {
	                cmdMEMWRAPQ();
	            }
	            else
	            {
	                if ((strcmp(cmdARG1, "TRIGGER?") == 0))
	                {
	                    cmdTRIGGERQ();
	                }
	                else
	                {
	                    if (strcmp(cmdARG1, "MEMPTRW?") == 0)
	                    {
                        	cmdMEMPTRWQ();
	                    }
	                    else
	                    {
#endif

                                if (SYSTEM_CheckNumericAndSetup(TRUE) == 0)
                                {
                                    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                                    cmdSET_DELAY();
                                } // checkNumeric
#if defined(DEVICE_XS100)
                            } // XSPDM_cmdSWD_RATEQ //
                        }     // XSPDM_cmdSWD_STEPQ //
                    }         // XSPDM_cmdSWD_STOPQ //
                }             // XSPDM_cmdSWD_SET_START //
#endif

#ifdef DEVICE_XR100
						} // cmdMEMPTRWQ
					} // cmdTRIGGERQ
				} // cmdMEMWRAPQ
#endif

#ifndef DEVICE_XR100
            } // cmdCTSTOREM
        }     // cmdSTOREM
#endif
        break;

    case 9:
        if (strcmp(cmdARG1, "SYST:ERR?") == 0)
        {
            cmdERR();
        }
        else
        {

#ifndef DEVICE_XR100
            if (strcmp(cmdARG1, "CTSTOREM?") == 0)
            {
#if defined(DEVICE_XS100)
                XSPDM_cmdCTSTOREMQ();
#else
                cmdCTSTOREMQ();
#endif
            }
            else
            {
#endif

#if defined(DEVICE_XS100)
                if (strcmp(cmdARG1, "SWDSTART?") == 0)
                {
                    XSPDM_cmdSWD_STARTQ(); // 05.06.22
                }
                else
                {
#endif
                    if (strcmp(cmdARG1, "HWTRGEDGE") == 0)
                    { // added 10.29.08
                        cmdHWTRGEDGE();
                    }
                    else
                    {
                        if (SYSTEM_CheckNumericAndSetup(TRUE) == 0)
                        {
                            INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
                            cmdSET_DELAY();
                        } // checkNumeric
                    }     // cmdHWTRGEDGE

#if defined(DEVICE_XS100)
                } // XSPDM_cmdSWD_STARTQ //
#endif

#ifndef DEVICE_XR100
            } // cmdCTSTOREMQ
#endif
        } // SYST:ERR?
        break;

    case 0:
        // NULL ... so IGNORE IT
        INSTRUMENT.stateCMD_FROM_TERM = TRUE; // ignore this entry
        break;

    default:
        if (SYSTEM_CheckNumericAndSetup(TRUE) == 0)
        {
            INSTRUMENT.stateOPERATION_COMPLETE = FALSE;
            cmdSET_DELAY();
        }
        break;
    } /* end switch */
} // end EXECUTE_COMMAND(void)

void SYSTEM_LoadNVParametersXT(void)
{
    //  -------------------------------------------------------------
    //  Function: LoadNVParameters(void)
    //  -------------------------------------------------------------
    //  Purpose: Loads the NV Parameters from the User Block into
    //           the RAM structure. Verifies the XORsum and resets the
    //           parameters to defaults if the XORsum fails.
    //  -------------------------------------------------------------

    unsigned char *tptr;
    unsigned char tXSUM;
    int _i;

    readUserBlock(&g_NVParameters, NVPARAMS_USERBLOCK_LOCATION, sizeof(DEVICE_NVPARAMETERS));
    //
    // XORsum the loaded structure to make sure it's valid.
    tptr = (unsigned char *)&g_NVParameters;
    tXSUM = 0;
    for (_i = 0; _i < sizeof(DEVICE_NVPARAMETERS); _i++)
        tXSUM ^= tptr[_i];
    tXSUM ^= MAGIC_XSUM_BYTE;

    //
    // If the XORsum fails, then the User Block data is corrupt, or has
    // never been initialized. Revert to safe defaults and save.
    if (tXSUM != 0)
    {
//#ifdef DEVICE_XT100
//        g_NVParameters.nv_ip_addr = aton("192.168.100.8");
//#endif
// 10.06.21 RD081621 BUILD
//#ifdef DEVICE_XT100_312P
//        g_NVParameters.nv_ip_addr = aton("192.168.100.8");
//#endif
#if (defined(DEVICE_XR100) || defined(DEVICE_XS100) || defined(DEVICE_XT100) || defined(DEVICE_XT100_312P))
        g_NVParameters.nv_ip_addr = aton("192.168.100.8");
#endif

#ifdef DEVICE_XT200
#ifdef PRIMARY_TROMBONE
        g_NVParameters.nv_ip_addr = aton("192.168.100.8");
#endif
#ifdef SECONDARY_TROMBONE
        g_NVParameters.nv_ip_addr = aton("192.168.100.9");
#endif
#endif

        g_NVParameters.nv_netmask = aton("255.255.0.0");
        g_NVParameters.nv_gateway = aton("192.168.100.1");
        g_NVParameters.nv_port = 5025; // default port address for industry standard SCPI  //

        g_ENET_PORT = g_NVParameters.nv_port;           // 1-03-04 added
        g_NVParameters.nv_useDHCP = TRUE;               // DHCP DEFAULT SHOULD BE ON 08.02.21
        g_NVParameters.nv_overshoot = TRUE;             // added 04.18.07
        g_NVParameters.nv_autodrop = TRUE;              // added 03.16.15
        g_NVParameters.nv_terminal_mode = FALSE;        // added 05.24.05
        g_NVParameters.nv_nsps_cycle_mode = CYCLE_UNIT; // added 07.02.08 // 04.10.18
        g_NVParameters.nv_overshoot_PS = 5; 			// added 06.06.22 SET DEFAULT OVERSHOOT VALUE TO 5 PS

        //#ifdef WEB_SERVER
#ifdef DEVICE_XT100
        strcpy(g_NVParameters.nv_description, "XT-100 Programmable Delay Line Instrument");
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
        strcpy(g_NVParameters.nv_description, "XT-100 Programmable Delay Line Instrument");
#endif
#ifdef DEVICE_XT200
        strcpy(g_NVParameters.nv_description, "XT-200 Programmable Delay Line Instrument");
#endif
#ifdef DEVICE_XR100
        strcpy(g_NVParameters.nv_description, "XR-100 Programmable Delay Line Instrument");
#endif
#if defined(DEVICE_XS100)
        strcpy(g_NVParameters.nv_description, "XS-100 Programmable Delay Line Instrument");
#endif

        strcpy(g_NVParameters.nv_password, "password");
        // 05.08.18 initialize the CTSTORE? INFO area and the CTSTORE CAL table
        //	int   nv_cal_table[SIZE_CAL_TABLE];     // float for # of PS with 3 decimal pt precision adjustment
        //	char  nv_cal_info[SIZE_CAL_INFO_FIELD]; // calibration table information max of 128 characters

        for (_i = 0; _i < SIZE_CAL_TABLE; _i++)
        { // BUG FIX (SHOULD BE < NOT <=)
            g_NVParameters.nv_cal_table[_i] = 0;
        }

        for (_i = 0; _i < SIZE_CAL_INFO_FIELD; _i++)
        {
            g_NVParameters.nv_cal_info[_i] = 0;
        }

        strcpy(g_NVParameters.nv_cal_info, "NO CALIBRATION");

#ifdef DHCP_SEND_HOSTNAME
        strcpy(g_NVParameters.nv_hostname, "COLBY_XXXXXXXX"); // 01.24.21
#endif
        g_NVParameters.nv_useCTSTORE = FALSE;
        SYSTEM_SaveNVParametersXT(); // 02.02.22 PRESERVE SERIAL PORT B
    }
}

void SYSTEM_SaveNVParametersXT(void)
{
    //  --------------------------------------------------------------
    //  Function: SaveNVParameters(void)
    //  --------------------------------------------------------------
    //  Purpose: Saves the RAM parameter structure to the User Block
    //           after updating the XORsum.
    //  --------------------------------------------------------------

    // 02.02.22 CLOSE SERIAL PORT B SINCE THIS IS A SHARED RESOURCE
    // 02.02.22 PREVENTS CHARS SENT OVER SERIAL PORT B WHEN WRITING TO USER BLOCK FLASH
    serBclose();

    SYSTEM_AdjustNVParametersXT();
    writeUserBlock(NVPARAMS_USERBLOCK_LOCATION, &g_NVParameters, sizeof(DEVICE_NVPARAMETERS));

    // 02.22.22 RESTORE SERIAL PORT B // RESTART THE SERIAL PORT B CONNECTION
    serBopen(9600); // Serial Port B is the EIA level RS-232 port
    serBflowcontrolOff();
    serBwrFlush(); // ON THE XT SYSTEM BOARD THIS IS USED FOR THE SECONDARY TROMBONE
    serBrdFlush();

    // printf("SaveNVParameters...\r\n"); // removed 06.06.22
}

void SYSTEM_ServiceSerialPortB_Char(void)
{
    int _length;

    _length = 0;

    // this is called for EACH CHARACTER coming FROM Serial Port B (Primary Trombone)
    // keep adding characters received into the pending Command Line buffer
    //
    // if a \r is received, process the entire line
    //

    MAIN_charSER_PORT = INSTRUMENT.charSER_PORT_B_ONLY;
    if ((MAIN_charSER_PORT != -1) && (MAIN_charSER_PORT != '\n'))
    { // ignore new line and 0xFFs
        if (MAIN_charSER_PORT != '\b')
        { // handle all chars except backspace
            // char in ch is valid, store it into the buffer ONLY if we
            //  haven't reached the end.  If at the end (80) then ignore.
            if (cmdINDEX < 80)
            {
                if (MAIN_charSER_PORT != '\r')
                {
                    sprintf(BUFFERS.DISPLAY_LINE, "%c", MAIN_charSER_PORT);
#ifdef DEVICE_XT100
#ifdef SECONDARY_TROMBONE
                    // 02.16.22 AS A SECONDARY TROMBONE ALL COMMANDS FROM PRIMARY MUST START WITH '>' FOR VERSION 1.15
                    if (MAIN_charSER_PORT == '>')
                    {
                        INSTRUMENT.stateGT_CHAR_DETECTED_FROM_PRI = TRUE;
                    }
#else
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE); // echo the char back
#endif
#endif

// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
#ifdef SECONDARY_TROMBONE
// DO NOTHING
#else
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE); // echo the char back
#endif
#endif

#ifdef DEVICE_XT200
#ifdef PRIMARY_TROMBONE
// DO NOTHING
#endif
#ifdef SECONDARY_TROMBONE
// 06.24.21 DONT ECHO ON TERMINAL
// SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);     //echo the char back
#endif
#endif
                }                                          // endif
                cmdBUFFER[cmdINDEX++] = MAIN_charSER_PORT; // store char in cmdINDEX then inc cmdINDEX
            }                                              // end-if
            else
            {
// 02.07.22 SERIAL BUFFER WILL OVERFLOW WHEN UPLOADING TO FLASH FIRMWARE ... SO IGNORE
#ifdef SECONDARY_TROMBONE
                INSTRUMENT.stateERROR_CODE = 0;
                INSTRUMENT.stateERROR = FALSE;
                memset(cmdBUFFER, 0x00, sizeof(cmdBUFFER)); // clear out the buffer
                cmdINDEX = 0;                               // reset it for next time
#else
                INSTRUMENT.stateERROR_CODE = 99;
                INSTRUMENT.stateERROR = TRUE;
                // printf("\r\nINPUT BUFFER OVERFLOW.\r\n");
                SYSTEM_OutputTerminal("\r\nINPUT BUFFER OVERFLOW.\r\n");
                memset(cmdBUFFER, 0x00, sizeof(cmdBUFFER)); // clear out the buffer
                cmdINDEX = 0;                               // reset it for next time
#endif
            } // end-else-if
        }     // end-if
        else
        {
            // handle backspace
            sprintf(BUFFERS.DISPLAY_LINE, "%c \b", MAIN_charSER_PORT);
            SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE); // echo the char back
            cmdINDEX = cmdINDEX - 1;
            if (cmdINDEX < 0)
            {
                cmdINDEX = 0;
                sprintf(BUFFERS.DISPLAY_LINE, " ", MAIN_charSER_PORT); // if at the beginning, then move it forward one space into the visible area
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);           // echo the char back
            }
        } // end-else
    }     // endif

    if (MAIN_charSER_PORT == '\r')
    { // CARRIAGE RETURN DETECTED // PARSE THE COMMAND
        cmdBUFFER[cmdINDEX - 1] = '\0';
        if (!INSTRUMENT.stateDEVICE_MODE_MT100A)
        {
            SYSTEM_OutputTerminal("\n\r");
        } // echo a CR
        // parse the COMMAND...
        memset(cmdCOMMAND, 0x00, sizeof(cmdCOMMAND)); // clear out COMMAND
        strcpy(cmdCOMMAND, cmdBUFFER);                // copy buffer into COMMAND
        cmdINDEX = 0;                                 // reset the index to 0 for the next time ... 07.16.21

#ifdef DEVICE_XT200
#ifdef PRIMARY_TROMBONE
        // We got a response back from the SECONDARY TROMBONE
        if (INSTRUMENT.stateOPC_QueryPending_CH2)
        {
            INSTRUMENT.stateOPC_QueryPending_CH2 = FALSE;
            if (strcmp(cmdBUFFER, "1") == 0)
            {
                INSTRUMENT.stateOPERATION_COMPLETE_CH2 = TRUE;
            }
            else
            {
                INSTRUMENT.stateOPERATION_COMPLETE_CH2 = FALSE;
            }
            INSTRUMENT.stateOPC_QueryResponseReceived_CH2 = TRUE; // TRIGGER THE COSTATE
        }
#endif
#else
        // PERFORM THE WORK
        INSTRUMENT.statePARSE = TRUE;               // toggle the flag to indicate Parse
        memset(cmdBUFFER, 0x00, sizeof(cmdBUFFER)); // clear out the buffer
        cmdINDEX = 0;                               // reset it for next time
        INSTRUMENT.stateCMD_FROM_TERM = TRUE;
#endif
    }

    if ((MAIN_charSER_PORT == '+') || (MAIN_charSER_PORT == '-'))
    {
        //+ or - char has been hit
        // these are special characters
        if (!INSTRUMENT.stateDEVICE_MODE_MT100A)
        {
            SYSTEM_OutputTerminal("\n\r");
        }                                             // echo a CR
        memset(cmdCOMMAND, 0x00, sizeof(cmdCOMMAND)); // clear out COMMAND
        if (cmdINDEX > 1)
        {
            // means there are characters BEFORE the + or - so this is a set STEP size command
            if (INSTRUMENT.stateDEVICE_DISPLAY_NS == TRUE)
                sprintf(cmdCOMMAND, "STEP %s NS", cmdBUFFER);
            else
                sprintf(cmdCOMMAND, "STEP %s PS", cmdBUFFER);
            if (MAIN_charSER_PORT == '+')
            {
                GLOBAL_SETTINGS.AUTO_SET_PLUS = TRUE;
                GLOBAL_SETTINGS.AUTO_SET_MINUS = FALSE;
            }
            if (MAIN_charSER_PORT == '-')
            {
                GLOBAL_SETTINGS.AUTO_SET_MINUS = TRUE;
                GLOBAL_SETTINGS.AUTO_SET_PLUS = FALSE;
            }
        }
        else
        {
            // command line started with + or - therefore this is a STEP + or
            strcpy(cmdCOMMAND, cmdBUFFER); // copy buffer into COMMAND
        }
        // parse the COMMAND...
        INSTRUMENT.statePARSE = TRUE;               // toggle the flag to indicate Parse
        memset(cmdBUFFER, 0x00, sizeof(cmdBUFFER)); // clear out the buffer
        cmdINDEX = 0;                               // reset it for next time
        INSTRUMENT.stateCMD_FROM_TERM = TRUE;
    }

    //
}

void SYSTEM_ServiceSerialPortE_Char(void)
{
    // For EACH CHARACTER from Serial Port E (MT-100A), keep adding into the pending Command Line buffer
    // until a \r is received.  Then process the entire line.

    // 11.18.21 BUILD2203
    int _NL_DETECTED;
    _NL_DETECTED = FALSE;

    MAIN_charSER_PORT = INSTRUMENT.charSER_PORT_E_ONLY;

    // 11.28.21 BUILD_2203
    // 11.18.21 SEE IF THIS IS A CHAR THAT CAN ONLY COME FROM THE MT-100A

    if ((MAIN_charSER_PORT == 0x13) || (MAIN_charSER_PORT == 0x15) ||
        (MAIN_charSER_PORT == 0x16) || (MAIN_charSER_PORT == 0X1B))
    { // 11.18.21 SETUP, DIAG, NS/PS, OR CLEAR KEY CAN ONLY COME FROM MT-100A
        // 11.19.21 IF FALSE BEFORE, THEN ALSO SET AND SAVE TO TO TRUE
        if (INSTRUMENT.stateDEVICE_MODE_MT100A == FALSE)
        {
            g_NVParameters.nv_terminal_mode = FALSE; // FALSE MEANS RS-232 IS IN MT-100A MODE, NOT TERMINAL MODE
            SYSTEM_SaveNVParametersXT();             // 02.02.22 PRESERVE SERIAL PORT B
            MAIN_charSER_PORT = '\r';
        }
        INSTRUMENT.stateDEVICE_MODE_MT100A = TRUE; // SET MT-100A MODE TO ON
    }
    else if ((MAIN_charSER_PORT == ' ') && (INSTRUMENT.stateDEVICE_MODE_MT100A == TRUE))
    { // 11.18.21 A SPACE CHAR WAS RECEIVED ON THE SERIAL PORT WHICH MEANS NON MT-100A ATTACHED
        INSTRUMENT.stateDEVICE_MODE_MT100A = FALSE;
    }

    if ((MAIN_charSER_PORT != -1) && (MAIN_charSER_PORT != '\n'))
    { // ignore new line and 0xFFs
        if (MAIN_charSER_PORT != '\b')
        { // handle all chars except backspace
            // char in ch is valid, store it into the buffer ONLY if we
            //  haven't reached the end.  If at the end (80) then ignore.
            if (cmdINDEX < 80)
            {
                if (MAIN_charSER_PORT != '\r')
                {
                    // putchar(ch);
                    sprintf(BUFFERS.DISPLAY_LINE, "%c", MAIN_charSER_PORT);
                    SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE); // echo the char back
                }                                                // endif
                cmdBUFFER[cmdINDEX++] = MAIN_charSER_PORT;       // store char in cmdINDEX then inc cmdINDEX
            }                                                    // end-if
            else
            {
                INSTRUMENT.stateERROR_CODE = 99;
                INSTRUMENT.stateERROR = TRUE;
                memset(cmdBUFFER, 0x00, sizeof(cmdBUFFER)); // clear out the buffer
                cmdINDEX = 0;                               // reset it for next time
            }                                               // end-else-if
        }                                                   // end-if
        else
        { // handle backspace
            sprintf(BUFFERS.DISPLAY_LINE, "%c \b", MAIN_charSER_PORT);
            SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE); // echo the char back
            cmdINDEX = cmdINDEX - 1;
            if (cmdINDEX < 0)
            {
                cmdINDEX = 0;
                sprintf(BUFFERS.DISPLAY_LINE, " ", MAIN_charSER_PORT); // if at the beginning, then move it forward one space into the visible area
                SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);           // echo the char back
            }
        } // end-else
    }     // endif
    // 11.18.21 BUILD 2203
    // 11.18.21 CHECK IF LF (LF CHAR CAN ONLY COME FROM NON-MT-100A E.G. PUTTY OR TELNET)
    else
    {
        if (MAIN_charSER_PORT == '\n')
        {
            // newline char detected
            // ignore it
            _NL_DETECTED = TRUE;
            // 11.18.21 SINCE A LF CHAR WAS DETECTED, THEN MUST BE OPERATING VIA
            // 11.18.21 SERIAL PORT WITH PUTTY OR TERMINAL ATTACHED
            INSTRUMENT.stateDEVICE_MODE_MT100A = FALSE; // SET TO FALSE TO TURN OFF DISPLAY PROMPTS
        }
    }

    if (MAIN_charSER_PORT == '\r')
    { // CARRIAGE RETURN DETECTED // PARSE THE COMMAND
        cmdBUFFER[cmdINDEX - 1] = '\0';
        if (!INSTRUMENT.stateDEVICE_MODE_MT100A)
        {
            SYSTEM_OutputTerminal("\n\r");
        } // echo a CR
        // parse the COMMAND...
        memset(cmdCOMMAND, 0x00, sizeof(cmdCOMMAND)); // clear out COMMAND
        strcpy(cmdCOMMAND, cmdBUFFER);                // copy buffer into COMMAND
        INSTRUMENT.statePARSE = TRUE;                 // toggle the flag to indicate Parse
        memset(cmdBUFFER, 0x00, sizeof(cmdBUFFER));   // clear out the buffer
        cmdINDEX = 0;                                 // reset it for next time
        INSTRUMENT.stateCMD_FROM_TERM = TRUE;
    }

    if ((MAIN_charSER_PORT == '+') || (MAIN_charSER_PORT == '-'))
    {
        //+ or - char has been hit
        // these are special characters
        if (!INSTRUMENT.stateDEVICE_MODE_MT100A)
        {
            SYSTEM_OutputTerminal("\n\r");
        }                                             // echo a CR
        memset(cmdCOMMAND, 0x00, sizeof(cmdCOMMAND)); // clear out COMMAND
        if (cmdINDEX > 1)
        {
            // means there are characters BEFORE the + or - so this is a set STEP size command
            if (INSTRUMENT.stateDEVICE_DISPLAY_NS == TRUE)
                sprintf(cmdCOMMAND, "STEP %s NS", cmdBUFFER);
            else
                sprintf(cmdCOMMAND, "STEP %s PS", cmdBUFFER);
            if (MAIN_charSER_PORT == '+')
            {
                GLOBAL_SETTINGS.AUTO_SET_PLUS = TRUE;
                GLOBAL_SETTINGS.AUTO_SET_MINUS = FALSE;
            }
            if (MAIN_charSER_PORT == '-')
            {
                GLOBAL_SETTINGS.AUTO_SET_MINUS = TRUE;
                GLOBAL_SETTINGS.AUTO_SET_PLUS = FALSE;
            }
        }
        else
        {
            // command line started with + or - therefore this is a STEP + or
            strcpy(cmdCOMMAND, cmdBUFFER); // copy buffer into COMMAND
        }
        // parse the COMMAND...
        INSTRUMENT.statePARSE = TRUE;               // toggle the flag to indicate Parse
        memset(cmdBUFFER, 0x00, sizeof(cmdBUFFER)); // clear out the buffer
        cmdINDEX = 0;                               // reset it for next time
        INSTRUMENT.stateCMD_FROM_TERM = TRUE;
    }
}

void SYSTEM_ServiceOPC_Response_CH2(void)
{
    sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", INSTRUMENT.stateOPERATION_COMPLETE_CH2); //
    INSTRUMENT.stateOPERATION_COMPLETE_CH2 = FALSE;                                  // CLEAR THE *OPC BIT

    // DETERMINE WHERE THE *opc? CAME FROM AND RETURN THE RESPONSE TO IT (EITHER SERIAL PORT OR ethernet)
    // testing

    INSTRUMENT.stateCMD_FROM_LAN = TRUE;
    SYSTEM_OutputQueryResponse();
}

int _DetermineX_Offset(float _Value)
{
    // DETERMINE HOW MUCH TO OFFSET THE CURSOR POSITION FOR RIGHT JUSTIFIED VALUE TO BE DISPLAYED
    // DEPENDING ON WHETHER IN NS OR PS UNITS MODE

    if (INSTRUMENT.stateDEVICE_DISPLAY_NS == TRUE)
    {
        if (_Value < 10.0)
        {
            return 40 - 1;
        }
        else if (_Value < 100.0)
        {
            return 32 - 1;
        }
        else
        {
            return 24 - 2; // 05.23.22
        }
    }
    else
    {
        if (_Value < 10.0)
        {
            return 40 + 16 + 2;
        }
        else if (_Value < 100.0)
        {
            return 32 + 16;
        }
        else if (_Value < 1000.0)
        {
            return 32 + 16 - 8;
        }
        else if (_Value < 10000.0)
        {
            return 32 - 1;
        }
        else if (_Value < 100000.0)
        {
            return 24 - 2; // 05.23.22
        }
        else
        {
            return 16 - 3; // 05.23.22
        }
    }
} // end

void SYSTEM_TFT_DISPLAY_UPDATE()
{
    int _i, _Digit;
    char _TFT_DisplayLine[20];
    float _ValueToUseForDisplay, _Percentage;
    int _X_LineEndPoint;
    int _X_TextOffset; // 05.18.22 determine amount text value is right justified on display

#if defined(TFT_ATTACHED)
    gselvp(VIEWPORT_MAIN); // XT-100
    gsetcolorb(G_BLACK);

    // DISPLAY THE UNITS
#if defined(DEVICE_XT100) || defined(DEVICE_XR100)

    if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
    {
        gselvp(VIEWPORT_CH1); // PS UNITS CHANNEL 1
        sprintf(_TFT_DisplayLine, "%9.2f", DISPLAY_SETTINGS.CURRENT_DELAY_F);
        _X_TextOffset = _DetermineX_Offset(DISPLAY_SETTINGS.CURRENT_DELAY_F);
    }
    else
    {
        gselvp(VIEWPORT_CH1); // NS UNITS CHANNEL 1
        sprintf(_TFT_DisplayLine, "%9.4f", (DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.0));
        _X_TextOffset = _DetermineX_Offset(DISPLAY_SETTINGS.CURRENT_DELAY_F / 1000.0);
    }

    // IF OFFSET IS POSITIVE, THERE IS A GAP(PRE-TEXT AREA) THAT MAY NEED TO BE FILLED WITH BLACK
    if (_X_TextOffset >0)
    {
        gsetcolorb(G_BLACK);
        gfillvp(CHX_TEXT_LINE_X,CHX_TEXT_LINE_Y,CHX_TEXT_LINE_X+_X_TextOffset,CHX_TEXT_LINE_Y+24,0X0000);	// 06.2.22 BLACK OUT PRE TEXT AREA
    }

    // ----------------------------------------------------------
    // CH1 LINE TEXT
    gselvp(VIEWPORT_CH1); // SELECT THE VIEWPORT
    gsetcolorb(G_BLACK);  // CLEAR OUT THE TEXT AREA
    gsetpos(CHX_TEXT_LINE_X + _X_TextOffset, CHX_TEXT_LINE_Y + 18); // 05.19.22 RIGHT JUSTIFY
    gsetcolorf(G_WHITE);
    // CONVERT STRING TO LARGE FONT DIGITS
    TFT_ToLargeFontString(_TFT_DisplayLine);
    gputs(_TFT_DisplayLine); // DISPLAY THE DELAY SETTING


    // DRAW THE BAR GRAPH BELOW (IF INSTALLED)

#if (defined(DEVICE_XT100) || defined(DEVICE_XT100_312P) || defined(DEVICE_XR100))
    _ValueToUseForDisplay = DISPLAY_SETTINGS.CURRENT_DELAY_F;
#else
#if defined(DEVICE_XT200)
    _ValueToUseForDisplay = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F;
#endif
#endif

    _Percentage = (_ValueToUseForDisplay / PARAMETERS.deviceMAX_DELAY_PS);

#if (defined(DEVICE_XT200_312P) || defined(DEVICE_XT100_312P))
    // IF DEVICE_MODE IS PARALLEL IN XT-200-312P OR XT-100-312P, THEN CHANGE TO SHOW BARS CORRECTLY
    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)
    {
        _Percentage = (_ValueToUseForDisplay / (PARAMETERS.deviceMAX_DELAY_PS / 2.0));
    }
#endif

    if (_Percentage > 1.0)
        _Percentage = 1.0; // boundary check
    _X_LineEndPoint = (int)(_Percentage * CHX_BAR_W);

    gcrectangle(CHX_BAR_X_UL - 1, CHX_BAR_Y_UL - 1, CHX_BAR_X_LR + 1, CHX_BAR_Y_LR + 1, G_WHITE);
    gsetcolorb(G_BLACK);
    gfillvp(CHX_BAR_X_UL, CHX_BAR_Y_UL, CHX_BAR_X_LR, CHX_BAR_Y_LR, 0x0000);
    gsetcolorb(G_GREEN);
    gfillvp(CHX_BAR_X_UL, CHX_BAR_Y_UL+3, CHX_BAR_X_UL + _X_LineEndPoint, CHX_BAR_Y_LR-3, 0x0000);
    gsetcolorb(G_BLACK);

#else
    // INSTRUMENT IS A DEVICE_XT200
    // UPDATE CH1 ONLY IF NEEDED

    if (INSTRUMENT.stateDEL_CHANNEL != CHANNEL_TWO)
    {
        if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
        {
            gselvp(VIEWPORT_CH1); // PS UNITS // CHANNEL 1
            sprintf(_TFT_DisplayLine, "%9.2f", INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F);
            _X_TextOffset = _DetermineX_Offset(INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F); // FOR CHANNEL 1
        }
        else
        {
            gselvp(VIEWPORT_CH1); // NS UNITS // CHANNEL 1
            sprintf(_TFT_DisplayLine, "%9.4f", (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.0));
            _X_TextOffset = _DetermineX_Offset(INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 1000.0); // FOR CHANNEL 1
        }

        // ----------------------------------------------------------
        // CH1 LINE TEXT
        gselvp(VIEWPORT_CH1); // SELECT THE VIEWPORT
        gsetcolorb(G_BLACK);  // CLEAR OUT THE TEXT AREA
        gsetpos(CHX_TEXT_LINE_X + _X_TextOffset, CHX_TEXT_LINE_Y + 18); // 05.19.22 RIGHT JUSTIFY
        gsetcolorf(G_WHITE);
        // CONVERT STRING TO LARGE FONT DIGITS
        TFT_ToLargeFontString(_TFT_DisplayLine);
        gputs(_TFT_DisplayLine); // DISPLAY THE DELAY SETTING



        // DRAW THE BAR GRAPH BELOW
        #if (defined(DEVICE_XT100) || defined(DEVICE_XT100_312P) || defined(DEVICE_XR100))
            _ValueToUseForDisplay = DISPLAY_SETTINGS.CURRENT_DELAY_F;
        #else
        #if defined(DEVICE_XT200)
            _ValueToUseForDisplay = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F;
        #endif
        #endif
            _Percentage = (_ValueToUseForDisplay / PARAMETERS.deviceMAX_DELAY_PS);
        #if (defined(DEVICE_XT200_312P) || defined(DEVICE_XT100_312P))
            // IF DEVICE_MODE IS PARALLEL IN XT-200-312P OR XT-100-312P, THEN CHANGE TO SHOW BARS CORRECTLY
            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)
                _Percentage = (_ValueToUseForDisplay / (PARAMETERS.deviceMAX_DELAY_PS / 2.0));
        #endif
        if (_Percentage > 1.0)
            _Percentage = 1.0; // boundary check
        _X_LineEndPoint = (int)(_Percentage * CHX_BAR_W);

        gcrectangle(CHX_BAR_X_UL - 1, CHX_BAR_Y_UL - 1, CHX_BAR_X_LR + 1, CHX_BAR_Y_LR + 1, G_WHITE);
        gsetcolorb(G_BLACK);
        gfillvp(CHX_BAR_X_UL, CHX_BAR_Y_UL, CHX_BAR_X_LR, CHX_BAR_Y_LR, 0x0000);
        gsetcolorb(G_GREEN);
        gfillvp(CHX_BAR_X_UL, CHX_BAR_Y_UL+3, CHX_BAR_X_UL + _X_LineEndPoint, CHX_BAR_Y_LR-3, 0x0000);
        gsetcolorb(G_BLACK);

    } // UPDATE CHANNEL 1 ONLY

    // UPDATE CH2 ONLY IF NEEDED
    if ((INSTRUMENT.stateDEL_CHANNEL != CHANNEL_ONE) || (INSTRUMENT.stateFIRST_TIME_INIT_SEQUENCE == TRUE))
    {
        if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
        {
            gselvp(VIEWPORT_CH2); // PS UNITS // CHANNEL 2
            sprintf(_TFT_DisplayLine, "%9.2f", INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F);
            _X_TextOffset = _DetermineX_Offset(INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F); // FOR CHANNEL 2
        }
        else
        {
            gselvp(VIEWPORT_CH2); // NS UNITS // CHANNEL 2
            sprintf(_TFT_DisplayLine, "%9.4f", (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.0));
            _X_TextOffset = _DetermineX_Offset(INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F / 1000.0); // FOR CHANNEL 2
        }

        // ----------------------------------------------------------
        // CH2 LINE TEXT
        gselvp(VIEWPORT_CH2); // SELECT THE VIEWPORT
        gsetcolorb(G_BLACK);  // CLEAR OUT THE TEXT AREA
        gsetpos(CHX_TEXT_LINE_X + _X_TextOffset, CHX_TEXT_LINE_Y + 18); // 05.19.22 RIGHT JUSTIFY
        gsetcolorf(G_WHITE);
        // CONVERT STRING TO LARGE FONT DIGITS
        TFT_ToLargeFontString(_TFT_DisplayLine);
        gputs(_TFT_DisplayLine); // DISPLAY THE DELAY SETTING

        // DRAW THE BAR GRAPH BELOW

        #if defined(DEVICE_XT200)
        _ValueToUseForDisplay = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F;
        #endif
        //#endif
        _Percentage = (_ValueToUseForDisplay / PARAMETERS.deviceMAX_DELAY_PS);
        #if (defined(DEVICE_XT200_312P) || defined(DEVICE_XT100_312P))
        // IF DEVICE_MODE IS PARALLEL IN XT-200-312P OR XT-100-312P, THEN CHANGE TO SHOW BARS CORRECTLY
        if (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)
            _Percentage = (_ValueToUseForDisplay / (PARAMETERS.deviceMAX_DELAY_PS / 2.0));
        #endif
        if (_Percentage > 1.0)
            _Percentage = 1.0; // boundary check
        _X_LineEndPoint = (int)(_Percentage * CHX_BAR_W);

        gcrectangle(CHX_BAR_X_UL - 1, CHX_BAR_Y_UL - 1, CHX_BAR_X_LR + 1, CHX_BAR_Y_LR + 1, G_WHITE);
        gsetcolorb(G_BLACK);
        gfillvp(CHX_BAR_X_UL, CHX_BAR_Y_UL, CHX_BAR_X_LR, CHX_BAR_Y_LR, 0x0000);
        gsetcolorb(G_GREEN);
        gfillvp(CHX_BAR_X_UL, CHX_BAR_Y_UL+3, CHX_BAR_X_UL + _X_LineEndPoint, CHX_BAR_Y_LR-3, 0x0000);
        gsetcolorb(G_BLACK);

    } // UPDATE CHANNEL 1 ONLY
    #endif

#endif
}

void SYSTEM_TFT_DISPLAY_FLOAT_IN_CH_TEXT(float _DisplayValue, int _ViewportNumber, int _Color)
{
	#if defined(TFT_ATTACHED)
    char _TFT_DisplayLine[30];
    int _X_TextOffset;

    // Display the float value into the designated CH TEXT AREA determined by ViewportNumber

    if (INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE)
    {
        gselvp(_ViewportNumber); // PS UNITS CHANNEL 1
        sprintf(_TFT_DisplayLine, "%9.2f", _DisplayValue);;
        _X_TextOffset = _DetermineX_Offset(_DisplayValue);
    }
    else
    {
        gselvp(_ViewportNumber); // NS UNITS CHANNEL 1
        sprintf(_TFT_DisplayLine, "%9.4f", (_DisplayValue / 1000.0));
        _X_TextOffset = _DetermineX_Offset(_DisplayValue/ 1000.0);
    }

    // ----------------------------------------------------------
    // CH1 LINE TEXT
    gselvp(_ViewportNumber); // SELECT THE VIEWPORT
    gsetpos(CHX_TEXT_LINE_X + _X_TextOffset, CHX_TEXT_LINE_Y + 18); // 05.19.22 RIGHT JUSTIFY
    gsetcolorf(_Color);
    // CONVERT STRING TO LARGE FONT DIGITS
    TFT_ToLargeFontString(_TFT_DisplayLine);
    gputs(_TFT_DisplayLine); // DISPLAY THE DELAY SETTING
    #endif
}

/*** BeginHeader */
#endif // #ifndef _INST_COMMANDS_LIB
       /*** EndHeader */