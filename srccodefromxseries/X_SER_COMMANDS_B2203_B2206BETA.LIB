/* START LIBRARY DESCRIPTION ***************************************************
*
*   File	    : X_SER_CMD_COMMANDS.LIB
*	Description	: CMD_COMMANDS LIBRARY
*	Project		: Colby Instruments Programmable Delay Line X SERIES
*	Date		: MAY 17, 2021
*				: Copyright(c) 2021 Colby Instruments, Bellevue, WA
*	NOTES:		: From split of REFACTOR_HW1.LIB TO
*               : REFACTOR_CMD.LIB AND REFACTOR_BASE.LIB.
*
END DESCRIPTION ***************************************************************/

////////////////////////////////////////////////f////////////////////////////////

// BUILD 2106 *****************************************************************
// BUILD 2106 *****************************************************************
// BUILD 2106 *****************************************************************

// CREATE THIS LIB STARTING FROM REFACTOR_HW1.LIB WHEN SPLIT INTO REFACTOR_CMD.LIB AND REFACTOR_BASE.LIB

// 02.15.21	SPLIT COMMANDS.LIB INTO MOTOR_COMMANDS.LIB (11 APIS) AND INST_COMMANDS.LIB (7 APIS)
// 02.15.21	TAKE ALL 3 APIS FROM METHODS.LIB AND FACTOR INTO MOTOR_COMMANDS.LIB
// 02.18.21 REMOVED GPIB CODE: cmdTMO,cmdESE, cmdESEQ, cmdSRE, cmdSREQ, cmdSTBQ, cmdESRQ, cmdADDRQ, cmdSET_ADDR
// 02.18.21 GPIB_ENABLED code left is a reminder to work on the OPERATION COMPLETE model/method/callback work TBD
// 02.18.21 remove xtoxerr code in cmdDEL_XT100 (tail pointer code not tested)
// 02.18.21 added tailpointer code for cmdDEL_XR100 (but not tested in CPDL build yet) to remove xtoxerr api
// 05.05.21	remove LoadNVParameters on cmdRST for secondary trombone

// 05.17.21 XT SYSTEM BUILD - REFACTOR_CMD_B2106_HW3RD01.LIB TO X_SER_REFACTOR_CMDS_B2109.LIB
// 05.17.21 XT SYSTEM BUILD - REFACTOR_CMD_B2106_HW3RD01.LIB TO X_SER_REFACTOR_CMDS_B2109.LIB
// 05.17.21 XT SYSTEM BUILD - REFACTOR_CMD_B2106_HW3RD01.LIB TO X_SER_REFACTOR_CMDS_B2109.LIB

// 05.18.21	REMOVE GPIB CODE, REMOVE #ifdef ETHERNET ENABLED since ETHERNET is ALWAYS ON
// 05.19.21 SYSTEM_ParseValue moved back to REFACTOR_BASE_LIB
// 05.19.21 remove cmdADDRQ, PODS, PODSQ
// 05.19.21 RENAME TO COMMANDS.LIB
// 05.19.21 REMOVE cmdDELAY_TIMEQ
// 05.26.21 REMOVE #ifdef DEVICE_xxDL200A, cmdCLS
// 06.19.21 REMOVE SYSTEM_ParseValue
// 06.22.21 REMOVE cmdDEL_XT100
// 06.24.21 added INSTRUMENT.LAST_OperationChannelNumber = 1 or 2
// 06.24.21 and handle in cmdOPCQ
// 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO (_MotorPositionDIGITAL < 0) _MotorPositionDIGITAL = 0 ;
// 07.26.21 added UNITS and UNITS? command & query to replace mode ns and mode ps and mode?

// 07.26.21	X SERIES FINAL PRODUCTION CODE VERSION 1.00 BUILD 2109 --------------------------------------------------
// 07.30.21 RD073021 BUILD
// 08.04.21	X SERIES FINAL PRODUCTION CODE VERSION 1.00 BUILD 2109 --------------------------------------------------
// 08.06.21 RD080621 BUILD
// 08.17.21 UPDATES TO HWIO_REL APIS, ROUND DOWN BUG AT LAST SECTION (SECTION NOW TURNS OFF FOR TROBONE TO DO REMAINDER)

// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------
// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------
// 08.17.21 X SERIES FINAL PRODUCTION CODE VERSION 1.01 BUILD 2109_RD080621 -----------------------------------------

// 10.06.21 HOT FIX TO HANDLE OVERSHOOT ON DELAY SETTINGS WITH RELAYS
// 10.08.21 added function long computeMOD(long _Argument); to compute remainder correctly

// 10.05.21 added handle #ifdef DEVICE_XT100_312P
// 10.06.21 RD081621 BUILD

// 10.18.21 START BUILD2112 RD102121
// 10.18.21 FIX FOR TROMBONE POSITION WITH CAL ON OR CAL OFF IN cmdSET_DELAY
// 10.22.21 CHANGES IN cmdSET_DELAY to HANDLE DEVICE_XT100_200N
// 10.22.21 add cmdREL_UL,cmdQUERYR_UL for DEVICE_XT100_200N TO HANDLE LOGICAL TO PHYSICAL MAPPING
// 10.26.21 HOT FIX ... HANDLE DELAY SETTING = MAX TO TURN ON TROMBONE TO 625PS AND ALL RELAYS ON FOR XT-100
// 10.26.21 HOT FIX ... change computeMOD to computeMOD_F
// 10.28.21 UPDATES IN STEP_INC AND STEP_DEC TO ROUND DOWN DELAY SETTINGS FOR DEVICE_XT100_200N
// 10.28.21 REMOVE LIMIT MESSAGE TO MT100 WHEN SPECIFY DELAY ABOVE DEVICE LIMIT
// 11.07.21 RENAME #define DEVICE_XT100_200N to #define USE_DELAY_UL_TABLE
// 11.11.21 DETECT THE EDGE CASE WHERE THE REMAINDER IS 625 AND THE POSITION MODULO IS ZERO
// 11.11.21 cmdSET_DELAY: if (_DelayRemainder_PS == 625) {_DesiredMotorPos_MOD_F = 625;}

// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------
// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------
// 11.11.21 X SERIES FINAL PRODUCTION CODE VERSION 1.11 BUILD 2112_RD102121 --------------------------------

// 11.11.21 BUILD2112_RD102121_RD111121
// 11.11.21 cmdNETQ: GW_ADDRESS AND NM_ADDRESS ... RETURN CURRENT ACTUAL SETTINGS NOT NVRAM SETTINGS
// 11.13.21 cmdIDN: handle DEVICE_XT200_312P
// 11.13.21 cmdDEL_ONE_TWO_Q: HANDLE PARALLEL MODE FOR DEVICE_XT200_312P

// 11.14.21 WORK ON REMOVE ALL #DEFINE REMOVE_CODE SECTIONS ... DELETE FROM CODE BASE
// 11.15.21 cmdDEL_ONEQ,cmdDEL_TWOQ, and cmdDEL_ONE_TWO_Q: DO NOT DIVIDE BY TWO FOR DEVICE_XT200_312P
// 11.16.21 cmdNETQ: REMOVE INVALID ARGUMENT -- DO NOT DISPLAY
// 11.17.21 cmdSET_DELAY: fixes and improvements for handling input char digits in #define USE_DELAY_UL_TABLE
// 11.18.21 cmdREL_UL: // 11.18.21 FOR DEVICE_XT200_200N ONLY:
// 11.18.21 cmdREL_UL: // 11.18.21 LOGICAL 8 (80 NS) MAPS TO PHYSICAL COMBINATION OF RELAY # 8 AND 9
// 11.18.21 cmdREL_UL: // 11.18.21 LOGICAL 9 (40 NS) MAPS TO PHYSICAL RELAY # 10
//
// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------
// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------
// 11.19.21 X SERIES FINAL PRODUCTION CODE VERSION 1.12 BUILD 2112_RD102121_RD111121-------------------------

// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------
// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------
// 11.22.21 X SERIES FINAL PRODUCTION CODE VERSION 1.13 BUILD 2203 ------------------------------------------

// 11.20.21 RD112021 ADD cmdMEMSTORE: MEM command to store delay settings
// 11.21.21 added cmdMEMPTR, cmdMEMPTRQ, cmdMEMWRAP, cmdMEMWRAPQ for DEVICE_XR100
// 11.21.21 added cmdTRIGGER  - trigger the relays to switch
// 11.25.21 cmdRELQ:UPDATE THE HW_RELAYS.RELAY_ON_OFF TO REFLECT HW_RELAYS.SETTINGS FOR SUM RELAY VALUES DISPLAY
// 11.25.21 added cmdTRIGGERQ - to set trigger and reply with 1 when completed
// 11.29.21 cmdHWTRGEDGE: call HWIO_EnableDisable_XIRQ(TRUE);  added ... needed ?
// 11.30.31 handle # for new MT-100A
// 12.03.21 add cmdMEMPTRW,cmdMEMPTRWQ
// 12.11.21 cmdNET: fix typo "re-initializing"

// 01.27.22 cmdSET_DELAY: add device support for DEVICE_XT200_312P -- PRIMARY RUNS IN PARALLEL MODE, SECONDARY IS XT-100 FULL TROMBONE
// 02.14.22 cmdOPCQ: ADD THE '>' CHAR TO *OPC? COMMAND FROM PRIMARY
// 02.14.22 cmdCAL: ADD THE '>' CHAR TO *CAL COMMAND FROM PRIMARY
// 02.14.22 cmdRST: ADD '>' CHAR TO *RST COMMAND FROM PRIMARY
// 02.16.22 VERSION 1.15
// 04.06.22 cmdSET_DELAY: clear out the delay setting displayed in TFT SCREEN if attached TBD
// 04.27.22 cmdIDN: add support for DEVICE_XS100
// 04.29.22 cmdSET_DELAY: add support for XS-100
// 05.23.22 cmdSET_DELAY: BUGFIX: OVERSHOOT POSITION MOVES TO ZERO DELAY WHEN CAL TABLE IS TURNED OFF // BUG
// 05.27.22 cmdSET_DELAY: display delay setting in yellow text/blank bar TFTbefore setting delay
//

// 06.29.22 TIMING_TEST VERSION -- INCORPORATES RD112021.LIB UPDATES
// 08.11.22 MERGED CODE LIBS
// 08.15.22 cmdOPCQ: SEC_TROMBONE_COMMAND[10] array size set to 10 (was 8) BUG FIX
// 08.15.22 cmdOPCQ: // 08.15.22 REPORT OPERATION COMPLETE -- DO NOT QUERY SECONDARY TROMBONE
// 08.15.22 cmdSET_DELAY: // 08.15.22 SET OPERATION COMPLETE TO TRUE AFTER SENDING SET DEL TO SECONDARY

// 08.18.22 cmdNETQ: // 08.10.22 SESSIONS INFORMATION SC=CLOSE, SO=OPEN-CONNECTED, SL=LISTENING
// 08.19.22 cmdCTSTORE: // 08.19.22 replace XS_USE_CAL_TABLE to USE_CAL_TABLE
// 08.19.22 cmdSET_DELAY: handle delay_remainder for DEVICE_XS100_005N AND DEVICE_XS100_010N
// 08.19.22 cmdDEL: REPORT OPERATION COMPLETE AFTER SETTING PIND DIODES FOR DEVICE_XS100

// 08.23.22 COMPARED/MERGED TO B2203 AND TIMING_TEST VERSIONS AND SOURCE CODE VER 1.17
// 08.26.22 cmdOPCQ: add # if defined(DEVICE_XS100)
// 08.26.22 cmdSET_DELAY:  add INSTRUMENT.stateOPERATION_COMPLETE = TRUE; FOR DEVICE_XS100

/*** BeginHeader */
#ifndef X_SER_COMMANDS_LIB
#define X_SER_COMMANDS_LIB
/*** EndHeader */

/*** BeginHeader
cmdCAL,
cmdCTSTORE,
cmdCTSTRQ,
cmdDEL_XR100,
cmdDEL,
cmdDEL_ONE,
cmdDEL_TWO,
cmdDEL_ONE_Q,
cmdDEL_TWO_Q,
cmdDEL_ONE_TWO_Q,
cmdERR,
cmdHWTRGEDGE,
cmdIDN,
cmdMODE,
cmdMODEQ,
cmdUNITS,
cmdUNITSQ,
cmdMOTOR_RS,
cmdNET,
cmdNETQ,
cmdNETMQ,
cmdNETSTATEQ,
cmdOPC,
cmdOPCQ,
cmdOVER,
cmdOVERQ,
cmdOVS,
cmdOVSQ,
cmdRELC,
cmdRST,
cmdREL,
cmdREL_UL,
cmdRELQ,
cmdREMOTE,
cmdREMQ,
cmdSTEPQ,
cmdSTEP_INC,
cmdSTEP_DEC,
cmdSTEP,
cmdCTSTOREM,
cmdCTSTOREMQ,
cmdTSTQ,
cmdCLS,
cmdSET_DELAY,
cmdHWFD,
cmdQUERYR_UL,
computeMOD,
computeMOD_F,
cmdTERM,
cmdTERMQ,
cmdMEMSTORE,
cmdMEMPTR,
cmdMEMPTRQ,
cmdMEMWRAP,
cmdMEMWRAPQ,
cmdMEMQ,
cmdTRIGGER,
cmdTRIGGERQ,
cmdMEMPTRW,
cmdMEMPTRWQ,
_DetermineRelayPattern
*/

/* Variables and functions in here are public access */

void cmdCAL(void);
void cmdCTSTORE(void);
void cmdCTSTRQ(void);
void cmdDEL_XR100(void);
void cmdDEL(void);
void cmdDEL_ONE(void);
void cmdDEL_TWO(void);
void cmdDEL_ONE_Q(void);
void cmdDEL_TWO_Q(void);
void cmdDEL_ONE_TWO_Q(void);
void cmdERR(void);
void cmdHWTRGEDGE(void);
void cmdIDN(void);
void cmdMODE(void);
void cmdMODEQ(void);
void cmdUNITS(void);
void cmdUNITSQ(void);
void cmdMOTOR_RS(void);
void cmdNET(void);
void cmdNETQ(void);
void cmdNETMQ(void);
void cmdNETSTATEQ(void);
void cmdOPC(void);
void cmdOPCQ(void);
void cmdOVER(void);
void cmdOVERQ(void);
void cmdOVS(void);
void cmdOVSQ(void);
void cmdRELC(void);
void cmdPODS(void);
void cmdPODSQ(void);
void cmdRST(short int TYPE);
void cmdREL(void);
void cmdREL_UL(void);
void cmdRELQ(void);
void cmdREMOTE(void);
void cmdREMQ(void);
void cmdSTEPQ(void);
void cmdSTEP_INC(void);
void cmdSTEP_DEC(void);
void cmdSTEP(void);
void cmdCTSTOREM(void);
void cmdCTSTOREMQ(void);
void cmdTSTQ(void);
void cmdCLS(void);
void cmdSET_DELAY(void);
void cmdHWFD(void);
void cmdQUERYR_UL(void);
float computeMOD_F(float _Argument);
void cmdTERM(void);
void cmdTERMQ(void);
void cmdMEMSTORE(void);
void cmdMEMPTR(void);
void cmdMEMPTRQ(void);
void cmdMEMWRAP(void);
void cmdMEMWRAPQ(void);
void cmdMEMQ(void);
void cmdTRIGGER(void);
void cmdTRIGGERQ(void);
void cmdMEMPTRW(void);
void cmdMEMPTRWQ(void);

unsigned int _DetermineRelayPattern(signed long _ul);

/*** EndHeader */

// 11.23.21 BUILD_2203_RD112021
unsigned int _DetermineRelayPattern(signed long _ul)
{
    // PERFORM SUCCESSIVE SUBTRACTION ON HW_RELAYS.RELAY_UL[] TO GET RELAY PATTERN
    // RETURN THE RELAY PATTERN

    unsigned int _RelayPattern;
    int _i;
    signed long _SuccessiveAmount;
    int _BitPointer;
    int _RelaySectionValuesODD;
    signed long _SumRelaysLessLast;

    _RelaySectionValuesODD = false;
    _RelayPattern = 0;
    _SumRelaysLessLast = 0;
    _SuccessiveAmount = _ul; // START WITH THE AMOUNT ENTERED

    //
    // DETERMINE IF IN ODD OR EVEN RELAY SECTION VALUES
    // TO DETERMINE IF TO TURN ON OR NOT THE LAST RELAY SECTION TO CREATE RELAY_PATTERN
    // SET _RelaySectionValuesODD TO TRUE IF ODD AND FALSE IF EVEN
    //

    if (HW_RELAYS.RELAY_UL[HW_RELAYS.NUM_OF_SECTIONS] < HW_RELAYS.RELAY_UL[HW_RELAYS.NUM_OF_SECTIONS - 1])
    {
        _RelaySectionValuesODD = TRUE;
        for (_i = 1; _i < HW_RELAYS.NUM_OF_SECTIONS; _i++)
        {
            _SumRelaysLessLast += HW_RELAYS.RELAY_UL[_i]; // get sum of all delays sections except for last one
        }
    }
    else
    {
        _RelaySectionValuesODD = FALSE;
    }

    for (_i = HW_RELAYS.NUM_OF_SECTIONS; _i >= 1; _i--)
    {
        //
        // CHECK TO SEE IF THIS IS THE LAST RELAY SECTION
        // IF LAST SECTION AND RELAYS ARE ODD (I.E. NOT BINARY EVEN STEPS OF DELAY)
        // THEN ONLY USE THIS LAST BIT IF SPECIFIED DELAY IS EXACTLY MAX
        // OR SPECIFIED DELAY IS MORE THAN THE NEXT TO LAST DELAY SECTION VALUE
        //
        if (_i == HW_RELAYS.NUM_OF_SECTIONS)
        {
            if ((_ul == (signed long)MAX_DELAY_SETTING) ||
                ((_ul > (signed long)_SumRelaysLessLast) && (_RelaySectionValuesODD == TRUE)) ||
                (_RelaySectionValuesODD == FALSE))
            {
                // PERFORM SUCCESSIVE SUBTRACTION ON THIS STEP //
                if ((_SuccessiveAmount >= HW_RELAYS.RELAY_UL[_i]) || (_SuccessiveAmount == (long)MAX_DELAY_SETTING))
                {
                    _BitPointer = 0x0001;
                    _BitPointer = (_BitPointer << _i - 1);
                    _RelayPattern = _RelayPattern | _BitPointer; // LOGICAL OR | SETS THE BIT ON
                    _SuccessiveAmount = _SuccessiveAmount - ((signed long)HW_RELAYS.RELAY_UL[_i]);
                }
            }
        }
        else
        {
            // FOR ALL THE OTHER STEPS OTHER THAN THE LAST ONE, PERFORM SUCCESSIVE SUBTRACTION
            // PERFORM SUCCESSIVE SUBTRACTION ON THIS STEP //
            if ((_SuccessiveAmount >= HW_RELAYS.RELAY_UL[_i]) || (_SuccessiveAmount == (long)MAX_DELAY_SETTING))
            {
                _BitPointer = 0x0001;
                _BitPointer = (_BitPointer << _i - 1);
                _RelayPattern = _RelayPattern | _BitPointer; // LOGICAL OR | SETS THE BIT ON
                _SuccessiveAmount = _SuccessiveAmount - ((signed long)HW_RELAYS.RELAY_UL[_i]);
            }
        }
    }
    // _RelayPattern has the bits on to set the relay on or off
    return _RelayPattern;
}

void cmdCAL(void)
{
    // Description:   Handles *CAL? and *CAL command for perform calibration self-check
    // Args:          None.
    // Returns:       Calibrated (TRUE or FALSE).
    // Prereq:        None.
    // Globals:
    // Notes:         Unit MUST be calibrated before calling PDLSetDelay

    // 03.28.18 execute this code for ALL PDL and CPDL devices

// 03.28.18 - if this is a PRIMARY_TROMBONE, send *CAL to (SECONDARY_TROMBONE)
#ifdef DEVICE_XT200
#ifdef PRIMARY_TROMBONE                           // 02.14.22 ADD THE '>' CHAR FROM PRIMARY TROMBONE
    SYSTEM_OutputSecTrombone(">*CAL\r\n");        // send the *CAL command to the secondary unit only for PDL-200A-1.25NS primary to do
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = 0; // set to ZERO since calibration just completed
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = 0.0;
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_E = 0.0;
#endif
#endif

// 04.20.18 handle all the different device model types
#ifdef DEVICE_XT100
    SYSTEM_ExecuteTromboneCalibration();
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    SYSTEM_ExecuteTromboneCalibration();
#endif
#ifdef DEVICE_XT200
    SYSTEM_ExecuteTromboneCalibration();
#endif

#ifdef DEVICE_XR100
    cmdTSTQ(); // FOR XR-100 only the relays need to be cycled.
#endif

    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS = 0; // current delay value in picoseconds for Channel One
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = 0; // current delay value in picoseconds for Channel Two
    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = 0;  // 03.28.18 added
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = 0;  // 03.28.18 added
    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_E = 0;  // 03.28.18 added
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_E = 0;  // 03.28.18 added

    INSTRUMENT.stateMENU_MODE = 0;

} // end cmdCAL

void cmdCTSTORE(void)
{

    /*------------------------------------------------------------------------------
    Description	:	Set calibration table values in NVPARAMETERS using command:]
                    CTSTORE ITEM# VALUE
    Arguments	:	cmdARG2 and cmdARG3
    Returns		:
    Prereq:     :	cmdARG1 has ASCII value CAL command
    Globals		:
    Notes:
// 11.02.10 	: 	CODE VERIFIED
//------------------------------------------------------------------------------*/
    //

    int index;
    int _Value;
    int _i;
    int j;
    char TEMP[SIZE_CAL_INFO_FIELD];
    int _MaxChars;

    if (strcmp(cmdARG2, "SAVE") == 0)
    { // added 09.16.06
        SYSTEM_SaveNVParametersXT();
        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    } // save all to NV RAM persistent storage
    else
    {
        if (strcmp(cmdARG2, "LOAD") == 0)
        {                                // added 09.16.06
            SYSTEM_LoadNVParametersXT(); // read all parameters from NVRAM STORAGE
            INSTRUMENT.stateERROR = FALSE;
            INSTRUMENT.stateERROR_CODE = NO_ERROR;
        } // load the calibration table into global memory g_CAL_TABLE from NVRAM storage
        else
        {
            if (strcmp(cmdARG2, "RESET") == 0)
            { // added 09.16.06
                // 05.08.18 initialize the CTSTORE? INFO area and the CTSTORE CAL table
                // int   nv_cal_table[SIZE_CAL_TABLE];     // float for XXX-1000A # of PS with 3 decimal pt precision adjustment
                // char  nv_cal_info[SIZE_CAL_INFO_FIELD]; // calibration table information max of 128 characters

                for (_i = 0; _i < SIZE_CAL_TABLE; _i++)
                { // BUG FIX (SHOULD BE < NOT <=)
                    g_NVParameters.nv_cal_table[_i] = 0;
                }

                for (_i = 0; _i < SIZE_CAL_INFO_FIELD; _i++)
                {
                    g_NVParameters.nv_cal_info[_i] = 0;
                }

                strcpy(g_NVParameters.nv_cal_info, "NO CALIBRATION");
                g_NVParameters.nv_useCTSTORE = FALSE;

                INSTRUMENT.stateERROR = FALSE;
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            } // load the calibration table into global memory g_CAL_TABLE from NVRAM storage
            else
            {
                if (strcmp(cmdARG2, "INFO") == 0)
                { // store just the CAL TABLE INFORMATION PART ONLY
                    if (strlen(cmdARG3) != 0)
                    {
                        // 02.04.09 COPY FROM 13th char to the end "CTSTORE INFO X..."
                        _MaxChars = strlen(GLOBAL_SETTINGS.COMMAND_LINE_COPY);
                        if ((_MaxChars - 13) > SIZE_CAL_INFO_FIELD)
                        {
                            _MaxChars = SIZE_CAL_INFO_FIELD + 13;
                        }

                        for (j = 13; j < _MaxChars; j++)
                        {
                            TEMP[j - 13] = GLOBAL_SETTINGS.COMMAND_LINE_COPY[j];
                        }
                        strcpy(g_NVParameters.nv_cal_info, TEMP);
                        SYSTEM_SaveNVParametersXT();
                        INSTRUMENT.stateERROR = FALSE;
                        INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    }
                    else
                    {
                        INSTRUMENT.stateERROR = TRUE;
                        INSTRUMENT.stateERROR_CODE = INVALID_ARG;
                    }
                }
                else
                {

                    if (strcmp(cmdARG2, "ON") == 0)
                    {
#if defined(DEVICE_XS100)
                        GLOBAL_SETTINGS.USE_CAL_TABLE = TRUE; // 08.19.22 replace XS_USE_CAL_TABLE to USE_CAL_TABLE
#else
                        GLOBAL_SETTINGS.USE_CAL_TABLE = TRUE;
#endif
                        g_NVParameters.nv_useCTSTORE = TRUE;
                        SYSTEM_SaveNVParametersXT();
                        INSTRUMENT.stateERROR = FALSE;
                        INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    } // use the calibration table
                    else
                    {
                        if (strcmp(cmdARG2, "OFF") == 0)
                        { // added 09.16.06
#if defined(DEVICE_XS100)
                            GLOBAL_SETTINGS.USE_CAL_TABLE = FALSE; // 08.19.22 replace XS_USE_CAL_TABLE to USE_CAL_TABLE
#else
                            GLOBAL_SETTINGS.USE_CAL_TABLE = FALSE;
#endif
                            g_NVParameters.nv_useCTSTORE = FALSE;
                            SYSTEM_SaveNVParametersXT();
                            INSTRUMENT.stateERROR = FALSE;
                            INSTRUMENT.stateERROR_CODE = NO_ERROR;
                        } // DO NOT USE the calibration table
                        else
                        {

                            if (strlen(cmdARG2) != 0)
                            {
                                index = atoi(cmdARG2);
                            }
                            else
                            {
                                index = 0;
                            } // end-else-if

                            if (strlen(cmdARG3) != 0)
                            {
                                _Value = atoi(cmdARG3); // make this a FLOAT
                            }
                            else
                            {
                                _Value = 0;
                            } // end-else-if

                            if ((index >= 0) && (index <= SIZE_CAL_TABLE - 1))
                            { // 0 thru SIZE_CAL_TABLE
                                g_NVParameters.nv_cal_table[index] = _Value;
                                INSTRUMENT.stateERROR = FALSE;
                                INSTRUMENT.stateERROR_CODE = NO_ERROR;
                            }
                            else
                            {
                                INSTRUMENT.stateERROR = TRUE;
                                INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
                            }
                        } // end-else
                    }     // end-else //02.04.09
                }         // end-else
            }             // end-else
        }                 // end-else
    }                     // end-else
} // end cmdCTSTORE

void cmdCTSTRQ(void)
{

    /*------------------------------------------------------------------------------
    Description	:	Returns the float value from CTSTORE table entry. If no arg2 entry, then return
                    1 = CTSTORE in-memory table in use or 0 = do NOT use in-memory CTSTORE table
   // 01.31.18 modified to handle FLOAT argument in CTSTORE entry for XXX-1000A
    Args			:   None.
    Returns		:
    Prereq		:   None.
    Globals		:
    Notes			:   None.
// 11.02.10 	: 	CODE VERIFIED
//------------------------------------------------------------------------------*/
    //

    int _TableEntry; // signed integer specifying the integer # of FEMTOSECONDS for calibration delta
    int _Index;
    short _InvalidIndex;

    _InvalidIndex = FALSE;

    if (strlen(cmdARG2) != 0)
    {
        _Index = (unsigned int)atoi(cmdARG2); // use this as the index
        if ((_Index >= 0) && (_Index <= SIZE_CAL_TABLE - 1))
        {
            _TableEntry = g_NVParameters.nv_cal_table[_Index];
        }
        else
        {
            _TableEntry = 0; // invalid index (not <= SIZE_CAL_TABLE-1)
            _InvalidIndex = TRUE;
        }
    }
    else
    {
        _Index = 0;
        _TableEntry = FALSE; // false is the same as zero
        // 10.22.08 CTSTORE? with no arguments, then return 1=if using cal table or 0=NOT using cal table
        if (GLOBAL_SETTINGS.USE_CAL_TABLE)
        {
            _TableEntry = TRUE;
        }
    } // end-else-if

    // if _Index is -1 or cmdARG2 == "info" then display info string else display the Table Entry
    // 10.04.17

    if ((_Index == -1) || (strcmp(cmdARG2, "INFO") == 0))
    {
        // 02.04.09
        //-1 therefore display string from NVRAM INFO
        sprintf(BUFFERS.DISPLAY_LINE, "%s\r\n", g_NVParameters.nv_cal_info);
        SYSTEM_OutputQueryResponse();
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    }
    else
    {
        sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", _TableEntry);
        SYSTEM_OutputQueryResponse();
        if (_InvalidIndex == FALSE)
        {
            INSTRUMENT.stateERROR_CODE = NO_ERROR;
        }
        else
        {
            INSTRUMENT.stateERROR_CODE = INVALID_ARG;
        }
    }

} // cmdCTSTRQ

void cmdCTSTOREM(void)
{
    /*------------------------------------------------------------------------------
    Description	: 	Handles CTSTOREM for CTSTORE MULTIPLE VALUES
    Arguments	:	cmdARG2
    Returns		:
    Prereq		:
    Globals		:
    Notes		: 	CTSTOREM Location a,b,c,d,e,f, ...
                : 	store multiple entries a,b,c,d,e,f,,.. starting at Location
                :	in the CTSTORE TABLE
//------------------------------------------------------------------------------*/
    // cmdARG2 has the starting location to store the multiple values
    // BUFFERS.INPUT_COMMAND_LINE [] has the current entire command line as read in from GPIB,ENET,-or-SERIAL
    // scans BUFFERS.INPUT_COMMAND_LINE [] until it finds a semicolon and returns its position
    // 06.19.21 BUG FIX ... DO NOT USE PARSE VALUE ... parse values correctly in download table from host

    int _Index, _IndexSpaceOne, _IndexSpaceTwo;
    int _IndexFirstCharEntryValue;
    int _EntryValueIndex;
    int _Length;
    int _LengthOfEntireBuffer;
    int _IndexCTSTORE;
    int _EachEntry_FS; // integer femtoseconds

    char StrStartingIndexCTSTORE[6] = {0}; // ALL NUL Characters
    char StrEachEntry[7] = {0};            // ALL NUL Characters
    int _CharPos;
    //   int _StrLength;   for testing
    int _j;

    _Index = 0;
    _IndexSpaceOne = 0;
    _IndexSpaceTwo = 0;

    // memset(_StartingIndexCTSTORE, 0x00, sizeof(_StartingIndexCTSTORE));
    // memset(_EachEntry, 0x00, sizeof(_EachEntry));

    _LengthOfEntireBuffer = strlen(BUFFERS.INPUT_COMMAND_LINE);
    // find the first space, then 1 thru first space location is CTSTOREM
    // find the second space, then first space thru second space is location
    // second space to next comma is first value
    // first comma and next comma is second value ... etc...
    // this method also assumes there are NO EXTRA SPACES IN THE ENTIRE STRING BUFFERS.INPUT_COMMAND_LINE

    _IndexSpaceOne = -1;
    _IndexSpaceTwo = -1;
    for (_Index = 0; _Index < _LengthOfEntireBuffer; _Index++)
    {
        if (BUFFERS.INPUT_COMMAND_LINE[_Index] == ' ')
        {
            if (_IndexSpaceOne == -1)
            {
                _IndexSpaceOne = _Index + 1; // point to the first character of the data value for the index
            }
            else
            {
                if (_IndexSpaceTwo == -1)
                { // point to space char after the data value
                    _IndexSpaceTwo = _Index;
                    break; // break the for loop since the second space is found
                }
            }
        } // END-if
    }     // end-for

    _Length = _IndexSpaceTwo - _IndexSpaceOne; // # of chars in the data value

    if (_Length >= _LengthOfEntireBuffer)
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG;
    }

    _CharPos = 0;
    for (_j = _IndexSpaceOne; _j < _IndexSpaceTwo; _j++)
    {
        StrStartingIndexCTSTORE[_CharPos++] = BUFFERS.INPUT_COMMAND_LINE[_j];
    }
    _IndexCTSTORE = atoi(StrStartingIndexCTSTORE);

    if ((_IndexCTSTORE < 0) || (_IndexCTSTORE > SIZE_CAL_TABLE - 1))
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG;
        return;
    }

    // now starting from _IndexSpaceTwo, get all the values separated by a comma

    _IndexFirstCharEntryValue = _IndexSpaceTwo + 1; // point to the first char in the data value
    _EntryValueIndex = _IndexSpaceTwo + 1;          // point to the first char in the data value

    for (_Index = _IndexSpaceTwo + 1; _Index < _LengthOfEntireBuffer; _Index++)
    {
        if ((BUFFERS.INPUT_COMMAND_LINE[_Index] == ',') || (_Index == _LengthOfEntireBuffer - 1))
        { // check if comma or LAST CHAR IN BUFFER

            if (_Index == _LengthOfEntireBuffer - 1)
            {
                _Length = _Index + 1 - _IndexFirstCharEntryValue; // add ONE because last char (not a comma)
            }
            else
            {
                _Length = _Index - _IndexFirstCharEntryValue;
            }

            // EXTRACT A VALUE STARTING FROM INDEX _IndexFirstCharEntryValue AND LENGTH OF _Length CHARACTERS
            _CharPos = 0;
            for (_j = _IndexFirstCharEntryValue; _j < _IndexFirstCharEntryValue + _Length; _j++)
            {
                StrEachEntry[_CharPos++] = BUFFERS.INPUT_COMMAND_LINE[_j];
            }
            _EachEntry_FS = atoi(StrEachEntry);

            // Clear out and update for the next go around
            _IndexFirstCharEntryValue = _Index + 1;
            memset(StrEachEntry, 0x00, sizeof(StrEachEntry));

            // each entry must be within 10000 fs (+/- 10 ps) correction else is invalid
            if ((_EachEntry_FS >= -10000) && (_EachEntry_FS <= 10000) && (_IndexCTSTORE >= 0) && (_IndexCTSTORE <= SIZE_CAL_TABLE - 1))
            {
                if (_IndexCTSTORE < SIZE_CAL_TABLE)
                {
                    g_NVParameters.nv_cal_table[_IndexCTSTORE] = _EachEntry_FS;
                    _IndexCTSTORE = _IndexCTSTORE + 1;
                    _EntryValueIndex = _Index + 1;
                } // end if // only store this entry if index is valid
            }
        }
    } // end-for

    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = NO_ERROR;
} // end cmdCSTOREM

void cmdCTSTOREMQ(void)
{
    /*------------------------------------------------------------------------------
    Description	: Handles CTSTOREMQ query
                : display 10 data entires starting at location index
                : e.g. CTSTOREM? Location
                : returns: a,b,c,d,e,f,g,h,i,j
                : data values from CTSTORE CAL TABLE
    Arguments   : cmdARG2
    Returns     :
    Prereq      :
    Globals     :
   Notes    	: CTSTOREM Location a,b,c,d,e,f, ...
                : store multiple entries a,b,c,d,e,f,,.. starting at Location
                : in the CTSTORE TABLE
//------------------------------------------------------------------------------*/

    int _IndexCTSTORE;
    int _i;
    char _FinalDisplayLine[128];
    char _EachEntry[10];
    int _NumberOfEntries;

    // cmdARG2 has the starting location
    // cmdARG3 has number of entries to display else default is 20

    if (strlen(cmdARG3) != 0)
    {
        _NumberOfEntries = (unsigned int)atoi(cmdARG3);
        if ((_NumberOfEntries <= 0) || (_NumberOfEntries > 20))
        {
            _NumberOfEntries = 20;
        }
    }
    else
    {
        _NumberOfEntries = 20;
    }

    if (strlen(cmdARG2) != 0)
    {
        _IndexCTSTORE = (unsigned int)atoi(cmdARG2); // use this as the index
        if ((_IndexCTSTORE >= 0) && (_IndexCTSTORE <= SIZE_CAL_TABLE - 1))
        {

            // get 10 data values starting at _IndexCTSTORE

            for (_i = 0; _i < _NumberOfEntries; _i++)
            {
                if ((_IndexCTSTORE + _i) >= (SIZE_CAL_TABLE))
                { // 6251 is invalid
                    break;
                }
                sprintf(_EachEntry, "%d", g_NVParameters.nv_cal_table[_IndexCTSTORE + _i]);
                strcat(_FinalDisplayLine, _EachEntry);
                memset(_EachEntry, 0x00, sizeof(_EachEntry));
                if ((_i != (_NumberOfEntries - 1)) && ((_IndexCTSTORE + _i) != (SIZE_CAL_TABLE - 1)))
                {
                    strcat(_FinalDisplayLine, ",");
                }
            } // end for
            // sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n",_TableEntry);
            strcat(_FinalDisplayLine, "\r\n");
            strcpy(BUFFERS.DISPLAY_LINE, _FinalDisplayLine);
            SYSTEM_OutputQueryResponse();
            INSTRUMENT.stateERROR = FALSE;
            INSTRUMENT.stateERROR_CODE = NO_ERROR;
        }
    }
    else
    {
        INSTRUMENT.stateERROR_CODE = INVALID_ARG;
        INSTRUMENT.stateERROR = TRUE;
    } // end-else-if

} // end cmdCSTOREMQ

void cmdDEL(void)
{

    //
    // DETERMINE IF BUILDING FOR XT-100 OR FOR XR-100 AND SELECT CORRESPONDING cmdDEL_* command
    //
    // THIS HANDLES THE DEL COMMAND TO SET DELAY

#ifdef DEVICE_XT100
    // cmdDEL_XT100(); // do not use this API
    cmdSET_DELAY(); // use this API
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    cmdSET_DELAY(); // use this API
#endif

// 04.19.18
#ifdef DEVICE_XR100
    cmdDEL_XR100();
    INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
#endif

#if defined(DEVICE_XS100)
    cmdSET_DELAY();
    INSTRUMENT.stateOPERATION_COMPLETE = TRUE; // 08.19.22 REPORT OPERATION COMPLETE AFTER SENDING DELAY COMMAND
#endif

} // end cmdDEL function

void cmdDEL_XR100(void)
{

    // Description:   Handles DEL or del command to set delay value
    //                for XR-100 Series Instruments
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    float delay_setting;
    char far *_TailPtr;
    unsigned int delay_trunc_i; // least sig digit
    unsigned int delay_int_only;
    float delay_trunc_f;
    float delay_temp;

    unsigned int delay_overflow_int; // if int portion of delay > 65536
    unsigned char delay_overflow;    // flag there is overflow
    unsigned char delay_overflow_2;  // 05.23.18 flag is there is more overflow of additional 65535
    unsigned char delay_overflow_3;  // 05.23.18 flag is there is even more overflow of additional 65535

    float delay_answer; // for bug FIX VER 1.06

    // 06.05.06 if the length of cmdARG3 is 4, it could be scientific notation with a space char, therefore combine
    // combine cmdARG2 with cmdARG3

    if (strlen(cmdARG3) == 4)
    {
        strcat(cmdARG2, cmdARG3);
    }

    delay_setting = atof(cmdARG2);

    delay_setting = _f_strtod(cmdARG2, &_TailPtr);

    // NOTE: THIS NEEDS TO BE TESTED //

    // if (_xtoxErr)
    //{
    //    INSTRUMENT.stateERROR = TRUE;
    //    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
    // }
    // else
    //{

    delay_overflow = FALSE;
    delay_overflow_2 = FALSE; // 05.23.18 // 11.16.10
    delay_overflow_3 = FALSE; // 05.23.18 // 11.16.10

    if ((strcmp(cmdARG3, "PS") == 0) || (strcmp(cmdARG3, "ps") == 0) || ((INSTRUMENT.stateDEVICE_DISPLAY_NS == FALSE) && (INSTRUMENT.stateCMD_FROM_TERM)))
    { // bug fix: added terminal check
        INSTRUMENT_SETTINGS.CURRENT_UNITS = PS;
    } // end-if
    else
    {
        if ((strcmp(cmdARG3, "NS") == 0) || (strcmp(cmdARG3, "ns") == 0))
        {
            INSTRUMENT_SETTINGS.CURRENT_UNITS = NS;
            delay_setting = delay_setting * 1000;
        } // end-if
    }     // end-else-if

    // 06.04.06 delay_setting contains the converted cmdARG2 value
    // e.g. DEL 50 ps ==> delay_setting should contain 50 (units of ps)
    // e.g. DEL 50.0E-12 ==> delay_setting should contain 50 (units of ps)
    // 06.04.06 DETERMINE WHETHER TO HANDLE cmdARG2 as DECIMAL OR SCIENTIFIC NOTATION
    //
    if ((delay_setting > 0.0) && (delay_setting <= 1.0E-06))
    {
        // SCIENTIFIC NOTATION!!
        delay_setting = delay_setting * 1.0E+12;
    }

    // BUG FIX:
    //  06.17.05 VER 1.06

    delay_answer = delay_setting - PARAMETERS.deviceMAX_DELAY_PS;

    // ORG      if ((delay_answer >= 0) && (delay_answer <= 0.001))
    // ORG         delay_setting = deviceMAX_DELAY_PS;

    // 06.20.06
    // this fixes the bug where delay_setting computes to being GREATER than
    // deviceMAX_DELAY_PS but really isn't because it is really 0.0019.... off.
    // e.g. specifying device limit of 20.460 ns doesnt work but is fixed now
    //
    if ((delay_answer >= 0) && (delay_answer <= 0.5))
    {
        delay_setting = PARAMETERS.deviceMAX_DELAY_PS;
    }

    if (delay_setting > PARAMETERS.deviceMAX_DELAY_PS)
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
        INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
    }

    else
    {
        delay_temp = delay_setting / 1; // get just the integer portion
        if (delay_temp > 65535.0)
        {
            delay_overflow = TRUE;
            delay_temp = delay_temp - 65535.0;
        }

// 05.23.18
#ifdef TEN_X
        if (delay_temp > 65535.0)
        {                            // for 131.070 to 196.605 NS
            delay_overflow_2 = TRUE; // record this overflow_2
            delay_temp = delay_temp - 65535.0;
        }

        if (delay_temp > 65535.0)
        {                            // for 196.605ns and up
            delay_overflow_3 = TRUE; // record this overflow_3
            delay_temp = delay_temp - 65535.0;
        }
#endif

        // following steps of code are used to ROUND down the desired delay to
        // nearest step size ...

        // determine just the INTEGER portion of the desired delay
        delay_int_only = (unsigned int)(delay_temp + 0.50f); // 06.21.21 proper way to convert float to int

        // determine just the value to the RIGHT of the dec point, called truncated
        if (delay_overflow)
        {
            delay_trunc_f = delay_setting - 65535.00 - delay_int_only;
// 05.23.18
#ifdef TEN_X
            // if there were overflows, then successively remove 65535
            if (delay_overflow_2)
            {
                delay_trunc_f = delay_trunc_f - 65535.00;
            }
            if (delay_overflow_3)
            {
                delay_trunc_f = delay_trunc_f - 65535.00;
            }
#endif
        }
        else
        {
            delay_trunc_f = delay_setting - delay_int_only;
        }

        // delay_trunc_f has the TRUNCATED portion as a floating point variable

        // delay_trunc_i has the TRUNCATED portion as an unsigned integer variable
        delay_trunc_i = (unsigned int)((delay_trunc_f + 0.01) * 100.0);

        // 05.14.05 -- BECAUSE THIS IS A CPDL, then resolution is to the 1 ps
        // CANNOT SEPCIFY A PS VALUE RESOLUTION LESS THAN 1 PS
        // THEREFORE MAKE THE TRUNCATED PART EQUAL TO ZERO !!
        delay_trunc_i = 0;

        // ROUND DOWN to nearest step size of XT-100 motor
        if ((delay_trunc_i >= 0) && (delay_trunc_i <= 24))
            delay_setting = (float)delay_int_only; // .00 thru .24 rounds down

        if ((delay_trunc_i >= 25) && (delay_trunc_i <= 49))
        {
            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                delay_setting = (float)delay_int_only; // .00 thru .24 rounds down
            else
                delay_setting = delay_int_only + 0.25;
        } // end-if

        if ((delay_trunc_i >= 50) && (delay_trunc_i <= 74))
            delay_setting = delay_int_only + 0.50;

        if ((delay_trunc_i >= 75) && (delay_trunc_i <= 99))
        {
            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {
                delay_setting = (float)(delay_int_only + 1); // round up
            }
            else
            {
                delay_setting = delay_int_only + 0.75;
            }

        } // end-if

        if ((delay_trunc_i >= 100) || ((delay_trunc_f > 0.50) && (delay_trunc_f < 1.0))) // 05.14.05 added additional check to handle 99.999 ns
            delay_setting = (float)delay_int_only + 1.0;

        // delay_setting now contains valid rounded down to nearest step size desired delay

        // if there is a delay_overflow (because # > 65536), then compensate

        if (delay_overflow)
            delay_setting = delay_setting + 65535.0;
// 05.23.18
#ifdef TEN_X
        // if there were overflows, then add them back into the total delay setting
        if (delay_overflow_2)
            delay_setting = delay_setting + 65535.0;

        if (delay_overflow_3)
            delay_setting = delay_setting + 65535.0;

#endif

        // 12-13-04
        DISPLAY_SETTINGS.CURRENT_DELAY_F = delay_setting; // put value into CurrentDelay_F for display

        if (((INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL) && (delay_setting > 625.0)) ||
            ((INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL) && (delay_setting > PARAMETERS.deviceMAX_DELAY_PS)))
        {
            INSTRUMENT.stateERROR = TRUE;
            INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
            INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
        }
        else
        {

            // NOW SET THE DELAY TO THE DESIRED DELAY SETTING
            if (SYSTEM_DeviceSetDelayNoOVS(delay_setting) == TRUE)
            { // set the delay!!
                INSTRUMENT.stateERROR = FALSE;
            } // end-if
            else
            {
                INSTRUMENT.stateERROR = TRUE;
                INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
            } // end else-if
        }     // end-else-if
    }

    //} // end-if

} // end cmdDEL_XR100

void cmdDEL_ONE(void)
{
    // set the delay in CHANNEL ONE
    INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
    cmdSET_DELAY(); // 04.18.18 use cmdSET_DELAY instead of cmdDEL_XT100
                    // MOTOR CODE will set INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
} // end cmdDEL_ONE set the delay in channel ONE

void cmdDEL_TWO(void)
{
    // set the delay in CHANNEL TWO
    INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
    cmdSET_DELAY(); // 04.18.18 use cmdSET_DELAY instead of cmdDEL_XT100
                    // MOTOR CODE will set INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
} // end cmdDEL_TWO set the delay in channel TWO

void cmdDEL_ONE_Q(void)
{
    // returns the current delay setting for channel ONE into SYSTEM_OutputQueryResponse
    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
    {
        DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS * 1.0E-12;
    }
    else
    {
// 11.11.21 BUILD2112_RD102121_RD111121
// 11.13.21 HANDLE PARALLEL MODE FOR DEVICE_XT200_312P
#ifdef DEVICE_XT200_312P
        DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS * 1.0E-12;
#else
        DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS * 0.50E-12;
#endif
    }
    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = NO_ERROR;
    sprintf(BUFFERS.DISPLAY_LINE, "%12.4e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E);
    SYSTEM_OutputQueryResponse(); // return result in EXPONENTIAL notation
} // end cmdDEL_ONEQ to query delay in channel ONE

void cmdDEL_TWO_Q(void)
{

    // returns the current delay setting for channel TWO into SYSTEM_OutputQueryResponse
    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
    {
        DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS * 1.0E-12;
    }
    else
    {
// 11.11.21 BUILD2112_RD102121_RD111121
// 11.13.21 HANDLE PARALLEL MODE FOR DEVICE_XT200_312P
#ifdef DEVICE_XT200_312P
        DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS * 1.0E-12;
#else
        DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS * 0.50E-12;
#endif
    }
    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = NO_ERROR;
    sprintf(BUFFERS.DISPLAY_LINE, "%12.4e\r\n", DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E);
    SYSTEM_OutputQueryResponse(); // return result in EXPONENTIAL notation
} // end cmdDEL_TWOQ to query delay in channel TWO

void cmdDEL_ONE_TWO_Q(void)
{
    // returns the current delay setting for channel ONE and TWO into SYSTEM_OutputQueryResponse
    float display_one, display_two;

    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
    {
        DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS * 1.0E-12;
        DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS * 1.0E-12;
        display_one = DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E;
        display_two = DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E;
    }
    else
    {
// 11.11.21 BUILD2112_RD102121_RD111121
// 11.13.21 HANDLE PARALLEL MODE FOR DEVICE_XT200_312P
#ifdef DEVICE_XT200_312P
        DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS;
        DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS;
        display_one = DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E;
        display_two = DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E;
#else
        DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS * 0.50E-12;
        DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS * 0.50E-12;
        display_one = DISPLAY_SETTINGS.CURRENT_DELAY_ONE_E;
        display_two = DISPLAY_SETTINGS.CURRENT_DELAY_TWO_E;
#endif
    }
    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = NO_ERROR;
    sprintf(BUFFERS.DISPLAY_LINE, "%12.4e,%12.4e\r\n", display_one, display_two);
    SYSTEM_OutputQueryResponse(); // return result in EXPONENTIAL notation
} // end cmdDEL_ONEQ to query delay in channel ONE

void cmdERR(void)
{
    // Description:   Handles *ERR? command to return last error value
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    int DisplayErrorCode;

    DisplayErrorCode = (int)INSTRUMENT.stateERROR_CODE;
    sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", DisplayErrorCode); // add \r 06.11.2010
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // end cmdERR

void cmdHWFD(void)
{

    HWIO_FactoryDefault();
    INSTRUMENT.stateERROR_CODE = NO_ERROR;
    INSTRUMENT.stateERROR = FALSE;
}

void cmdHWTRGEDGE(void)
{

    /*------------------------------------------------------------------------------
   //	DESCRIPTION	:	Sets the INSTRUMENT.EXT_HW_EDGE_TYPE MODE (0 = none, 1= + edge, 2 = - edge)
   //					to detect the edge type to TRIGGER. Sets the XIRQ Interrupt Type.
   Arguments	:  	cmdARG2
   Returns		:  	INSTRUMENT.EXT_HW_EDGE_TYPE
   Prereq		:  	cmdARG2 has type of edge
   Globals		:
   Notes		: 	HWTRIG type COMMAND
   // 11.02.10 	: 	CODE VERIFIED
   //------------------------------------------------------------------------------*/
    int input_value;

    input_value = atoi(cmdARG2);
    switch (input_value)
    {

    case NONE_EDGE:
        INSTRUMENT.EXT_HW_EDGE_TYPE = FALSE;
        break;
        //      case ENABLE:  // 1 = ENABLE == RISE_EDGE

    case RISE_EDGE:
        INSTRUMENT.EXT_HW_EDGE_TYPE = RISE_EDGE; // 2
        break;

        //      case RISE_EDGE:	// + edge
        //      	INSTRUMENT.EXT_HW_EDGE_TYPE = RISE_EDGE;
        //			break;

    case FALL_EDGE:                              // FALL = 1
        INSTRUMENT.EXT_HW_EDGE_TYPE = FALL_EDGE; // 1
        break;

    case BOTH_EDGE:
        INSTRUMENT.EXT_HW_EDGE_TYPE = BOTH_EDGE;
        break;

    default:
        INSTRUMENT.stateERROR_CODE = INVALID_ARG;
        INSTRUMENT.stateERROR = TRUE;
        break;
    } // end-switch

    //	g_XIRQ_EDGE_TYPE = g_EXT_HW_TRIGGER_TYPE;
    // XIRQ0OnOff(0);  //disable so can program it again! 11.04.08

    // EnableDisable_XIRQ(FALSE);

    // Initialize external interrupt
    // XIRQ0Init(EXT_HW_TRIGGER) ;      // setup callback function
    // XIRQ0OnOff(1);  //enable interrupt
    // g_NUM_EXT_HW_DETECTED = 0 ;

    HWIO_Initialize_XIRQ(INSTRUMENT.EXT_HW_EDGE_TYPE);
    // EnableDisable_XIRQ(TRUE);

    // 11.29.21 BUILD_RD112021
    HWIO_EnableDisable_XIRQ(TRUE); // enable hw interrupt

    INSTRUMENT.stateERROR_CODE = NO_ERROR;
    INSTRUMENT.stateERROR = FALSE;
} // end cmdHWTRGEDGE

void cmdIDN(void)
{
    // Description:   Handles *IDN? command
    // Args:          None.
    // Returns:       Displays string with *IDN information.
    // Prereq:        None.
    // Globals:
    // Notes:         None.

#ifdef DEVICE_XT200
#ifdef PRIMARY_TROMBONE
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-312P,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceSN, swVERSION);
#else
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-625P,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceSN, swVERSION);
#endif
#endif
#ifdef SECONDARY_TROMBONE
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-312P,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceSN, swVERSION);
#else
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-625P,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceSN, swVERSION);
#endif
#endif

#endif

#ifdef DEVICE_XT100
#ifndef SECONDARY_TROMBONE
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-%s,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceIDN_DISPLAY, deviceSN, swVERSION);
#else
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-625P,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceSN, swVERSION);
#endif
#endif

// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
#ifndef SECONDARY_TROMBONE
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-%s,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceIDN_DISPLAY, deviceSN, swVERSION);
#else
    // 11.11.21 BUILD2112_RD102121_RD111121
    // 11.13.21 DISPLAY 312P (NOT 625P)
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-312P,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceSN, swVERSION);
#endif
#endif

#ifdef DEVICE_XR100
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-%s,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceIDN_DISPLAY, deviceSN, swVERSION);
#endif

#if defined(DEVICE_XS100)
    sprintf(BUFFERS.DISPLAY_LINE, "%s,%s-%s,%s,%s\r\n", deviceMANUFACTURER, deviceMODEL, deviceIDN_DISPLAY, deviceSN, swVERSION);
#endif

    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR;

} // end cmdIDN

void cmdMODE(void)
{
    //
    // Description:   Handles MODE command to set to device mode (312.5ps | PAR | 625ps | SER)
    //
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:       stateMODE = DEVICE_PARALLEL | DEVICE_SERIAL
    // Notes:         None.
    //
    // ARG1 = MODE
    // ARG2 = SER | 625ps | 312.5 ps | PAR | IP | DHCP
    // ARG3 = ipaddress | on | ON | off | OFF
    //

    if ((strcmp(cmdARG2, "312.5ps") == 0) || (strcmp(cmdARG2, "312.5PS") == 0))
        INSTRUMENT.stateDEVICE_MODE = DEVICE_PARALLEL;
    if ((strcmp(cmdARG2, "PAR") == 0) || (strcmp(cmdARG2, "par") == 0))
        INSTRUMENT.stateDEVICE_MODE = DEVICE_PARALLEL;

// 10.06.21 RD081621 BUILD -- 312P ALWAYS PARALLEL MODE
#ifndef DEVICE_XT100_312P
    if ((strcmp(cmdARG2, "625ps") == 0) || (strcmp(cmdARG2, "625PS") == 0))
        INSTRUMENT.stateDEVICE_MODE = DEVICE_SERIAL;
    if ((strcmp(cmdARG2, "SER") == 0) || (strcmp(cmdARG2, "ser") == 0))
        INSTRUMENT.stateDEVICE_MODE = DEVICE_SERIAL;
#endif

    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME

// 03.29.18 handle additional device modes
#ifdef DEVICE_XT200
    if ((strcmp(cmdARG2, "DEL1") == 0) || (strcmp(cmdARG2, "del1") == 0))
        INSTRUMENT.stateDEL_CHANNEL = CHANNEL_ONE;
    if ((strcmp(cmdARG2, "DEL2") == 0) || (strcmp(cmdARG2, "del2") == 0))
        INSTRUMENT.stateDEL_CHANNEL = CHANNEL_TWO;
    //   if ((strcmp(cmdARG2, "DEL3") == 0) || (strcmp(cmdARG2, "del3") == 0))
    //      INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH;
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME

    if (strcmp(cmdARG2, "CYCL") == 0)
    {
        if (strlen(cmdARG3) != 0)
        {
            switch (atoi(cmdARG3))
            {
            case 1:
                INSTRUMENT.stateCYCLE_MODE = CYCLE_SEQ;
                break;
            case 2:
                INSTRUMENT.stateCYCLE_MODE = CYCLE_UNIT;
                break;
            case 3:
                INSTRUMENT.stateCYCLE_MODE = CYCLE_CHANNEL;
                break;
            default:
                INSTRUMENT.stateCYCLE_MODE = CYCLE_UNIT; // default
                break;
            }                                      // end-switch
            INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
        }
        else
        {
            INSTRUMENT.stateERROR_CODE = INVALID_ARG;
        }
    }
#endif

    if ((strcmp(cmdARG2, "TERM") == 0) || (strcmp(cmdARG2, "term") == 0))
    {

        if ((strcmp(cmdARG3, "ON") == 0) || (strcmp(cmdARG3, "on") == 0))
        {
            INSTRUMENT.stateDEVICE_MODE_MT100A = TRUE; // set MT-100A MODE to ON
            g_NVParameters.nv_terminal_mode = FALSE;   // means RS-232 in MT-100A mode, not terminal_mode
            SYSTEM_SaveNVParametersXT();
        }
        else
        {
            INSTRUMENT.stateDEVICE_MODE_MT100A = FALSE; // set MT-100A MODE to OFF
            g_NVParameters.nv_terminal_mode = TRUE;     // means RS-232 in terminal_mode; NOT MT-100A mode
            SYSTEM_SaveNVParametersXT();
        }
    }

} // cmdMODE

void cmdMODEQ(void)
{
    // Description:   Returns the state of the MODE (either parallel or serial)
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:       stateMODE = DEVICE_PARALLEL | DEVICE_SERIAL
    // Notes:         None.
    //

#ifdef DEVICE_XT100
    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
    {
        sprintf(BUFFERS.DISPLAY_LINE, "625PS\r\n");
    } // end-if
    else
    {
        sprintf(BUFFERS.DISPLAY_LINE, "312.5PS\r\n");
    } // end-else-if
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
#endif

// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
    {
        sprintf(BUFFERS.DISPLAY_LINE, "625PS\r\n");
    } // end-if
    else
    {
        sprintf(BUFFERS.DISPLAY_LINE, "312.5PS\r\n");
    } // end-else-if
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
#endif

#ifdef DEVICE_XT200
    switch (INSTRUMENT.stateDEL_CHANNEL)
    {
    case CHANNEL_ONE:
        sprintf(BUFFERS.DISPLAY_LINE, "DEL1\r\n");
        break;
    case CHANNEL_TWO:
        sprintf(BUFFERS.DISPLAY_LINE, "DEL2\r\n");
        break;
        //   case CHANNEL_BOTH:
        //      sprintf(BUFFERS.DISPLAY_LINE, "DEL3\r\n");
        //      break;
    } // end-switch
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
#endif

} // cmdMODEQ

void cmdUNITS(void)
{
    //
    // Description:   Sets default UNITS command to set to NS or PS
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:       stateDEVICE_DISPLAY_NS == TRUE  for NS
    //				 						== FALSE for PS units
    // Notes:         None.
    // ARG1 = UNITS
    // ARG2 = PS | NS

    if ((strcmp(cmdARG2, "NS") == 0) || (strcmp(cmdARG2, "ns") == 0))
    {
        // SET DEVICE TO DISPLAY NS MODE
        INSTRUMENT.stateDEVICE_DISPLAY_NS = TRUE;
#if defined(TFT_ATTACHED)
        TFT_DrawCHX_Units(1, FALSE);
#if defined(DEVICE_XT200)
        TFT_DrawCHX_Units(2, FALSE);
#endif
#endif
    }
    if ((strcmp(cmdARG2, "PS") == 0) || (strcmp(cmdARG2, "ps") == 0))
    {
        // SET DEVICE TO DISPLAY PS MODE
        INSTRUMENT.stateDEVICE_DISPLAY_NS = FALSE;
#if defined(TFT_ATTACHED)
        TFT_DrawCHX_Units(1, TRUE);
#if defined(DEVICE_XT200)
        TFT_DrawCHX_Units(2, TRUE);
#endif
#endif
    }
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // cmdUNITS

void cmdUNITSQ(void)
{
    // Description:	Returns the state of the default UNITS when entering numeric values
    //				without using the DEL command
    // Args:        None.
    // Returns:
    // Prereq:		None.
    // Globals:     stateDEVICE_DISPLAY_NS == TRUE  for NS
    //									== FALSE for PS units
    // Notes:		None.
    //

    if (INSTRUMENT.stateDEVICE_DISPLAY_NS == TRUE)
    {
        sprintf(BUFFERS.DISPLAY_LINE, "NS\r\n");
    }
    else
    {
        sprintf(BUFFERS.DISPLAY_LINE, "PS\r\n");
    }
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // cmdUNITSQ

void cmdMOTOR_RS(void)
{
    /*------------------------------------------------------------------------------
    Description	: 	Sends Request Status RS command to motor
    Arguments	:
    Returns		:  GLOBAL_SETTINGS.REMOTE_LOCAL_MODE = REMOTE or LOCAL
    Prereq		:
    Globals		: 	GLOBAL_SETTINGS.REMOTE_LOCAL_MODE
    Notes		   : 	Returns TRUE (1) or FALSE (0) of g_REMOTE (for LOCAL LOCK-OUT)
// 01.28.21		:  code created
//------------------------------------------------------------------------------*/

#if (defined(DEVICE_XT100) || defined(DEVICE_XT200))
    short int sRMRA;
    char MotorCommand[25];

    strcpy(MotorCommand, Motor_RS);
    INSTRUMENT.stateMOTOR_ResponseACK_TYPE = RS;

    strcat(MotorCommand, "\r");
    serCputs(MotorCommand); // put this out onto the C port 10.18.16

    sRMRA = FALSE;

    // COPIED FROM ABOVE ... NOW GET THE RESPONSE
    while (!sRMRA)
    {
        //
        // Costate Loop to received chars over serial port while processing
        // commands to the Motor.
        // 1. use ReadMOTOR_Response(xx) to send a 2 letter command to motor
        // 2. waitfor(sRMRA); sRMRA = FALSE; to wait for and receive 0% acknowledgement
        // 3. _RAW_MOTOR_RESPONSE_Value has the response ;
        //

        // see if there are any characters from SERIAL C MOTOR RS-485
        CharFromSerialPortC = serCgetc();
        strCharFromSerialPortC[0] = (char)CharFromSerialPortC;
        if (CharFromSerialPortC != 0xFF)
        {                                                // CHAR available on SERIAL PORT C
            stateSERIAL_CHAR_PORTC_IN_INIT_MOTOR = TRUE; // signal char available
        }

        costate
        {
            waitfor(stateSERIAL_CHAR_PORTC_IN_INIT_MOTOR);
            stateSERIAL_CHAR_PORTC_IN_INIT_MOTOR = FALSE;
            if (CharFromSerialPortC == 0x0D)
            {
                stateCOMMAND_LINE_PORTC_ENTER_INIT_MOTOR = TRUE;
            }
            else
            {
                // build the response line string by adding each character
                strcat(strCOMMAND_LINE_PORTC, strCharFromSerialPortC);
            }
        } // end costate

        costate
        {
            waitfor(stateCOMMAND_LINE_PORTC_ENTER_INIT_MOTOR); // \r received
            stateCOMMAND_LINE_PORTC_ENTER_INIT_MOTOR = FALSE;
            MOTOR.RESPONSE_Value = MOTOR_ParseResponse(strCOMMAND_LINE_PORTC);

            strcat(strCOMMAND_LINE_PORTC, "\r");
            strcat(strCOMMAND_LINE_PORTC, "\n");

            // put the results into the BUFFERS.DISPLAY_LINE to display upon return
            sprintf(BUFFERS.DISPLAY_LINE, strCOMMAND_LINE_PORTC);
            // strCOMMAND_LINE_PORTD[] has the response from the MOTOR
            memset(strCOMMAND_LINE_PORTC, 0x00, sizeof(strCOMMAND_LINE_PORTC)); // clear out buffer
            sRMRA = TRUE;                                                       // state READ MOTOR RESPONSE ACKNOWLEDGE 0% HAS BEEN RECEIVED //
        }
    } // end-while

    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = NO_ERROR;
#endif
} // end cmdMOTOR_RS

void cmdNET(void)
{
    // Description:   Handles NET to set network address info IP | GATEWAY | NETMASK | PORT
    //
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.
    //
    // ARG1 = NET
    // ARG2 = IP  | GW | NM | PORT | DHCP
    // ARG3 = ipaddress | port# (0000 thru 9999)
    //

    //#ifdef ETHERNET_ENABLED // implement only if using Ethernet //
    if ((strcmp(cmdARG2, "DHCP") == 0) || (strcmp(cmdARG2, "dhcp") == 0))
    {
        if ((strcmp(cmdARG3, "ON") == 0) || (strcmp(cmdARG3, "on") == 0))
        {
            g_NVParameters.nv_useDHCP = TRUE;
            SYSTEM_SaveNVParametersXT();
        }
        else if ((strcmp(cmdARG3, "OFF") == 0) || (strcmp(cmdARG3, "off") == 0))
        {
            g_NVParameters.nv_useDHCP = FALSE;
            SYSTEM_SaveNVParametersXT();
        }
    } // endif DHCP

    if ((strcmp(cmdARG2, "PORT") == 0) || (strcmp(cmdARG2, "port") == 0))
    {
        if ((strlen(cmdARG3) != 0))
        {
            g_NVParameters.nv_port = atoi(cmdARG3);
            SYSTEM_SaveNVParametersXT();
        }
    } // endif PORT

    if ((strcmp(cmdARG2, "IP") == 0) || (strcmp(cmdARG2, "ip") == 0))
    {
        if ((strlen(cmdARG3) != 0))
        {
            g_NVParameters.nv_ip_addr = inet_addr(cmdARG3);
            SYSTEM_SaveNVParametersXT();
        }
    } // endif IP

    if ((strcmp(cmdARG2, "NM") == 0) || (strcmp(cmdARG2, "nm") == 0))
    {
        if ((strlen(cmdARG3) != 0))
        {
            g_NVParameters.nv_netmask = inet_addr(cmdARG3);
            SYSTEM_SaveNVParametersXT();
        }
    } // endif IP

    if ((strcmp(cmdARG2, "GW") == 0) || (strcmp(cmdARG2, "gw") == 0))
    {
        if ((strlen(cmdARG3) != 0))
        {
            g_NVParameters.nv_gateway = inet_addr(cmdARG3);
            SYSTEM_SaveNVParametersXT();
        }
    } // endif IP

    /*   // 03.06.08 add command to set autodrop ethernet connections true or false
   if ((strcmp(cmdARG2,"AD") == 0) || (strcmp(cmdARG2,"ad") == 0)) {
      if ((strlen(cmdARG3) != 0)) {
         g_NVParameters.nv_autodrop = atoi(cmdARG3); 	// added 03.16.15
         SYSTEM_SaveNVParametersXT();                          // added 03.16.15
         ENET_AutoDropOldConnections (atoi(cmdARG3));
         }
   } //endif IP
*/
    // 09.20.17 add Autodrop capability and save to nvram
    // 03.06.08	add command to set autodrop ethernet connections true or false
    // 05.22.18 SAVE into NVRAM
    if ((strcmp(cmdARG2, "AD") == 0) || (strcmp(cmdARG2, "ad") == 0))
    {
        if ((strlen(cmdARG3) != 0))
        {

            // 10.28.08 add ON or OFF to specify AUTODROP in ARG3
            if ((strcmp(cmdARG3, "ON") == 0) || (strcmp(cmdARG2, "on") == 0))
            {
                // bug fix 05.22.18 SAVE into NVRAM
                g_NVParameters.nv_autodrop = TRUE; // TRUE
                SYSTEM_SaveNVParametersXT();       // 05.22.18
                ENET_AutoDropOldConnections(atoi("1"));
            }
            else if ((strcmp(cmdARG3, "OFF") == 0) || (strcmp(cmdARG2, "off") == 0))
            {
                // bug fix 05.22.18 SAVE into NVRAM
                g_NVParameters.nv_autodrop = FALSE; // TRUE
                SYSTEM_SaveNVParametersXT();        // 05.22.18
                ENET_AutoDropOldConnections(atoi("0"));
            }
            else
            {
                // bug fix 05.22.18 SAVE into NVRAM
                g_NVParameters.nv_autodrop = FALSE; // TRUE
                SYSTEM_SaveNVParametersXT();        // 05.22.18
                ENET_AutoDropOldConnections(atoi(cmdARG3));
            }
        }
    } // end-if AD
    SYSTEM_SaveNVParametersXT();

#ifdef DHCP_SEND_HOSTNAME
    // 01.24.21 added NET HOSTNAME XXX
    if ((strcmp(cmdARG2, "HOSTNAME") == 0) || (strcmp(cmdARG2, "hostname") == 0))
    {
        if ((strlen(cmdARG3) != 0) && (strlen(cmdARG3) <= 15))
        {
            strcpy(g_NVParameters.nv_hostname, cmdARG3);
            SYSTEM_SaveNVParametersXT();
            strcpy(g_DynamicMemHostName, g_NVParameters.nv_hostname);
            g_RetCode = sethostname(g_DynamicMemHostName); // 01.20.21
            sprintf(BUFFERS.DISPLAY_LINE, "Setting DHCP HostName to %s and re-initilizing network.\r\n", g_RetCode);
            SYSTEM_OutputQueryResponse();
            INSTRUMENT.stateERROR_CODE = NO_ERROR;
            INSTRUMENT.stateERROR = FALSE;
        }
        else
        {
            INSTRUMENT.stateERROR_CODE = INVALID_ARG;
            INSTRUMENT.stateERROR = TRUE;
            return; // UNABLE TO SET HOST NAME SO JUST RETURN
        }
    } // end-if HOSTNAME

    // 01.24.21 added NET RELEASE
    if ((strcmp(cmdARG2, "RELEASE") == 0) || (strcmp(cmdARG2, "release") == 0))
    {
        dhcp_release(); // release the current lease
        return;         // JUST RELEASE THE CURRENT LEASE AND RETURN ...
    }                   // end-if RELEASE

#endif

    // 04.22.05 ONCE THE NEW PARAMETERS ARE ACCEPTED, MAKE THEM ACTIVE!!
    ENET_Reconfigure(g_NVParameters.nv_useDHCP,
                     g_NVParameters.nv_ip_addr,
                     g_NVParameters.nv_netmask,
                     g_NVParameters.nv_gateway);

} // cmdMODE

void cmdNETSTATEQ(void)
{
    //
    // Description:   Returns the status of the Network Status LED (TRUE OR FALSE)
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", INSTRUMENT_SETTINGS.CURRENT_LAN_LED_STATUS);
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME

} // end cmdNETSTATEQ

void cmdNETQ(void)
{
    // Description:   Returns the state of the NET (ip address, DHCP on or off, gateway address and netmask)
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    long IP_ADDRESS;
    long GW_ADDRESS;
    long NM_ADDRESS;
    unsigned int PORT_ADDRESS;
    char AD_STATUS; // 03.16.15 add AD support

    char IP_BUFFER[20];
    char GW_BUFFER[20];
    char NM_BUFFER[20];

#ifdef DHCP_SEND_HOSTNAME
    char _Answer[51];
    char AD_BUFFER[5]; // 10.28.08
#endif

    // 08.10.22 add # of sessions connected, listening, or closed
    int _SessionsConnected;
    int _SessionsListening;
    int _SessionsClosed;
    int _Counter;

    IP_ADDRESS = ENET_GetIP(); // GET THE ACTUAL IP ADDRESS

    // 11.11.21 BUILD2112_RD102121_RD111121
    // 11.11.21 GW_ADDRESS = g_NVParameters.nv_gateway;
    // 11.11.21 BUG FIX - RETURN CURRENT GATEWAY ADDRESS (NOT NVRAM SETTINGS)
    GW_ADDRESS = ENET_GetGateway(); // 11.13.21 GET THE ACTUAL GATEWAY ADDRESS

    // 11.11.21 BUG FIX - RETURN CURRENT NETMASK (NOT NVRAM SETTINGS)
    // 11.11.21 NM_ADDRESS = g_NVParameters.nv_netmask;
    NM_ADDRESS = ENET_GetNetmask(); // 11.13.21 GET THE ACTUAL NETMASK

    PORT_ADDRESS = g_NVParameters.nv_port;
    AD_STATUS = (char)g_NVParameters.nv_autodrop; // 03.16.15 add AD support

    // 08.10.22 SESSIONS INFORMATION SC=CLOSE, SO=OPEN-CONNECTED, SL=LISTENING
    _SessionsConnected = _SessionsClosed = _SessionsListening = 0;
    for (_Counter = 0; _Counter < ENET_MAX_CONNECTIONS; _Counter++)
    {
        switch (g_ENETsessions[_Counter].session_state)
        {
        case ENET_SESSION_STATE_CLOSED:
        case ENET_SESSION_STATE_CLOSING:
            _SessionsClosed++;
            break;
        case ENET_SESSION_STATE_CONNECTED:
            _SessionsConnected++;
            break;
        case ENET_SESSION_STATE_LISTENING:
            _SessionsListening++;
            break;
        }
    }

#ifndef DHCP_SEND_HOSTNAME
    if (g_NVParameters.nv_useDHCP == TRUE)
    {
        //        sprintf(BUFFERS.DISPLAY_LINE, "IP=%s,NM=%s,GW=%s,PORT=%d,DHCP=ON,AD=%d\r\n",
        //                inet_ntoa(IP_BUFFER, IP_ADDRESS), inet_ntoa(NM_BUFFER, NM_ADDRESS), inet_ntoa(GW_BUFFER, GW_ADDRESS),
        //                PORT_ADDRESS, AD_STATUS); // 03.16.15 add AD support
        // 08.10.22 ADD SESSIONS INFO
        sprintf(BUFFERS.DISPLAY_LINE, "IP=%s,NM=%s,GW=%s,PORT=%d,DHCP=ON,AD=%d,SL=%d,SO=%d,SC=%d\r\n",
                inet_ntoa(IP_BUFFER, IP_ADDRESS), inet_ntoa(NM_BUFFER, NM_ADDRESS), inet_ntoa(GW_BUFFER, GW_ADDRESS),
                PORT_ADDRESS, AD_STATUS, _SessionsListening, _SessionsConnected, _SessionsClosed); // 08.10.22 add _Sessions
    }
    else
    {
        //        sprintf(BUFFERS.DISPLAY_LINE, "IP=%s,NM=%s,GW=%s,PORT=%d,DHCP=OFF,AD=%d\r\n",
        //                inet_ntoa(IP_BUFFER, IP_ADDRESS), inet_ntoa(NM_BUFFER, NM_ADDRESS), inet_ntoa(GW_BUFFER, GW_ADDRESS),
        //                PORT_ADDRESS, AD_STATUS); // 03.16.15 add AD support
        // 08.10.22 ADD SESSIONS INFO
        sprintf(BUFFERS.DISPLAY_LINE, "IP=%s,NM=%s,GW=%s,PORT=%d,DHCP=OFF,AD=%d,SL=%d,SO=%d,SC=%d\r\n",
                inet_ntoa(IP_BUFFER, IP_ADDRESS), inet_ntoa(NM_BUFFER, NM_ADDRESS), inet_ntoa(GW_BUFFER, GW_ADDRESS),
                PORT_ADDRESS, AD_STATUS, _SessionsListening, _SessionsConnected, _SessionsClosed); // 08.10.22 add _Sessions
    }
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
#endif

#ifdef DHCP_SEND_HOSTNAME

    if (g_NVParameters.nv_autodrop == TRUE)
    {
        sprintf(AD_BUFFER, "ON \0");
    }
    else
    {
        sprintf(AD_BUFFER, "OFF\0");
    }

    if (strlen(cmdARG2) == 0)
    {
        if (g_NVParameters.nv_useDHCP == TRUE)
        {
            //            sprintf(BUFFERS.DISPLAY_LINE, "IP=%s,NM=%s,GW=%s,PORT=%d,DHCP=ON,AD=%s\r\n",
            //                    inet_ntoa(IP_BUFFER, IP_ADDRESS), inet_ntoa(NM_BUFFER, NM_ADDRESS), inet_ntoa(GW_BUFFER, GW_ADDRESS),
            //                    PORT_ADDRESS, AD_BUFFER);
            // 08.10.22 ADD SESSIONS INFO
            sprintf(BUFFERS.DISPLAY_LINE, "IP=%s,NM=%s,GW=%s,PORT=%d,DHCP=ON,AD=%d,SL=%d,SO=%d,SC=%d\r\n",
                    inet_ntoa(IP_BUFFER, IP_ADDRESS), inet_ntoa(NM_BUFFER, NM_ADDRESS), inet_ntoa(GW_BUFFER, GW_ADDRESS),
                    PORT_ADDRESS, AD_STATUS, _SessionsListening, _SessionsConnected, _SessionsClosed); // 08.10.22 add _Sessions
        }
        else
        {
            //            sprintf(BUFFERS.DISPLAY_LINE, "IP=%s,NM=%s,GW=%s,PORT=%d,DHCP=OFF,AD=%s\r\n",
            //                    inet_ntoa(IP_BUFFER, IP_ADDRESS), inet_ntoa(NM_BUFFER, NM_ADDRESS), inet_ntoa(GW_BUFFER, GW_ADDRESS),
            //                    PORT_ADDRESS, AD_BUFFER);
            // 08.10.22 ADD SESSIONS INFO
            sprintf(BUFFERS.DISPLAY_LINE, "IP=%s,NM=%s,GW=%s,PORT=%d,DHCP=OFF,AD=%d,SL=%d,SO=%d,SC=%d\r\n",
                    inet_ntoa(IP_BUFFER, IP_ADDRESS), inet_ntoa(NM_BUFFER, NM_ADDRESS), inet_ntoa(GW_BUFFER, GW_ADDRESS),
                    PORT_ADDRESS, AD_STATUS, _SessionsListening, _SessionsConnected, _SessionsClosed); // 08.10.22 add _Sessions
        }
        SYSTEM_OutputQueryResponse();
        INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
    }
    else
    {
        if ((strcmp(cmdARG2, "HOSTNAME") == 0) || (strcmp(cmdARG2, "hostname") == 0))
        {
            gethostname(_Answer, 50);
            sprintf(BUFFERS.DISPLAY_LINE, "%s\r\n", _Answer);
            SYSTEM_OutputQueryResponse();
            INSTRUMENT.stateERROR_CODE = NO_ERROR;
            INSTRUMENT.stateERROR = FALSE;
        }
        else
        {
            INSTRUMENT.stateERROR_CODE = INVALID_ARG;
            INSTRUMENT.stateERROR = TRUE;
        }
    }
#endif

} // cmdNETQ

void cmdNETMQ(void)
{
    // Description:   Returns the state of the NET (ip address, DHCP on or off, gateway address and netmask)
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    char MAC_ID_buffer[6];

    //#ifdef ETHERNET_ENABLED // implement only if using Ethernet //

    pd_getaddress(0, MAC_ID_buffer);

    sprintf(BUFFERS.DISPLAY_LINE, "MAC_ID=%02X%02X-%02X%02X-%02X%02X\r\n",
            MAC_ID_buffer[0], MAC_ID_buffer[1], MAC_ID_buffer[2], MAC_ID_buffer[3],
            MAC_ID_buffer[4], MAC_ID_buffer[5]);

    SYSTEM_OutputQueryResponse();

    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
                                           //#endif

} // cmdNETMQ

void cmdOVER(void)
{
    //
    // Description:   Sets the OVERSHOOT flag either ON or OFF added 10.04.06
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:       GLOBAL_SETTINGS.userOVERSHOOT == TRUE or FALSE
    // Notes:         None.
    //
    if ((strcmp(cmdARG2, "ON") == 0) || (strcmp(cmdARG2, "on") == 0))
    {
        GLOBAL_SETTINGS.userOVERSHOOT = TRUE;
        g_NVParameters.nv_overshoot = TRUE; // update the setting in NVRAM also
        SYSTEM_SaveNVParametersXT();
    }
    if ((strcmp(cmdARG2, "OFF") == 0) || (strcmp(cmdARG2, "off") == 0))
    {
        // turn OFF overshoot
        GLOBAL_SETTINGS.userOVERSHOOT = FALSE;
        g_NVParameters.nv_overshoot = FALSE; // update the setting in NVRAM also
        SYSTEM_SaveNVParametersXT();
    }
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // cmdOVER

void cmdOVERQ(void)
{
    //
    // Description:   Returns the state of the OVERSHOOT flag (either ON or OFF)
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:       GLOBAL_SETTINGS.userOVERSHOOT == TRUE or FALSE
    // Notes:         None.

    if (GLOBAL_SETTINGS.userOVERSHOOT)
    {
        sprintf(BUFFERS.DISPLAY_LINE, "ON\r\n");
    } // end-if
    else
    {
        sprintf(BUFFERS.DISPLAY_LINE, "OFF\r\n");
    } // end-else-if
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // cmdOVERQ

void cmdOPC(void)
{
    // Description:   Clears the OPERATION CLEAR status bit on GPIB
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         Clears the INSTRUMENT.stateERROR_CODE to NO_ERROR
    //                When receiving the *OPC command, the XT-100 should set the
    //                operation complete bit in the Standard Event Status Register
    //                when all pending operations have finished.  The command
    //				 *OPC will clear the bit to 0 (FALSE).
    //

    INSTRUMENT.stateOPERATION_COMPLETE = FALSE; // CLEAR THIS BIT TO 0
    INSTRUMENT.stateERROR_CODE = NO_ERROR;      // CLEAR THIS OUT FOR NEXT TIME
    INSTRUMENT.stateERROR = FALSE;

} // cmdOPC

void cmdOPCQ(void)
{
    // Description:   Returns the OPERATION COMPLETE status bit for INSTRUMENT
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         Clears the INSTRUMENT.stateERROR_CODE to NO_ERROR
    //                When receiving the *OPC command, XT-100 should set the
    //                operation complete bit in INSTRUMENTS.stateOPERATION_COMPLETE
    //                when all pending operations have finished.
    //                Querying *OPC? will CLEAR the OPC BIT

    char SEC_TROMBONE_COMMAND[10]; // 08.15.22 make this 10

#ifdef DEVICE_XT100
    // THIS COVERS ALL VERSIONS INCLUDING SECONDARY TROMBONE
    sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", INSTRUMENT.stateOPERATION_COMPLETE); //
    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;                                  // CLEAR THE *OPC BIT
    SYSTEM_OutputQueryResponse();
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    // THIS COVERS ALL VERSIONS INCLUDING SECONDARY TROMBONE
    sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", INSTRUMENT.stateOPERATION_COMPLETE); //
    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;                                  // CLEAR THE *OPC BIT
    SYSTEM_OutputQueryResponse();
#endif
#if defined(DEVICE_XR100) || defined(DEVICE_XS100)
    sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", INSTRUMENT.stateOPERATION_COMPLETE); //
    INSTRUMENT.stateOPERATION_COMPLETE = FALSE;                                  // CLEAR THE *OPC BIT
    SYSTEM_OutputQueryResponse();
#endif

#ifdef DEVICE_XT200
    // AS A PRIMARY TROMBONE, DETERMINE IF THE LAST OPERATION WAS FOR DEL CHANNEL 1 OR NOT
#ifdef PRIMARY_TROMBONE
    // SEE IF THE LAST COMMAND A DEL2 COMMAND OPERATION TO
    // IF YES, THEN ALSO DETERMINE WHERE THE *opc? CAME FROM AND RECORD THAT
    // IF NO THEN JUST HANDLE THE *opc? HERE..

    switch (INSTRUMENT.stateLAST_OperationChannelNumber)
    {
    case 1:
        sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", INSTRUMENT.stateOPERATION_COMPLETE); //
        INSTRUMENT.stateOPERATION_COMPLETE = FALSE;                                  // CLEAR THE *OPC BIT
        SYSTEM_OutputQueryResponse();
        break;
    case 2:

#if defined(REMOVE_ORG_CODE)
        // 08.15.22 DO NOT SENT *OPC? TO SECONDARY TROMBONE BECAUSE PORT B INOPERATIVE BECAUSE OF WEB SERVER FLASH
        // YES IT WAS A DEL2 COMMAND SO QUERY THE SEC TROMBONE
        memset(SEC_TROMBONE_COMMAND, 0x00, sizeof(SEC_TROMBONE_COMMAND));
        // sprintf(SEC_TROMBONE_COMMAND, ">*OPC?\r\n");	// 02.14.22 ADD THE '>' CHAR TO PRIMARY COMMAND
        SEC_TROMBONE_COMMAND[0] = '>';
        SEC_TROMBONE_COMMAND[1] = '*';
        SEC_TROMBONE_COMMAND[2] = 'O';
        SEC_TROMBONE_COMMAND[3] = 'P';
        SEC_TROMBONE_COMMAND[4] = 'C';
        SEC_TROMBONE_COMMAND[5] = '?';
        SEC_TROMBONE_COMMAND[6] = '\r';
        SEC_TROMBONE_COMMAND[7] = '\n';
        SEC_TROMBONE_COMMAND[8] = 0;
        // printf(SEC_TROMBONE_COMMAND);
        INSTRUMENT.stateOPC_QueryPending_CH2 = TRUE;
        SYSTEM_OutputSecTrombone(SEC_TROMBONE_COMMAND);
#endif

        // 08.15.22 REPORT OPERATION COMPLETE -- DO NOT QUERY SECONDARY TROMBONE
        sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", INSTRUMENT.stateOPERATION_COMPLETE); //
        INSTRUMENT.stateOPERATION_COMPLETE = FALSE;                                  // CLEAR THE *OPC BIT
        SYSTEM_OutputQueryResponse();

        break;

    default:                                                                         // shouldn't get here but just in case ...
        sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", INSTRUMENT.stateOPERATION_COMPLETE); //
        INSTRUMENT.stateOPERATION_COMPLETE = FALSE;                                  // CLEAR THE *OPC BIT
        SYSTEM_OutputQueryResponse();
        break;
    }
#endif

#endif

    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
    INSTRUMENT.stateERROR = FALSE;
    // return;    // 08.15.22 remove the return
} // cmdOPCQ

void cmdOVS(void)
{
    //
    // Description:   Sets the OVERSHOOT amount into NVRAM
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:       g_NVParameters.nv_overshoot_PS = NEW OVERSHOOT AMOUNT
    // Notes:         None.
    //
    int _InputValue;

    if (strlen(cmdARG2) != 0)
    {

        _InputValue = 0;
        _InputValue = atoi(cmdARG2);

        if ((_InputValue >= 1) && (_InputValue <= 99))
        {
            g_NVParameters.nv_overshoot_PS = _InputValue;
            SYSTEM_SaveNVParametersXT();
            INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
        }
        else
        {
            INSTRUMENT.stateERROR_CODE = INVALID_ARG; // INDICATE ERROR
        }
    }
    else
    {
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // INDICATE ERROR
    }

} // cmdOVS

void cmdOVSQ(void)
{
    //
    // Description:   Returns the amount of the OVERSHOOT from NVRAM
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:       GLOBAL_SETTINGS.userOVERSHOOT == TRUE or FALSE
    // Notes:         None.

    int _OvershootAmount; // in integer ps units

    SYSTEM_LoadNVParametersXT();
    _OvershootAmount = g_NVParameters.nv_overshoot_PS;
    sprintf(BUFFERS.DISPLAY_LINE, "%2d\r\n", _OvershootAmount);
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // cmdOVSQ

void cmdREMOTE(void)
{
    /*------------------------------------------------------------------------------
    Description	:	Set REMOTE LOCKOUT ON OR OFF
    Arguments	:	cmdARG2
    Returns		:	GLOBAL_SETTINGS.REMOTE_LOCAL_MODE = REMOTE or LOCAL
    Prereq		:
    Globals		: 	GLOBAL_SETTINGS.REMOTE_LOCAL_MODE
    Notes		: 	Sets to TRUE (1) or FALSE (0) of g_REMOTE (for LOCAL LOCK-OUT)
// 11.02.10 	: 	CODE VERIFIED
//------------------------------------------------------------------------------*/
    //

    if ((strcmp(cmdARG2, "ON") == 0) || (strcmp(cmdARG2, "1") == 0))
    { // added 09.16.06
        // 11.30.21 SEND THE # SEPARATELY FOR NEW MT-100A VER 2
        SYSTEM_OutputTerminal("#");
        HWIO_msDelay(125);
        sprintf(BUFFERS.DISPLAY_LINE, "REMOTE MODE\tLOCAL LOCK OUT");
        // 11.19.21 DONT SEND THIS OUT IF IN TERMINAL MODE,ONLY IF MT-100A ATTACHED
        if (INSTRUMENT.stateDEVICE_MODE_MT100A == TRUE)
            SYSTEM_OutputTerminal(BUFFERS.DISPLAY_LINE);

        GLOBAL_SETTINGS.REMOTE_LOCAL_MODE = REMOTE;
        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    } // set REMOTE MODE TRUE
    else
    {
        GLOBAL_SETTINGS.REMOTE_LOCAL_MODE = LOCAL;
        SYSTEM_OutputPrompt();
        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    } // end-else-if
} // end cmdREMOTE

void cmdREMQ(void)
{
    /*------------------------------------------------------------------------------
    Description	: 	Handles REMOTE query
    Arguments	:	cmdARG2
    Returns		:  	GLOBAL_SETTINGS.REMOTE_LOCAL_MODE = REMOTE or LOCAL
    Prereq		:
    Globals		: 	GLOBAL_SETTINGS.REMOTE_LOCAL_MODE
    Notes		: 	Returns TRUE (1) or FALSE (0) of g_REMOTE (for LOCAL LOCK-OUT)
// 11.02.10 	: 	CODE VERIFIED
//------------------------------------------------------------------------------*/
    //
    sprintf(BUFFERS.DISPLAY_LINE, "%d\r\n", GLOBAL_SETTINGS.REMOTE_LOCAL_MODE);
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = NO_ERROR;
} // end cmdREMQ

void cmdRELC(void)
{
    // Description:   RELC # of cycles to toggle relays off/on/off
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         Cycles relays off/on/off to improve performance after long period of storage or non-use
    // 08.25.09       added command to cycle relays off/on/off

    int input_value;
    int i;
    int wait, wait_loops;
    int _RelayNumberIndex;
    int _BitPointer;

    if ((strlen(cmdARG2) != 0) && (HW_RELAYS.NUM_OF_SECTIONS != 0)) // ERROR IF NO RELAYS ARE INSTALLED 07.25.21
    {

        input_value = 0;
        input_value = atoi(cmdARG2);

        if ((input_value >= 1) && (input_value <= 1000))
        {

            for (i = 0; i < input_value; i++)
            {

                // Initialize Hardware Relays
                HW_RELAYS.SETTINGS = 0x0000; // hardware Relay Settings

                HWIO_Initialize_RelaysXT();
                HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // turn them all OFF

                for (wait_loops = 0; wait_loops < 1; wait_loops++)
                {
                    for (wait = 0; wait < 25000; wait++) // shorten time to 25K
                    {
                    }
                }

                // ONLY TURN ON ALL THE RELAYS UP TO THE NUMBER THAT ARE INSTALLED

                HW_RELAYS.SETTINGS = 0x0000;
                for (_RelayNumberIndex = HW_RELAYS.NUM_OF_SECTIONS; _RelayNumberIndex >= 1; _RelayNumberIndex--)
                {
                    _BitPointer = 0x0001;
                    _BitPointer = (_BitPointer << _RelayNumberIndex - 1);
                    HW_RELAYS.SETTINGS = HW_RELAYS.SETTINGS | _BitPointer; // LOGICAL OR | SETS THE BIT ON
                }
                // PREVIOUS METHOD OF TURNING ON ALL THE RELAYS
                // HW_RELAYS.SETTINGS = 0xFFFF;           // turn them all ON
                HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // TURN ON ONLY THE INSTALLED RELAYS

                for (wait_loops = 0; wait_loops < 1; wait_loops++)
                {
                    for (wait = 0; wait < 25000; wait++) // shorten time to 25K
                    {
                    }
                }

                HW_RELAYS.SETTINGS = 0x0000;                  // turn them all OFF
                HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // turn them all OFF

            } // end - for

            // AFTER CYCLING THE RELAYS, SET THE DELAY TO 0

            sprintf(cmdARG1, "DEL"); // added 06.24.05
            sprintf(cmdARG2, "0");

            cmdDEL();
            INSTRUMENT.stateMENU_MODE = 0;
            INSTRUMENT.statePARSE = FALSE;

            INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
            INSTRUMENT.stateERROR = FALSE;
            INSTRUMENT.stateERROR_CODE = NO_ERROR;
        }
        else
        {
            INSTRUMENT.stateERROR = TRUE;
            INSTRUMENT.stateERROR_CODE = INVALID_ARG;
        }
    }
    else
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG;
    }
} // cmdRELC

void cmdREL(void)
{
    // Description:  Handles REL or rel command to turn on (00 thru 15) relay on or off
    // Args:       	None.
    // Returns:
    // Prereq:       None.
    // Globals:
    // Notes:        This is a NEW command.  REL is used to turn on or off individual relays.
    // USAGE:        REL X ON | OFF    where X is the relay # according to the layout:
    //             	16 15 14 13 -- 12 11 10 09 -- 08 07 06 05 -- 04 03 02 01 //
    //             	NOTE: Specifying X=0 selects ALL relays to be ON or OFF.
    //

    short relay_number;
    short relay_ON, relay_OFF;
    int hwSET_RELAY;
    float sumDELAY;
    short j;
    int _RelayNumberIndex;
    int _BitPointer;
    float _getTromboneOnlyPortion;

    relay_ON = 0x0001;
    relay_OFF = 0xFFFF;
    hwSET_RELAY = 0x0000;

    relay_number = atoi(cmdARG2);

    if ((relay_number >= 0) && (relay_number <= HW_RELAYS.NUM_OF_SECTIONS))
    {

        if (relay_number == 0)
        {
            // IF SPECIFYING RELAY # 0, THEN ONLY TURN ON ALL THE BITS THAT ARE INSTALLED
            hwSET_RELAY = 0x0000;
            for (_RelayNumberIndex = HW_RELAYS.NUM_OF_SECTIONS; _RelayNumberIndex >= 1; _RelayNumberIndex--)
            {
                _BitPointer = 0x0001;
                _BitPointer = (_BitPointer << _RelayNumberIndex - 1);
                hwSET_RELAY = hwSET_RELAY | _BitPointer; // LOGICAL OR | SETS THE BIT ON
            }
        }
        else
        {
            hwSET_RELAY = (0x0001 << (relay_number - 1));
        }

        // hwSET_RELAY HAS EACH BIT SET TO 1 IF WANTED TO TURN THEM ON OR OFF

        if ((strcmp(cmdARG3, "ON") == 0) || (strcmp(cmdARG3, "on") == 0))
        {

            HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS | hwSET_RELAY); // OR | TURNS ON THE RELAY
            HW_RELAYS.RELAY_ON_OFF[relay_number] = TRUE;
            if (relay_number == 0)
            {
                for (j = 1; j <= HW_RELAYS.NUM_OF_SECTIONS; j++)
                {
                    HW_RELAYS.RELAY_ON_OFF[j] = TRUE; // FOR DISPLAY PURPOSES, REFLECT THE STATE OF THE RELAYS
                }
            }

        } // end-else
        else
        {
            if ((strcmp(cmdARG3, "OFF") == 0) || (strcmp(cmdARG3, "off") == 0))
            {

                hwSET_RELAY = ~hwSET_RELAY;                                 // INVERT THE BITS TO SET
                HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS & hwSET_RELAY); // THEN 'AND' TO TURN OFF RELAY BIT
                HW_RELAYS.RELAY_ON_OFF[relay_number] = FALSE;
                if (relay_number == 0)
                {
                    for (j = 1; j <= HW_RELAYS.NUM_OF_SECTIONS; j++)
                    {
                        HW_RELAYS.RELAY_ON_OFF[j] = FALSE; // FOR DISPLAY PURPOSES, REFLECT THE STATE OF THE RELAYS
                    }
                }
            }
            else
            {
                // INVALID 3rd ARGUMENT -- IGNORED
            } // end-else-if
        }     // end else-if

    } // end-if

    else
    {
        INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
    }                                             // end-else-if

    sumDELAY = 0;
    for (j = 1; j <= HW_RELAYS.NUM_OF_SECTIONS; j++)
    {
        if (HW_RELAYS.RELAY_ON_OFF[j] == TRUE)
        {
            sumDELAY = sumDELAY + HW_RELAYS.RELAY_DELAY_VALUE[j];
        }
    }

    // DEPENDING ON THE DEVICE TYPE, NEED TO DETERMINE THE ACTUAL FINAL DELAY SETTING

#ifdef DEVICE_XR100
    DISPLAY_SETTINGS.CURRENT_DELAY_F = sumDELAY;
    INSTRUMENT_SETTINGS.CURRENT_DELAY = sumDELAY;

// IF ANY ONE SECTION IS ABOVE 65525 PS, THEN HANDLE WITH TEN_X
#ifdef TEN_X
    // MULTIPLY sumDELAY BY 10X hwRELAY_VALUE HAS ONLY 1/10TH OF ACTUAL VALUE
    DISPLAY_SETTINGS.CURRENT_DELAY_F = sumDELAY * 10.0;
    INSTRUMENT_SETTINGS.CURRENT_DELAY = sumDELAY * 10.0;
#endif
// DEVICE_XR100
#endif

#ifdef DEVICE_XT100
    _getTromboneOnlyPortion = fmodf(INSTRUMENT_SETTINGS.CURRENT_DELAY, 625.0);
    // NEED TO ADDIN THE TROMBONE ONLY SECTION TO DETERMINE ACTUAL CURRENT DELAY SETTING
    DISPLAY_SETTINGS.CURRENT_DELAY_F = sumDELAY + _getTromboneOnlyPortion;  // ADD TROMBONE PORTION
    INSTRUMENT_SETTINGS.CURRENT_DELAY = sumDELAY + _getTromboneOnlyPortion; // ADD TROMBONE PORTION
// DEVICE_XT100
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    _getTromboneOnlyPortion = fmodf(INSTRUMENT_SETTINGS.CURRENT_DELAY, 625.0);
    // NEED TO ADDIN THE TROMBONE ONLY SECTION TO DETERMINE ACTUAL CURRENT DELAY SETTING
    DISPLAY_SETTINGS.CURRENT_DELAY_F = sumDELAY + _getTromboneOnlyPortion;  // ADD TROMBONE PORTION
    INSTRUMENT_SETTINGS.CURRENT_DELAY = sumDELAY + _getTromboneOnlyPortion; // ADD TROMBONE PORTION
#endif

} // end cmdREL

// 11.07.21 #ifdef DEVICE_XT100_200N
#ifdef USE_DELAY_UL_TABLE

void cmdREL_UL(void)
{
    // Description: Handles REL or rel command to turn on (00 thru 15) relay on or off
    // Args:       	None.
    // Returns:
    // Prereq:      None.
    // Globals:
    // Notes:       This is a NEW command.  REL is used to turn on or off individual relays.
    // USAGE:       REL X ON | OFF    where X is the relay # according to the layout:
    //             	16 15 14 13 -- 12 11 10 09 -- 08 07 06 05 -- 04 03 02 01 //
    //             	NOTE: Specifying X=0 selects ALL relays to be ON or OFF.
    //

    // 10.22.21 THIS IS FOR DEVICE_XT100_200N ONLY (TESTING FOR OTHER VERSIONS NOW 11.07.21)

    short relay_number;
    short relay_ON, relay_OFF;
    int hwSET_RELAY;
    float sumDELAY;
    short j;
    int _RelayNumberIndex;
    int _BitPointer;
    float _getTromboneOnlyPortion;

    relay_ON = 0x0001;
    relay_OFF = 0xFFFF;
    hwSET_RELAY = 0x0000;

    relay_number = atoi(cmdARG2);

    if ((relay_number >= 0) && (relay_number <= HW_RELAYS.NUM_OF_SECTIONS))
    {

        if (relay_number == 0)
        {
            // IF SPECIFYING RELAY # 0, THEN ONLY TURN ON ALL THE BITS THAT ARE INSTALLED
            hwSET_RELAY = 0x0000;
            for (_RelayNumberIndex = HW_RELAYS.NUM_OF_SECTIONS; _RelayNumberIndex >= 1; _RelayNumberIndex--)
            {
                _BitPointer = 0x0001;
                _BitPointer = (_BitPointer << _RelayNumberIndex - 1);
                hwSET_RELAY = hwSET_RELAY | _BitPointer; // LOGICAL OR | SETS THE BIT ON
            }
        }
        else
        {
#ifdef DEVICE_XT100_200N
            // 11.18.21 FOR THE XT100_200N
            // 11.18.21 LOGICAL 8 (80 NS) MAPS TO PHYSICAL COMBINATION OF RELAY # 8 AND 9
            if (relay_number == 8)
            {
                // SETTING LOGICAL RELAY # 8 (80NS VALUE SETS PHYSICAL RELAYS 8 AND 9)
                hwSET_RELAY = (0x0001 << (8 - 1));  // PHYS 8 == 7
                hwSET_RELAY += (0x0001 << (9 - 1)); // PHYS 9 == 8
            }
            else if (relay_number == 9)
            {
                hwSET_RELAY = (0x0001 << (10 - 1)); // PHYS 10 == 9
            }
            else
            {
                hwSET_RELAY = (0x0001 << (relay_number - 1));
            }
#else
            hwSET_RELAY = (0x0001 << (relay_number - 1));
#endif
        }

        // hwSET_RELAY HAS EACH BIT SET TO 1 IF WANTED TO TURN THEM ON OR OFF

        if ((strcmp(cmdARG3, "ON") == 0) || (strcmp(cmdARG3, "on") == 0))
        {

            HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS | hwSET_RELAY); // OR | TURNS ON THE RELAY
            HW_RELAYS.RELAY_ON_OFF[relay_number] = TRUE;
            if (relay_number == 0)
            {
                for (j = 1; j <= HW_RELAYS.NUM_OF_SECTIONS; j++)
                {
                    HW_RELAYS.RELAY_ON_OFF[j] = TRUE; // FOR DISPLAY PURPOSES, REFLECT THE STATE OF THE RELAYS
                }
            }

        } // end-else
        else
        {
            if ((strcmp(cmdARG3, "OFF") == 0) || (strcmp(cmdARG3, "off") == 0))
            {

                hwSET_RELAY = ~hwSET_RELAY;                                 // INVERT THE BITS TO SET
                HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS & hwSET_RELAY); // THEN 'AND' TO TURN OFF RELAY BIT
                HW_RELAYS.RELAY_ON_OFF[relay_number] = FALSE;
                if (relay_number == 0)
                {
                    for (j = 1; j <= HW_RELAYS.NUM_OF_SECTIONS; j++)
                    {
                        HW_RELAYS.RELAY_ON_OFF[j] = FALSE; // FOR DISPLAY PURPOSES, REFLECT THE STATE OF THE RELAYS
                    }
                }
            }
            else
            {
                // INVALID 3rd ARGUMENT -- IGNORED
            } // end-else-if
        }     // end else-if

    } // end-if

    else
    {
        INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
    }                                             // end-else-if

    sumDELAY = 0;
    for (j = 1; j <= HW_RELAYS.NUM_OF_SECTIONS; j++)
    {
        if (HW_RELAYS.RELAY_ON_OFF[j] == TRUE)
        {
            sumDELAY = sumDELAY + HW_RELAYS.RELAY_DELAY_VALUE[j];
        }
    }

    // DEPENDING ON THE DEVICE TYPE, NEED TO DETERMINE THE ACTUAL FINAL DELAY SETTING

#ifdef DEVICE_XR100
    DISPLAY_SETTINGS.CURRENT_DELAY_F = sumDELAY;
    INSTRUMENT_SETTINGS.CURRENT_DELAY = sumDELAY;

// IF ANY ONE SECTION IS ABOVE 65525 PS, THEN HANDLE WITH TEN_X
#ifdef TEN_X
    // MULTIPLY sumDELAY BY 10X hwRELAY_VALUE HAS ONLY 1/10TH OF ACTUAL VALUE
    DISPLAY_SETTINGS.CURRENT_DELAY_F = sumDELAY * 10.0;
    INSTRUMENT_SETTINGS.CURRENT_DELAY = sumDELAY * 10.0;
#endif
// DEVICE_XR100
#endif

#ifdef DEVICE_XT100
    _getTromboneOnlyPortion = fmodf(INSTRUMENT_SETTINGS.CURRENT_DELAY, 625.0);
    // NEED TO ADDIN THE TROMBONE ONLY SECTION TO DETERMINE ACTUAL CURRENT DELAY SETTING
    DISPLAY_SETTINGS.CURRENT_DELAY_F = sumDELAY + _getTromboneOnlyPortion;  // ADD TROMBONE PORTION
    INSTRUMENT_SETTINGS.CURRENT_DELAY = sumDELAY + _getTromboneOnlyPortion; // ADD TROMBONE PORTION
// DEVICE_XT100
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    _getTromboneOnlyPortion = fmodf(INSTRUMENT_SETTINGS.CURRENT_DELAY, 625.0);
    // NEED TO ADDIN THE TROMBONE ONLY SECTION TO DETERMINE ACTUAL CURRENT DELAY SETTING
    DISPLAY_SETTINGS.CURRENT_DELAY_F = sumDELAY + _getTromboneOnlyPortion;  // ADD TROMBONE PORTION
    INSTRUMENT_SETTINGS.CURRENT_DELAY = sumDELAY + _getTromboneOnlyPortion; // ADD TROMBONE PORTION
#endif

} // end cmdREL_UL
#endif

void cmdRELQ(void)
{
    // Description:   Returns the state of all relays on or off
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    int r[18];
    int i, j;
    unsigned int b;
    unsigned char bit_is;
    char _REL_Answer[17] = "0000000000000000"; // 0 - 15 and #16 is \0 NULL char;
    float _SUM_Relays;                         // 06.22.21 SUM OF ALL THE RELAYS

    for (i = 1; i <= 16; i++) // THIS NUMBER MUST BE 16
    {

        b = 1;
        b = b << (i - 1);
        r[i] = (b & HW_RELAYS.SETTINGS) >> (i - 1);
        // 11.25.21 X SERIES -- UPDATE THE HW_RELAYS.RELAY_ON_OFF TO REFLECT HW_RELAYS.SETTINGS
        // 11.25.21 X SERIES -- HW_RELAYS.RELAY_ON_OFF[i] IS USED TO DETERMINE SUM RELAY VALUES FOR DISPLAY
        if (r[i])
        {
            _REL_Answer[15 - (i - 1)] = '1';
            HW_RELAYS.RELAY_ON_OFF[i] = TRUE;
        }
        else
        {
            _REL_Answer[15 - (i - 1)] = '0';
            HW_RELAYS.RELAY_ON_OFF[i] = FALSE;
        }
    }
    _REL_Answer[16] = '\0'; // MSB is on LEFT and LSB is on far RIGHT
    _SUM_Relays = 0;
    for (j = 1; j <= HW_RELAYS.NUM_OF_SECTIONS; j++)
    {
        if (HW_RELAYS.RELAY_ON_OFF[j] == TRUE)
            _SUM_Relays = _SUM_Relays + HW_RELAYS.RELAY_DELAY_VALUE[j];
    }
#ifdef DEVICE_XR100
    DISPLAY_SETTINGS.CURRENT_DELAY_F = _SUM_Relays; // sum of relays on in PS ... but ONLY FOR XR-100
#endif

    _SUM_Relays = _SUM_Relays / 1000.00; // convert to NS

// 05.23.18 handle TEN_X when any section is above 65535 ps in length
#ifdef TEN_X
#ifdef DEVICE_XR100 // multiply sumDELAY by 10x because of hwRELAY_VALUE array is 1/10th of actual values
    DISPLAY_SETTINGS.CURRENT_DELAY_F = _SUM_Relays * 10.0;
#endif
    _SUM_Relays = _SUM_Relays * 10.0;
#endif

//	sprintf(BUFFERS.DISPLAY_LINE,"RELAYS[16...1] = %s, %9.4f ns\r\n",answer,sumDELAY);
#ifdef DEVICE_XR100
    // FOR XR-100 REPORT THE SUM
    // DEPENDING ON UNITS SETTING OF NS OR PS  07.26.21

    if (INSTRUMENT.stateDEVICE_DISPLAY_NS == TRUE)
    {
        // UNITS ARE NS
        sprintf(BUFFERS.DISPLAY_LINE, "%s,%9.4f NS\r\n", _REL_Answer, _SUM_Relays);
    }
    else
    {
        // UNITS ARE PS
        sprintf(BUFFERS.DISPLAY_LINE, "%s,%9.0f PS\r\n", _REL_Answer, (_SUM_Relays * 1000));
        //
    }

#endif

#ifdef DEVICE_XT100
    // FOR XT-100 DEVICES, REPORT ONLY THE RELAY SETTINGS
    sprintf(BUFFERS.DISPLAY_LINE, "%s\r\n", _REL_Answer);
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    // FOR XT-100 DEVICES, REPORT ONLY THE RELAY SETTINGS
    sprintf(BUFFERS.DISPLAY_LINE, "%s\r\n", _REL_Answer);
#endif

    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // cmdRELQ

void cmdQUERYR_UL(void)
{
    // Description:   Returns the state of all relays on or off
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    int r[18];
    int i, j;
    unsigned int b;
    unsigned char bit_is;
    char _REL_Answer[17] = "0000000000000000"; // 0 - 15 and #16 is \0 NULL char;
    float _SUM_Relays;                         // 06.22.21 SUM OF ALL THE RELAYS

    for (i = 1; i <= 16; i++) // THIS NUMBER MUST BE 16
    {

        // b = 1;
        // b = b << (i - 1);
        //         r[i] = (b & HW_RELAYS.SETTINGS) >> (i - 1);
        //         if (r[i])
        //  10.23.21 BUILD RD102121
        if (HW_RELAYS.RELAY_ON_OFF[i] == ON)
            _REL_Answer[15 - (i - 1)] = '1';
        else
            _REL_Answer[15 - (i - 1)] = '0';
    }
    _REL_Answer[16] = '\0'; // MSB is on LEFT and LSB is on far RIGHT
    _SUM_Relays = 0;
    for (j = 1; j <= HW_RELAYS.NUM_OF_SECTIONS; j++)
    {
        if (HW_RELAYS.RELAY_ON_OFF[j] == TRUE)
            _SUM_Relays = _SUM_Relays + HW_RELAYS.RELAY_UL[j];
    }
#ifdef DEVICE_XR100
    DISPLAY_SETTINGS.CURRENT_DELAY_F = _SUM_Relays; // sum of relays on in PS ... but ONLY FOR XR-100
#endif

    _SUM_Relays = _SUM_Relays / 1000.00; // convert to NS

// 05.23.18 handle TEN_X when any section is above 65535 ps in length
#ifdef TEN_X
#ifdef DEVICE_XR100 // multiply sumDELAY by 10x because of hwRELAY_VALUE array is 1/10th of actual values
    DISPLAY_SETTINGS.CURRENT_DELAY_F = _SUM_Relays * 10.0;
#endif
    _SUM_Relays = _SUM_Relays * 10.0;
#endif

//	sprintf(BUFFERS.DISPLAY_LINE,"RELAYS[16...1] = %s, %9.4f ns\r\n",answer,sumDELAY);
#ifdef DEVICE_XR100
    // FOR XR-100 REPORT THE SUM
    // DEPENDING ON UNITS SETTING OF NS OR PS  07.26.21

    if (INSTRUMENT.stateDEVICE_DISPLAY_NS == TRUE)
    {
        // UNITS ARE NS
        sprintf(BUFFERS.DISPLAY_LINE, "%s,%9.4f NS\r\n", _REL_Answer, _SUM_Relays);
    }
    else
    {
        // UNITS ARE PS
        sprintf(BUFFERS.DISPLAY_LINE, "%s,%9.0f PS\r\n", _REL_Answer, (_SUM_Relays * 1000));
        //
    }

#endif

#ifdef DEVICE_XT100
    // FOR XT-100 DEVICES, REPORT ONLY THE RELAY SETTINGS
    sprintf(BUFFERS.DISPLAY_LINE, "%s\r\n", _REL_Answer);
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    // FOR XT-100 DEVICES, REPORT ONLY THE RELAY SETTINGS
    sprintf(BUFFERS.DISPLAY_LINE, "%s\r\n", _REL_Answer);
#endif

    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // cmdQUERYR_UL

void cmdRST(short int TYPE)
{

    // Description:   Handles *RST command to RESET Instrument
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         Reset the instrument.

#ifdef DEVICE_XT200
// 03.28.18 - if this is a primary trombone, then send the RST command to secondary
#ifdef PRIMARY_TROMBONE                    // 02.14.22 ADD '>' CHAR TO *RST COMMAND FROM PRIMARY TROMBONE
    SYSTEM_OutputSecTrombone(">*RST\r\n"); // 07.07.06 send *RST command to SECONDARY TROMBONE
#endif
#endif

    SYSTEM_OutputTerminal("#"); // CLEAR THE LCD DISPLAY AND TURN ON THE BACKLIGHT?

#ifdef DEVICE_XT100
    SYSTEM_OutputTerminal("  XT-100 SERIES ");
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS\r\n");
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    SYSTEM_OutputTerminal("  XT-100 SERIES ");
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS\r\n");
#endif

#ifdef DEVICE_XR100
    SYSTEM_OutputTerminal("  XR-100 SERIES ");
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS\r\n");
#endif

#ifdef DEVICE_XT200
    SYSTEM_OutputTerminal("  XT-200 SERIES ");
    SYSTEM_OutputTerminal("\tCOLBYINSTRUMENTS\r\n");
#endif

    g_ENET_PORT = g_NVParameters.nv_port; // 1-04-05 addition

    // 05.27.21
    if (INSTRUMENT.stateFACTORY_DEFAULT_PRESSED == TRUE)
    {
        // use HARD DEFAULTS
        // ENET_Init(FALSE,aton("192.168.0.8"),aton("255.255.255.0"),aton("192.168.0.1"));
        // 04.26.2021 // SHOULD THIS BE 0.8 OR 0.10 ?? // 05.27.21
        ENET_Reconfigure(FALSE, aton("192.168.100.10"), aton("255.255.0.0"), aton("192.168.100.1"));
    }
    else
    {
        if (g_NVParameters.nv_useDHCP == TRUE)
        {
            // ENET_Init(TRUE,GLOBAL_SETTINGS.g_NVParameters.nv_ip_addr,GLOBAL_SETTINGS.g_NVParameters.nv_netmask,GLOBAL_SETTINGS.g_NVParameters.nv_gateway);
            ENET_Reconfigure(TRUE, g_NVParameters.nv_ip_addr, g_NVParameters.nv_netmask, g_NVParameters.nv_gateway);
        }
        else
        {
            // ENET_Init(FALSE,GLOBAL_SETTINGS.g_NVParameters.nv_ip_addr,GLOBAL_SETTINGS.g_NVParameters.nv_netmask,GLOBAL_SETTINGS.g_NVParameters.nv_gateway);
            ENET_Reconfigure(FALSE, g_NVParameters.nv_ip_addr, g_NVParameters.nv_netmask, g_NVParameters.nv_gateway);
        }
    }

// 03.28.18
#ifdef DEVICE_XT100
    sprintf(cmdARG1, "DEL");
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    sprintf(cmdARG1, "DEL");
#endif
#ifdef DEVICE_XR100
    sprintf(cmdARG1, "DEL");
#endif
#ifdef DEVICE_XT200
    // 07.21.08 -- BUG FIX
    INSTRUMENT.stateDEL_CHANNEL = 1; // default is to set channel ONE 01.12.16 (change from ONE)
    sprintf(cmdARG1, "DEL1");
#endif

    sprintf(cmdARG2, "0");
    sprintf(cmdARG3, "PS");
    cmdDEL();

    // reset key variables

    INSTRUMENT_SETTINGS.CURRENT_UNITS = PS; // set default current units (change for diff models?)
    INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE = 0.0;
    DISPLAY_SETTINGS.CURRENT_STEP_SIZE_E = 0.0; // for display purposes
    INSTRUMENT_SETTINGS.CURRENT_DELAY = 0.0;
    DISPLAY_SETTINGS.CURRENT_DELAY_E = 0.0; // SETTINGS.CurrentDelay formatted for display (EXPONENT)
    DISPLAY_SETTINGS.CURRENT_DELAY_F = 0.0; // SETTINGS.CurrentDelay formatted for display (FLOAT)

#ifdef DEVICE_XR100
    INSTRUMENT_SETTINGS.CURRENT_UNITS = NS;
#endif

#ifdef DEVICE_XT100
    INSTRUMENT_SETTINGS.CURRENT_UNITS = NS; // default units is PS except of trombone only model
    if (PARAMETERS.deviceMAX_DELAY_NS <= 0.625)
    {
        INSTRUMENT_SETTINGS.CURRENT_UNITS = PS;
    }
#endif

// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    INSTRUMENT_SETTINGS.CURRENT_UNITS = NS; // default units is PS except of trombone only model
    if (PARAMETERS.deviceMAX_DELAY_NS <= 0.625)
    {
        INSTRUMENT_SETTINGS.CURRENT_UNITS = PS;
    }
#endif
#ifdef DEVICE_XT200
#ifdef PRIMARY_TROMBONE
    INSTRUMENT_SETTINGS.CURRENT_UNITS = PS;
    INSTRUMENT.stateDEVICE_DISPLAY_NS = FALSE;
#endif
#endif

#ifdef SECONDARY_TROMBONE
    INSTRUMENT_SETTINGS.CURRENT_UNITS = PS;
    INSTRUMENT.stateDEVICE_DISPLAY_NS = FALSE;
#endif

    INSTRUMENT.stateDEL_CHANNEL = 1;              // default is to set channel ONE 01.12.16 changed from ONE
    INSTRUMENT.stateMT100A_DISPLAY = CHAN_ONE_PS; // default display state = CHANNEL_ONE and PS units

    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_E = 0;   // default channel one delay
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_E = 0;   // default channel two delay
    INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = 0.0; // default channel one delay
    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = 0.0; // default channel two delay
} // end cmdRST

void cmdSTEP_INC(void)
{

    //
    // STEP INCREMENT
    //

#ifdef DEVICE_XT100
    float NewDelayValue;
    if (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE != 0.0)
    {
        NewDelayValue = 0.0;

        if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
        {
            NewDelayValue = INSTRUMENT_SETTINGS.CURRENT_DELAY + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }
        else
        {
            NewDelayValue = (DISPLAY_SETTINGS.CURRENT_DELAY_F / 2) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }

        if (NewDelayValue >= PARAMETERS.deviceMAX_DELAY_PS)
        {
            NewDelayValue = PARAMETERS.deviceMAX_DELAY_PS;
        } // end-if

        if (NewDelayValue <= PARAMETERS.deviceMAX_DELAY_PS)
        {
            // SET THE DELAY!!!
            sprintf(cmdARG1, "DEL");
            sprintf(cmdARG2, "%9.2f", NewDelayValue);
            cmdDEL();
        } // end-if
    }     // end-if
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    float NewDelayValue;
    if (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE != 0.0)
    {
        NewDelayValue = 0.0;

        if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
        {
            NewDelayValue = INSTRUMENT_SETTINGS.CURRENT_DELAY + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }
        else
        {
            // 10.14.21 FOR DEVICE_XT_312P, HALVE THE STEP_SIZE ALSO
            NewDelayValue = (DISPLAY_SETTINGS.CURRENT_DELAY_F / 2) + (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE); // 10.18.21 NOT DIV 2 ON STEP
        }

        if (NewDelayValue >= PARAMETERS.deviceMAX_DELAY_PS)
        {
            // 10.14.21 FOR DEVICE_XT_312P, HALVE THE deviceMAX_DELAY_PS (== 625ps)
            NewDelayValue = (PARAMETERS.deviceMAX_DELAY_PS / 2);
        } // end-if

        if (NewDelayValue <= PARAMETERS.deviceMAX_DELAY_PS)
        {
            // SET THE DELAY!!!
            sprintf(cmdARG1, "DEL");
            sprintf(cmdARG2, "%9.2f", NewDelayValue);
            cmdDEL();
        } // end-if
    }     // end-if
#endif
#if (defined(DEVICE_XR100) || defined(DEVICE_XS100))
    float NewDelayValue;
    if (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE != 0.0)
    {
        NewDelayValue = 0.0;

        if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
        {
            NewDelayValue = INSTRUMENT_SETTINGS.CURRENT_DELAY + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }
        else
        {
            NewDelayValue = (DISPLAY_SETTINGS.CURRENT_DELAY_F / 2) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }

        if (NewDelayValue >= PARAMETERS.deviceMAX_DELAY_PS)
        {
            NewDelayValue = PARAMETERS.deviceMAX_DELAY_PS;
        } // end-if

        if (NewDelayValue <= PARAMETERS.deviceMAX_DELAY_PS)
        {
            // SET THE DELAY!!!
            sprintf(cmdARG1, "DEL");
            sprintf(cmdARG2, "%9.2f", NewDelayValue);
            cmdDEL();
        } // end-if
    }     // end-if
#endif
#if defined(DEVICE_XT200)

    float NewDelayValue_ONE; // for CHANNEL ONE
    float NewDelayValue_TWO; // for CHANNEL TWO

    if (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE != 0.0)
    {
        NewDelayValue_ONE = 0.0; // initialize variables
        NewDelayValue_TWO = 0.0;
        switch (INSTRUMENT.stateDEVICE_MODE)
        {
        case DEVICE_SERIAL:
            switch (INSTRUMENT.stateDEL_CHANNEL)
            {
            case CHANNEL_ONE: // 04.10.18 replace DISPLAY_SETTINGS with INSTRUMENT_SETTINGS
                NewDelayValue_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
                if (NewDelayValue_ONE >= PARAMETERS.deviceMAX_DELAY_PS)
                {
                    NewDelayValue_ONE = PARAMETERS.deviceMAX_DELAY_PS;
                } // end-if
                break;
            case CHANNEL_TWO:
                NewDelayValue_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
                if (NewDelayValue_TWO >= PARAMETERS.deviceMAX_DELAY_PS)
                {
                    NewDelayValue_TWO = PARAMETERS.deviceMAX_DELAY_PS;
                } // end-if
                break;
            case CHANNEL_BOTH:
                NewDelayValue_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
                if (NewDelayValue_ONE >= PARAMETERS.deviceMAX_DELAY_PS)
                {
                    NewDelayValue_ONE = PARAMETERS.deviceMAX_DELAY_PS;
                } // end-if
                NewDelayValue_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
                if (NewDelayValue_TWO >= PARAMETERS.deviceMAX_DELAY_PS)
                {
                    NewDelayValue_TWO = PARAMETERS.deviceMAX_DELAY_PS;
                } // end-if
                break;
            }      // end-switch stateDEL_CHANNEL
            break; // DEVICE_SERIAL
        case DEVICE_PARALLEL:
            switch (INSTRUMENT.stateDEL_CHANNEL)
            {
            case CHANNEL_ONE:
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                NewDelayValue_ONE = (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#else
                NewDelayValue_ONE = (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS / 2) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#endif
                if (NewDelayValue_ONE >= PARAMETERS.deviceMAX_DELAY_PS)
                {
                    NewDelayValue_ONE = PARAMETERS.deviceMAX_DELAY_PS;
                } // end-if
                break;
            case CHANNEL_TWO:
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                NewDelayValue_TWO = (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#else
                NewDelayValue_TWO = (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS / 2) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#endif
                if (NewDelayValue_TWO >= PARAMETERS.deviceMAX_DELAY_PS)
                {
                    NewDelayValue_TWO = PARAMETERS.deviceMAX_DELAY_PS;
                } // end-if
                break;
            case CHANNEL_BOTH:
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                NewDelayValue_ONE = (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#else
                NewDelayValue_ONE = (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS / 2) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#endif
                if (NewDelayValue_ONE >= PARAMETERS.deviceMAX_DELAY_PS)
                {
                    NewDelayValue_ONE = PARAMETERS.deviceMAX_DELAY_PS;
                } // end-if
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                NewDelayValue_TWO = (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#else
                NewDelayValue_TWO = (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS / 2) + INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#endif
                if (NewDelayValue_TWO >= PARAMETERS.deviceMAX_DELAY_PS)
                {
                    NewDelayValue_TWO = PARAMETERS.deviceMAX_DELAY_PS;
                } // end-if
                break;
            }      // end-switch stateDEL_CHANNEL
            break; // DEVICE_PARALLEL
        }          // end-switch stateDEVICE_MODE

        // SET THE DELAY FOR THE CORRESPONDING CHANNEL
        switch (INSTRUMENT.stateDEL_CHANNEL)
        {
        case CHANNEL_ONE:
            sprintf(cmdARG1, "DEL1");
            sprintf(cmdARG2, "%9.2f", NewDelayValue_ONE);
            cmdDEL_ONE();
            break;
        case CHANNEL_TWO:
            sprintf(cmdARG1, "DEL2");
            sprintf(cmdARG2, "%9.2f", NewDelayValue_TWO);
            cmdDEL_TWO();
            break;
        case CHANNEL_BOTH:
            sprintf(cmdARG1, "DEL1");
            sprintf(cmdARG2, "%9.2f", NewDelayValue_ONE);
            cmdDEL_ONE();
            sprintf(cmdARG1, "DEL2");
            sprintf(cmdARG2, "%9.2f", NewDelayValue_TWO);
            cmdDEL_TWO();
            INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH; // set this back because calling cmdDEL_ONE and cmdDEL_TWO sets it to one or the other
            break;
        } // end-switch stateDEL_CHANNEL
    }     // end-if
#endif
}

void cmdSTEP_DEC(void)
{

    //
    // STEP DECREMENT
    //

#ifdef DEVICE_XT100
    float NewDelayValue;

    // 10.27.21 BUILD RD102721
    long _TEMP_I;
    float _TEMP_F;
    float _TEMP_F2;

    //	_TEMP_I = 0;
    //	_TEMP_F = 0.0;
    //    _TEMP_F2 = 0.0;

    if (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE != 0.0)
    {

        NewDelayValue = 0.0;

        if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
        {
            // 10.27.21 BUILD RD102121
            // CHECK THE DIGITS AFTER THE DECIMAL POINT

            _TEMP_F = INSTRUMENT_SETTINGS.CURRENT_DELAY;
            _TEMP_F2 = INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;

            NewDelayValue = INSTRUMENT_SETTINGS.CURRENT_DELAY - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;

            _TEMP_I = (long)NewDelayValue;

            _TEMP_F = 1000.0 * (NewDelayValue - ((float)_TEMP_I));

            if (_TEMP_F < 350)
            {
                // should be 00
            }
            else if (_TEMP_F < 700)
            {
                // should be 00.50
                NewDelayValue = ((float)_TEMP_I) + 0.500;
            }
            else
            {
                // should be 00 ??
                NewDelayValue = ((float)_TEMP_I) + 1.0;
            }
        }
        else
        {
            NewDelayValue = (DISPLAY_SETTINGS.CURRENT_DELAY_F / 2) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }

        if (NewDelayValue <= 0.0)
        {
            NewDelayValue = 0.0;
        } // end-if

        if (NewDelayValue >= 0.0)
        {
            // determine the device mode then set the delay
            // SET THE DELAY!!!
            sprintf(cmdARG1, "DEL");
            sprintf(cmdARG2, "%9.2f", NewDelayValue);
            cmdDEL();
        } // end-if
    }     // end-if
#endif
// 10.06.21 RD081621 BUILD
#ifdef DEVICE_XT100_312P
    float NewDelayValue;
    if (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE != 0.0)
    {
        NewDelayValue = 0.0;

        if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
        {
            NewDelayValue = INSTRUMENT_SETTINGS.CURRENT_DELAY - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }
        else
        {
            // 10.14.21 FOR DEVICE_XT_312P, HALVE THE STEP_SIZE ALSO
            NewDelayValue = (DISPLAY_SETTINGS.CURRENT_DELAY_F / 2) - (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE); // 10.18.21 NOT DIV 2 ON STEP
        }

        if (NewDelayValue <= 0.0)
        {
            NewDelayValue = 0.0;
        } // end-if

        if (NewDelayValue >= 0.0)
        {
            // determine the device mode then set the delay
            // SET THE DELAY!!!
            sprintf(cmdARG1, "DEL");
            sprintf(cmdARG2, "%9.2f", NewDelayValue);
            cmdDEL();
        } // end-if
    }     // end-if
#endif
#if (defined(DEVICE_XR100) || defined(DEVICE_XS100))
    float NewDelayValue;
    if (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE != 0.0)
    {
        NewDelayValue = 0.0;

        if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
        {
            NewDelayValue = INSTRUMENT_SETTINGS.CURRENT_DELAY - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }
        else
        {
            NewDelayValue = (DISPLAY_SETTINGS.CURRENT_DELAY_F / 2) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
        }

        if (NewDelayValue <= 0.0)
        {
            NewDelayValue = 0.0;
        } // end-if

        if (NewDelayValue >= 0.0)
        {
            // determine the device mode then set the delay
            // SET THE DELAY!!!
            sprintf(cmdARG1, "DEL");
            sprintf(cmdARG2, "%9.2f", NewDelayValue);
            cmdDEL();
        } // end-if
    }     // end-if
#endif

#ifdef DEVICE_XT200
    float NewDelayValue_ONE; // for CHANNEL ONE
    float NewDelayValue_TWO; // for CHANNEL TWO

    if (INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE != 0.0)
    {
        NewDelayValue_ONE = 0.0; // initialize variables
        NewDelayValue_TWO = 0.0;
        switch (INSTRUMENT.stateDEVICE_MODE)
        {
        case DEVICE_SERIAL:
            switch (INSTRUMENT.stateDEL_CHANNEL)
            {
            case CHANNEL_ONE: // 04.10.18 replace DISPLAY_SETTINGS with INSTRUMENT_SETTINGS
                NewDelayValue_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
                if (NewDelayValue_ONE <= 0.0)
                {
                    NewDelayValue_ONE = 0.0;
                } // end-if
                break;
            case CHANNEL_TWO:
                NewDelayValue_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
                if (NewDelayValue_TWO <= 0.0)
                {
                    NewDelayValue_TWO = 0.0;
                } // end-if
                break;
            case CHANNEL_BOTH:
                NewDelayValue_ONE = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
                if (NewDelayValue_ONE <= 0.0)
                {
                    NewDelayValue_ONE = 0.0;
                } // end-if
                NewDelayValue_TWO = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
                if (NewDelayValue_TWO <= 0.0)
                {
                    NewDelayValue_TWO = 0.0;
                } // end-if
                break;
            }      // end-switch stateDEL_CHANNEL
            break; // DEVICE_SERIAL
        case DEVICE_PARALLEL:
            switch (INSTRUMENT.stateDEL_CHANNEL)
            {
            case CHANNEL_ONE:
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                NewDelayValue_ONE = (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#else
                NewDelayValue_ONE = (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS / 2) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#endif
                if (NewDelayValue_ONE <= 0.0)
                {
                    NewDelayValue_ONE = 0.0;
                } // end-if
                break;
            case CHANNEL_TWO:
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                NewDelayValue_TWO = (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#else
                NewDelayValue_TWO = (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS / 2) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#endif
                if (NewDelayValue_TWO <= 0.0)
                {
                    NewDelayValue_TWO = 0.0;
                } // end-if
                break;
            case CHANNEL_BOTH:
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                NewDelayValue_ONE = (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#else
                NewDelayValue_ONE = (INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS / 2) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#endif
                if (NewDelayValue_ONE <= 0.0)
                {
                    NewDelayValue_ONE = 0.0;
                } // end-if
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                NewDelayValue_TWO = (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#else
                NewDelayValue_TWO = (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS / 2) - INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE;
#endif
                if (NewDelayValue_TWO <= 0.0)
                {
                    NewDelayValue_TWO = 0.0;
                } // end-if
                break;
            }      // end-switch stateDEL_CHANNEL
            break; // DEVICE_PARALLEL
        }          // end-switch stateDEVICE_MODE

        // SET THE DELAY FOR THE CORRESPONDING CHANNEL
        switch (INSTRUMENT.stateDEL_CHANNEL)
        {
        case CHANNEL_ONE:
            sprintf(cmdARG1, "DEL1");
            sprintf(cmdARG2, "%9.2f", NewDelayValue_ONE);
            cmdDEL_ONE();
            break;
        case CHANNEL_TWO:
            sprintf(cmdARG1, "DEL2");
            sprintf(cmdARG2, "%9.2f", NewDelayValue_TWO);
            cmdDEL_TWO();
            break;
        case CHANNEL_BOTH:
            sprintf(cmdARG1, "DEL1");
            sprintf(cmdARG2, "%9.2f", NewDelayValue_ONE);
            cmdDEL_ONE();
            sprintf(cmdARG1, "DEL2");
            sprintf(cmdARG2, "%9.2f", NewDelayValue_TWO);
            cmdDEL_TWO();
            INSTRUMENT.stateDEL_CHANNEL = CHANNEL_BOTH; // set this back because calling cmdDEL_ONE and cmdDEL_TWO sets it to one or the other
            break;
        } // end-switch stateDEL_CHANNEL
    }     // end-if
#endif

} // cmdSTEP_DEC

void cmdSTEP(void)
{
    // STEP XX ns | ps
    // sets the step size to XX ns | ps.  step size MUST be positive value.
    // Description:   Handles STEP or step command to handle += and -= keys on microterminal
    //
    // Args:       None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    float Step;
    float AbsStep;

    // printf("STEP COMMAND.\n\r");
    // if (INSTRUMENT.stateCMD_FROM_TERM)
    //    SYSTEM_OutputTerminal("STEP COMMAND.");

    Step = atof(cmdARG2);

    // 06.04.06 delay_setting contains the converted cmdARG2 value
    // e.g. DEL 50 ps ==> delay_setting should contain 50 (units of ps)
    // e.g. DEL 50.0E-12 ==> delay_setting should contain 50 (units of ps)

    // 06.04.06 DETERMINE WHETHER TO HANDLE cmdARG2 as DECIMAL OR SCIENTIFIC NOTATION
    //

    if (((Step > 0.0) && (Step <= 1.0E-06)) || ((Step < 0.0) && (Step >= -1.0E-06)))
    {
        // SCIENTIFIC NOTATION!!
        Step = Step * 1.0E+12;
    }

    if ((strcmp(cmdARG3, "PS") == 0) || (strcmp(cmdARG3, "ps") == 0))
    {
        INSTRUMENT_SETTINGS.CURRENT_UNITS = PS;
    } // end-if
    else
    {
        if ((strcmp(cmdARG3, "NS") == 0) || (strcmp(cmdARG3, "ns") == 0) || (INSTRUMENT_SETTINGS.CURRENT_UNITS == NS))
        {
            Step = Step * 1000; // convert to number of picoseconds
            INSTRUMENT_SETTINGS.CURRENT_UNITS = NS;
        }
    } // end-else-if

    AbsStep = Step;

    if (Step < 0)
        AbsStep = -1.0 * Step; // STEP SIZE IS ONLY POSITIVE VALUE

    //   DO NOT USE
    //   if (AbsStep > deviceMAX_DELAY_PS) {
    if ((((AbsStep - PARAMETERS.deviceMAX_DELAY_PS) * 1000) - 1) > 0)
    { // BUG FIX 11.08.06
        INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE = 0.0;
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
    }
    else
    {

        // 06.21.21 CONSIDER IF TRYING TO SET A STEP SIZE IN XR-100 THAT IS SMALLER THAN MIN STEP SIZE
        // 06.21.21 SHOULD WE MAKE THE STEP SIZE THE SMALLEST STEP THEN ?

        if (AbsStep < (PARAMETERS.deviceSTEP_SIZE_NS * 1000))
        {
            // specified step size is smaller than smallest step size so set it to the smallest step size
            INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE = PARAMETERS.deviceSTEP_SIZE_NS * 1000;
        }
        else
        {
            INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE = AbsStep; // valid ... so set it!!
        }

        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;

        // if cmdSTEP is called from the MICROTERMINAL, then it is a result of hitting the + or the - key
        // then should AUTO-SET to the new delay value
        // added 05.10.05
        //

        if (INSTRUMENT.stateCMD_FROM_TERM)
        {
            if (GLOBAL_SETTINGS.AUTO_SET_PLUS)
            {
                sprintf(cmdARG3, "PS");
                cmdSTEP_INC();
            }
            else
            {
                if (GLOBAL_SETTINGS.AUTO_SET_MINUS)
                {
                    sprintf(cmdARG3, "PS");
                    cmdSTEP_DEC();
                } // end if
            }     // end else //
        }         // end if
    }

} // end cmdSTEP

void cmdSTEPQ(void)
{
    //
    // Description:   Returns the step size in number of picoseconds
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:       stateMODE = DEVICE_PARALLEL | DEVICE_SERIAL
    // Notes:         None.
    //
    DISPLAY_SETTINGS.CURRENT_STEP_SIZE_E = INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE * 1.0E-12;
    sprintf(BUFFERS.DISPLAY_LINE, "%12.4e\r\n", DISPLAY_SETTINGS.CURRENT_STEP_SIZE_E);
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME
} // cmdSTEPQ

void cmdTSTQ(void)
{
    // Description:   Sets all relays ON, then OFF
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         None.

    unsigned int wait_loops, wait;

    INSTRUMENT_SETTINGS.CURRENT_UNITS = PS; // set default current units (change for diff models?)
    INSTRUMENT_SETTINGS.CURRENT_STEP_SIZE = 0.0;
    DISPLAY_SETTINGS.CURRENT_STEP_SIZE_E = 0.0; // for display purposes
    INSTRUMENT_SETTINGS.CURRENT_DELAY = 0.0;
    DISPLAY_SETTINGS.CURRENT_DELAY_E = 0.0; // CurrentDelay formatted for display (EXPONENT)
    DISPLAY_SETTINGS.CURRENT_DELAY_F = 0.0; // CurrentDelay formatted for display (FLOAT)
    // DISPLAY_SETTINGS.CURRENT_GPIB_ADDR = 0;

    // Initialize Hardware Relays
    HW_RELAYS.SETTINGS = 0x0000; // hardware Relay Settings
    HWIO_Initialize_RelaysXT();
    HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // turn them all OFF

    for (wait_loops = 0; wait_loops < 1; wait_loops++)
    {
        for (wait = 0; wait < 5000; wait++) // was 50000 09.24.07
        {
        }
    }

    HW_RELAYS.SETTINGS = 0xFFFF;                  // turn them all ON
    HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // turn them all ON

    for (wait_loops = 0; wait_loops < 1; wait_loops++)
    {
        for (wait = 0; wait < 5000; wait++) // was 50000 09.24.07
        {
        }
    }

    HW_RELAYS.SETTINGS = 0x0000;                  // turn them all OFF
    HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS); // turn them all OFF

    // 04.20.18
    INSTRUMENT.stateERROR_CODE = NO_ERROR;

} // end cmdTSTQ

void cmdCLS(void)
{
    // Description:   Clears the Standard Event Status Register (ESR)
    // Args:          None.
    // Returns:
    // Prereq:        None.
    // Globals:
    // Notes:         Clears the INSTRUMENT.stateERROR_CODE to NO_ERROR

    INSTRUMENT.stateOPERATION_COMPLETE = FALSE; // CLEAR THE OPC BIT TO FALSE
    INSTRUMENT.stateERROR_CODE = NO_ERROR;      // CLEAR THE ERROR CODE IF ANY
    INSTRUMENT.stateERROR = FALSE;

} // cmdCLS

// BUILD RD102121
// 10.23.21
int LOCAL_CheckForDecimalPt(char *_cmdARG)
{
    //
    // evaluates _cmdARG to see if input is a valid numeric entry
    // return 0 if valid else -1 if not
    int _ErrorCodeToReturn;
    int _i;
    char _PeriodFound;

    _ErrorCodeToReturn = -1;
    _i = 0;
    _PeriodFound = FALSE;
    // when using atof(), function returns 0 and errno == 0 even when cmdARG1 is NOT numeric digits
    // therefore need to scan cmdARG1 for non-numeric digits though decimal point "." is OK
    // ensure all input is numeric digits or period
    if (strlen(_cmdARG) != 0)
    {
        for (_i = 0; _i < strlen(_cmdARG); _i++)
        {
            if (_cmdARG[_i] == '.')
            { // 04.19.18 added space
                _PeriodFound = TRUE;
                _ErrorCodeToReturn = _i;
                break;
            } // end-if
            else
            {
                _PeriodFound = FALSE;
                _ErrorCodeToReturn = -1;
            }
        } // end-for
    }     // end-if
    return _ErrorCodeToReturn;
}

void cmdSET_DELAY(void)
{
    //
    // Description:    Handles DEL or del command to set delay value
    // Arguments:      _DelaySetting is value in ps units of the desired delay setting.
    // Returns:        TRUE
    // Pre-req:        None.
    // Globals:        cmdARG1 and cmdARG2
    //                 MOTOR_CurrentStepPosition set to current motor StepPosition
    // Notes:          Determines the amount to move left or right for motor and sets
    // the new motor position by moving it left or right.
    // This section of code takes cmdARG2 which contains the keys/digits entered
    // and determines the VALID delay setting we can set rounded to nearest step size
    //
    // cmdARG2 contains ASCII string of desired delay value
    //
    // delay_setting contains final valid delay setting (in picoseconds).
    // delay_setting is a FLOAT variable e.g. delay_setting = 50; means 50 picoseconds
    // 06.04.06 delay_setting contains the converted cmdARG2 value
    // e.g. DEL 50 ps ==> delay_setting should contain 50 (units of ps)
    // e.g. DEL 50.0E-12 ==> delay_setting should contain 50 (units of ps)
    //
    // HANDLES INPUT FROM MT-100A MICROTERMINAL AND FROM TELNET

    float _DelaySetting_PS; // = 0 ; 10.18.16
    float _DelayRemainder_PS;
    float _Delta;
    float _FemtoSecondsPortion;

    int _CalTableDesiredDelayIndex;
    int _j;

    unsigned int _delay_overflow_int; // if int portion of delay > 65536
    unsigned char _delay_overflow;    // flag there is overflow
    unsigned long _Temp, _Temp2;
    unsigned int _TempUIntPS; // change to UNSIGNED LONG
    unsigned int _TempUIntFS;
    unsigned long _TempULongPS;
    unsigned long _DelaySetting_FS; // 0 to nnnpppfff // units
    unsigned long _TempUL;

    float _OvershootAmount;
    float _MotorMovementDelta_PS;
    float _CalTableEntryOffsetAmount;
    float delay_set_PRI, delay_set_SEC; // 03.28.18 for PDL-200A and CPDL-200A
    long _MotorPositionDIGITAL;
    float _DelaySettingPS_With_Overshoot; // 02.02.21
    float _FinalCP_DelaySetting_PS;
    float _TEMP_f;
    float _CurrentMotorPos_MOD_F;
    float _DesiredMotorPos_MOD_F;
    float _ValueToDisplay_TFT;

#if defined(TFT_ATTACHED)
    int _ProgressBarLow_Position;
    int _ProgressBarHigh_Position;
#endif
    // 10.23.21 BUILD 102121
    // 11.07.21 #ifdef DEVICE_XT100_200N
    // FOR DEVICE_XT100_200N MUST USE UNSIGNED LONG UL TABLE

#ifdef USE_DELAY_UL_TABLE
    int position;
    char _dest[10];
    int _afterDecimalPT_I;
    int _strlenARG2;
    int _numberOfDigits;
    float _DelaySetting_FS_F;
    char *TailPoint;
    float _TEMP_F;
    int _TEMP_PS_I;
    int _TEMP_FS_I;
    float _TEMP_FS_F;
    float _TEMP_PS_F;
    unsigned long _TEMP_UL;
    unsigned long _DelaySetting_NPS_UL; // nnnppp where nnn = ns, ppp = ps
    unsigned long _DelaySetting_FS_UL;  // fff where fff = fs
    unsigned long _DelaySetting_PS_UL;  // ppp where ppp = ps
#endif

// --------------------------------------------------------------------------------------------------------------------
#if (defined(DEVICE_XR100) || defined(DEVICE_XS100))
    float delay_trunc_f;
    float delay_temp;

    unsigned int delay_trunc_i;      // least sig digit
    unsigned int delay_int_only;     // 06.21.21 MUST BE UNSIGNED -- RANGE IS 0 TO 65535 INT
    unsigned int delay_overflow_int; // if int portion of delay >= 65536
    unsigned char delay_overflow;    // flag if there is 1ST OVERFLOW
    unsigned char delay_overflow_2;  // flag if there is 2ND OVERFLOW of additional 65535
    unsigned char delay_overflow_3;  // flag if there is 3RD OVERFLOW of additional 65535

    float delay_answer; // for bug FIX VER 1.06
#endif
    // --------------------------------------------------------------------------------------------------------------------

    // 06.05.06 if the length of cmdARG3 is 4, it could be scientific notation with a space char, therefore combine
    // combine cmdARG2 with cmdARG3

    if (strlen(cmdARG3) == 4)
    {
        strcat(cmdARG2, cmdARG3);
    }

    // cmdARG2 has ASCII delay setting
    // 10.23.21 NOTE: 99999.5 is OK
    // 10.23.21 NOTE: 100000.5 returns 100000
    // 10.23.21 NOTE: ANY VALUE ABOVE 100000.0 TO 199999.5 ROUNDS DOWN
    // 10.23.21 NOTE: FOR DEVICE_XT_200N, NEED TO FIX THIS

    _DelaySetting_PS = atof(cmdARG2);

    if (SYSTEM_CheckNumericOnly(cmdARG2) != 0)
    { // see if delay setting is valid
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
        return;
    }
    else
    {
        _delay_overflow = FALSE;
#ifdef DEVICE_XR100
        delay_overflow_2 = FALSE; // 11.16.10
        delay_overflow_3 = FALSE; // 11.16.10
#endif

        // cmdARG3 if specified contains the units
        if ((strcmp(cmdARG3, "PS") == 0) || (strcmp(cmdARG3, "ps") == 0))
        {
            INSTRUMENT_SETTINGS.CURRENT_UNITS = PS;
        } // end-if
        else
        {
            if ((strcmp(cmdARG3, "NS") == 0) || (strcmp(cmdARG3, "ns") == 0))
            {
                INSTRUMENT_SETTINGS.CURRENT_UNITS = NS;
                _DelaySetting_PS = _DelaySetting_PS * 1000.0;
            } // end-if
        }     // end-else-if
    }         // end if

//  START DEVICE_XT100 --------------------------------------------------------------------------------------------------------
#if defined(DEVICE_XT100)

#if defined(TFT_ATTACHED)
    // 05.24.22 CLEARING OUT THE TEXT FIELD IS NOT NEEDED
    // 05.26.22 DISPLAY THE CURRENT SETTING IN YELLOW BEFORE SETTING DELAY
    _ValueToDisplay_TFT = DISPLAY_SETTINGS.CURRENT_DELAY_F;
    SYSTEM_TFT_DISPLAY_FLOAT_IN_CH_TEXT(_ValueToDisplay_TFT, VIEWPORT_CH1, G_YELLOW);              // DISPLAY OF TEXT
    gcrectangle(CHX_BAR_X_UL - 1, CHX_BAR_Y_UL - 1, CHX_BAR_X_LR + 1, CHX_BAR_Y_LR + 1, G_YELLOW); // DISPLAY THE FRAME OF BAR

    // CLEAR THE PROGRESS BAR
    // 06.03.22 gsetcolorb(G_BLACK);
    // gfillvp(CHX_BAR_X_UL, CHX_BAR_Y_UL, CHX_BAR_X_LR, CHX_BAR_Y_LR, 0x0000);
#endif
// 11.07.21 #ifndef DEVICE_XT100_200N
#if !defined(USE_DELAY_UL_TABLE)

    // 10.23.21 ORIGINAL METHOD
    // 04.20.18 DETERMINE IF MODE IS SERIAL OR PARALLEL. IF PARALLEL, DOUBLE THE INPUT
    // 04.20.18 INORDER TO GET THE RIGHT AMOUNT TO SEND TO THE MOTOR
    // 04.20.18 PARALLEL MODE IS ONLY FOR XT-100 INSTRUMENT ONLY

    // 10.25.21 NOTE: NEED TO REMOVE ANY #ifdef DEVICE_XT100_200N CODE IN THIS #ifndef DEVICE_XT100_200N section ...
    // 10.25.21 NOTE: NEED TO REMOVE ANY #ifdef DEVICE_XT100_200N CODE IN THIS #ifndef DEVICE_XT100_200N section ...
    // 10.25.21 NOTE: NEED TO REMOVE ANY #ifdef DEVICE_XT100_200N CODE IN THIS #ifndef DEVICE_XT100_200N section ...

#if defined(TFT_ATTACHED)
    // 06.03.22 SET THE PROGRESS BAR INDICATOR DIRECTION

    // float PARAMETERS.deviceMAX_DELAY_PS HAS PS NUMBER OF MAX DELAY OF INSTRUMENT

    if (((_DelaySetting_PS)-INSTRUMENT_SETTINGS.CURRENT_DELAY) > 0)
    {
        INSTRUMENT.stateLESS_TO_MORE_DELAY_SETTING = TRUE;
        // INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int) (((INSTRUMENT_SETTINGS.CURRENT_DELAY/625.0) * CHX_BAR_W) + 0.50);
        // INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int) (((_DelaySetting_PS/625.0)* CHX_BAR_W) + 0.50);
        //  USE SCALED VALUES
        INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int)(((INSTRUMENT_SETTINGS.CURRENT_DELAY / PARAMETERS.deviceMAX_DELAY_PS) * CHX_BAR_W) + 0.50);
        INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int)(((_DelaySetting_PS / PARAMETERS.deviceMAX_DELAY_PS) * CHX_BAR_W) + 0.50);
    }
    else
    {
        INSTRUMENT.stateLESS_TO_MORE_DELAY_SETTING = FALSE;
        // INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int) (((_DelaySetting_PS/625.0)* CHX_BAR_W) + 0.50);
        // INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int) (((INSTRUMENT_SETTINGS.CURRENT_DELAY/625.0) * CHX_BAR_W) + 0.50);
        //  USE SCALED VALUES
        INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int)(((_DelaySetting_PS / PARAMETERS.deviceMAX_DELAY_PS) * CHX_BAR_W) + 0.50);
        INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int)(((INSTRUMENT_SETTINGS.CURRENT_DELAY / PARAMETERS.deviceMAX_DELAY_PS) * CHX_BAR_W) + 0.50);
    }

    _ProgressBarLow_Position = INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT;
    _ProgressBarHigh_Position = INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT;
#endif
    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)
    {
        _DelaySetting_PS = _DelaySetting_PS * 2.00;
    }

    // 09.11.18 BUG-FIX - FORGOT TO BRING OVER THIS CODE FROM HW1VER1
    if ((_DelaySetting_PS > 0.0) && (_DelaySetting_PS <= 1.0E-06))
    {
        // SCIENTIFIC NOTATION!!
        _DelaySetting_PS = _DelaySetting_PS * 1.0E+12;
    }
    // 09.11.2018 NOW VERSION 2.01 WITH THIS BUG FIX
    // ORG _TempIntPS = (unsigned int) _DelaySetting_PS;
    // 06.15.18 handle MAX DELAY <= 65.535 and MAX DELAY > 65.535 NS

    // need to use unsigned long for > 65.535 ns because unsigned int has limit of 65535
    _TempULongPS = (unsigned long)(_DelaySetting_PS + 0.01);
    _Delta = _DelaySetting_PS - ((float)_TempULongPS);

    // handle if the last digit is a 9 e.g. xx.yyy9
    if (_Delta < -0.009)
    {
        _DelaySetting_PS = _DelaySetting_PS - 1;
        _Delta = _DelaySetting_PS - ((float)((unsigned long)(_DelaySetting_PS)));
        _TempULongPS = _TempULongPS - 1;
    } // in the case of XXX.99, _Delta is NEGATIVE so make it 0
    else
    {
        if (_Delta < 0)
        {
            _Delta = 0;
        }
    } // end-else

    // 06.05.18 use _TempULongFS instead of _TempUIntFS for delay > 65535
    // get the integer number of FS
    _FemtoSecondsPortion = (_Delta * 1000.0) + 0.10;
    if (_FemtoSecondsPortion < 1)
    {
        _TempUIntFS = 0;
    }
    else
    {
        _TempUIntFS = (unsigned int)_FemtoSecondsPortion;
    }

    // 04.30.18 TRUNCATE
    // 04.30.18 for different size CAL_TABLE
    // 06.01.18 for .50 entry on MT-100A, the value for _TempIntFS is 496
    // 06.01.18 for .25 entry on MT-100A, the value for _TempIntFS is 246
    // 06.01.18 therefore ROUND DOWN from 0 to 250 for ZERO and to 0.500 for all else

    switch (SIZE_CAL_TABLE)
    {
    case 1251:
        if (_TempUIntFS <= 246)
        {                    // was 499 then 496
            _TempUIntFS = 0; // round down to nearest .00 ps
        }
        else
        {
            _TempUIntFS = 500; // round down to nearest .50 ps
        }
        break;
    default:
        break;
    }

    // create the unsigned long integer of FS for total delay
    _DelaySetting_FS = (unsigned long)_TempULongPS;
    _DelaySetting_FS = _DelaySetting_FS * 1000;
    _TempUL = (unsigned long)_TempUIntFS;
    _DelaySetting_FS = _DelaySetting_FS + _TempUL;
    // 04.30.18 set _DelaySetting_PS to the truncated value
    _DelaySetting_PS = ((float)_TempULongPS) + (float)(_TempUIntFS / 1000.0);
    _OvershootAmount = (float)g_NVParameters.nv_overshoot_PS;

    // 02.22.2017 CHANGE CODE BELOW TO USE FEMTOSECONDS RESOLUTION RATHER THAN PICOSECONDS

    // 10.23.21 _DelaySetting_PS is a FLOAT
    // 10.23.21 _DelaySetting_FS is a UNSIGNED LONG

    if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= PARAMETERS.deviceMAX_DELAY_PS))
    {
        INSTRUMENT.stateLAST_OperationChannelNumber = 1;
        // XT-100 : HANDLE 0 TO 625.0 IF ONLY TROMBONE (NO RELAYS)
        if ((((_DelaySetting_FS >= 0) && (_DelaySetting_FS < 625000))) ||
            ((_DelaySetting_FS == 625000) && (((strcmp(INSTRUMENT.deviceOPTION, "000") == 0) ||
                                               (strcmp(INSTRUMENT.deviceOPTION, "OEM") == 0) ||
                                               (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)))))
        {
            if ((g_NVParameters.nv_overshoot == TRUE) && (MOTOR.CurrentDelaySettingPS < _DelaySetting_PS))
            {
                // MOVE TO OVERSHOOT POSITION THEN MOVE TO THE FINAL DESIRED POSITION

                _FinalCP_DelaySetting_PS = _DelaySetting_PS;
                _DelaySettingPS_With_Overshoot = _DelaySetting_PS + _OvershootAmount;

                if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                {
                    // 04.30.18 // use a calibrated correction position
                    // 04.30.18 // determine the index to get the calibration offset
                    // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                    // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps

                    if (SIZE_CAL_TABLE == 1251)
                    {
                        // multiply _DelaySetting_PS by 10 (since calibration table fixes are at each 100 fs)
                        _CalTableDesiredDelayIndex = (int)(_FinalCP_DelaySetting_PS * 2);
                    }
                    else
                    {
                        _CalTableDesiredDelayIndex = 0;
                    }

                    // 02.03.21 IF THE INDEX IS ABOVE 1250 THEN USE 0 AS THE OFFSET
                    if (_CalTableDesiredDelayIndex <= 1250)
                    {
                        // NOTE: THE CALIBRATION TABLE ENTRY OFFSET IS IN FEMTOSECONDS UNITS, E.G. TABLE ENTRY OF -600 SHOULD BE == -0.60 ps
                        // THEREFORE DIVIDE BY 1000.0 TO GET PS UNITS
                        _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);
                    }
                    else
                    {
                        _CalTableEntryOffsetAmount = 0;
                    }

                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    //_MotorPositionDIGITAL = (unsigned long)((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                    _TEMP_f = ((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                    _MotorPositionDIGITAL = (long)_TEMP_f;

                    if (_MotorPositionDIGITAL > MAX_NUMBER_MOTOR_STEPS) // Final Calibrated Position + 8325 STEPS is beyond limit, then adjust amount
                    {
                        _MotorPositionDIGITAL = MAX_NUMBER_MOTOR_STEPS;
                    }
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS + (MOTOR_STEPS_PER_FIVE_PS / MOTOR_STEPS_PER_ONE_PS); // use a min of fix to reflect DESIRED delay setting
                                                                                                                         // printf("OVERSHOOT _MotorPositionDIGITAL, Fcp, Fcp offset = %lu, %6.2f, %6.2f \n", _MotorPositionDIGITAL, _FinalCP_DelaySetting_PS, _CalTableEntryOffsetAmount);
                }
                else
                {
                    // MOTOR_SetDelay(_DelaySetting_PS + _OvershootAmount); // add overshoot amount only (CAL TABLE NOT USED)
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    _MotorPositionDIGITAL = (long)(_DelaySettingPS_With_Overshoot * MOTOR_STEPS_PER_ONE_PS);
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                    // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                    // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                }
            } // end-if

            // MOVE TO FINAL POSITION (AND CHECK FOR CALIBRATION TABLE ON/OFF)
            if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
            {
                // 04.30.18 // USE A CALIBRATED CORRECTION POSITION
                // 04.30.18 // DETERMINE THE INDEX TO GET THE CALIBRATION OFFSET
                // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps
                if (SIZE_CAL_TABLE == 1251)
                {
                    _CalTableDesiredDelayIndex = (int)(_DelaySetting_PS * 2);
                }
                else
                {
                    _CalTableDesiredDelayIndex = 0;
                }

                _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);

                // MOTOR_SetDelay(_DelaySetting_PS - _CalTableEntryOffsetAmount );  // should be MINUS the Offset Amount (not PLUS) 02.03.18
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                _MotorPositionDIGITAL = (long)((_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);
                // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                if (_MotorPositionDIGITAL < 0)
                    _MotorPositionDIGITAL = 0;
                MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                // printf("FINAL _MotorPositionDIGITAL, Fcp, offset  = %lu , %6.2f, %6.2f \n", _MotorPositionDIGITAL, _DelaySetting_PS, _CalTableEntryOffsetAmount);

                // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
            }
            else
            {
                // MOTOR_SetDelay(_DelaySetting_PS);
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS);
                // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                if (_MotorPositionDIGITAL < 0)
                    _MotorPositionDIGITAL = 0;
                MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
            }

            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {
                HWIO_REL_SetRelays_X_SER(0x0000); // TURN OFF ALL THE RELAYS
                for (_j = 1; _j <= HW_RELAYS.NUM_OF_SECTIONS; _j++)
                {
                    HW_RELAYS.RELAY_ON_OFF[_j] = OFF;
                } // end-for
            }     // end-if

        } // bad 06-16-21}		  // end-if

        else
        {
            // XT-100 : WITH RELAYS HANDLE == 625.0 FOR XT-100 WITH RELAYS
            if (_DelaySetting_FS == 625000)
            {
                // INSTRUMENT HAS A TROMBONE PLUS RELAYS SO LET THE RELAY SET 625.0 ps
                // THIS IS A XT-100-0X0 THEREFORE SET 625.00 ps WITH RELAYS
                _DelayRemainder_PS = HWIO_REL_SetupAndSet_X(_DelaySetting_PS); // only the 0.625 relay ON
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE;                   // signal that this is the last movement
                // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT // 02.02.21
                _MotorPositionDIGITAL = 0;
                // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                if (_MotorPositionDIGITAL < 0)
                    _MotorPositionDIGITAL = 0;
                MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                INSTRUMENT_SETTINGS.CURRENT_DELAY = 625.00;
            } // end-if
        }

        // XT-100 : WITH MORE THAN ONE RELAY SECTION
        if (_DelaySetting_FS > 625000)
        {
            // normally cycle through each of the relays if in SERIAL mode
            // but if in PARALLEL mode then can't set delay (out of range)
            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {

                // 10.22.21 BUILD RD102221
                // 11.07.21 #ifdef DEVICE_XT100_200N

#if defined(USE_DELAY_UL_TABLE)
                _DelayRemainder_PS = HWIO_REL_SetupRelaysAndSet_UL(_DelaySetting_PS); // HWIO_RelaySetupRelays DOES turn on the last section
#else

                // Cycle through each of the relay sections from 16 to 1 and
                // determine which relays to turn ON by calling HWIO_RelaySetupRelays
                // check desired delay value
                // if desired delay is less than the sum of all the relays (except for last one) then use relaySetupRelaysX
                // else if desired delay requires turning on the last relay;then use HWIO_RelaySetupRelays to turn it ON!!
                _Temp = (unsigned long)_DelaySetting_PS;
                _Temp2 = (unsigned long)PARAMETERS.deviceMAX_DELAY_PS;
                if ((_Temp > GLOBAL_SETTINGS.SUM_RELAYS_LESS_1) || (_Temp == _Temp2))
                {
                    _DelayRemainder_PS = HWIO_REL_SetupAndSet_X(_DelaySetting_PS); // successive subtraction but handle the last section differently
                }                                                                  // relaySetupRelaysX does NOT turn on the last section
                else
                {
                    // turn on the last relay
                    _DelayRemainder_PS = HWIO_REL_SetupRelaysAndSet(_DelaySetting_PS); // HWIO_RelaySetupRelays DOES turn on the last section
                }                                                                      // end-else //turn ON the last section because desired delay is high enough
#endif

                // ----
                // 10.06.21 HOT FIX TO HANDLE OVERSHOOT ON DELAY SETTINGS WITH RELAYS
                // _DelayRemainder_PS HAS THE REMAINDER AMOUNT FOR THE TROMBONE TO MOVE TO
                // ORG if ((g_NVParameters.nv_overshoot == TRUE) && (MOTOR.CurrentDelaySettingPS < _DelaySetting_PS))

                // DETERMINE IF OVERSHOOT IS REQUIRED BY COMPARING CURRENT TROMBONE POSITION AND ONLY IF DESIRED TROMBONE POSITION IS HIGHER (MORE DELAY)
                _CurrentMotorPos_MOD_F = computeMOD_F(MOTOR.CurrentDelaySettingPS); // 10.26.21 HOT FIX TO _F
                _DesiredMotorPos_MOD_F = computeMOD_F(_DelaySetting_PS);            // 10.26.21 HOT FIX TO _F

                // 10.26.21 HOT FIX ... HANDLE MAX DELAY SETTING FOR TROMBONE TO FULL ON
                if (_DelaySetting_PS == PARAMETERS.deviceMAX_DELAY_PS)

// 10.22.21
// ORG _DesiredMotorPos_MOD = computeMOD((long) _DelaySetting_PS);
// BUILD RD102121
// 10.22.21
// IF THE DESIRED DELAY == 200 NS, THEN REMAINDER IS 625 PS
// 11.07.21 #ifdef DEVICE_XT100_200N
#if defined(USE_DELAY_UL_TABLE)
                    if (_DelayRemainder_PS == 625)
                    {
                        _DesiredMotorPos_MOD = (long)_DelayRemainder_PS;
                    }
                    else
                    {
                        _DesiredMotorPos_MOD = computeMOD((long)_DelaySetting_PS);
                    }
#else
                    _DesiredMotorPos_MOD_F = computeMOD_F(_DelaySetting_PS);
#endif
                // 11.11.21 BUILD_RD102121
                // 11.11.21 DETECT THE EDGE CASE WHERE THE REMAINDER IS 625 AND THE POSITION MODULO IS ALSO 0
                // 11.11.21 THEREFORE CHANGE THE MOTOR MODULO POSITION TO 625
                if (_DelayRemainder_PS == 625)
                {
                    _DesiredMotorPos_MOD_F = 625;
                }
                // 10.21.21 MOVE TO OVERSHOOT POSITION IF OVERSHOOT IS ON // 10.26.21 change to _CurrentMotorPos_MOD_F
                if ((g_NVParameters.nv_overshoot == TRUE) && (_CurrentMotorPos_MOD_F < _DesiredMotorPos_MOD_F)) // 10.21.21 CHANGE TO < FROM <=
                {
                    // MOVE TO OVERSHOOT POSITION THEN MOVE TO THE FINAL DESIRED POSITION
                    // 10.06.21 HOT FIX
                    // ORG _FinalCP_DelaySetting_PS = _DelaySetting_PS;
                    // ORG _DelaySettingPS_With_Overshoot = _DelaySetting_PS + _OvershootAmount;
                    // Replace _DelaySetting_PS with _DelayRemainder_PS
                    _FinalCP_DelaySetting_PS = _DelayRemainder_PS;
                    _DelaySettingPS_With_Overshoot = _DelayRemainder_PS + _OvershootAmount;

                    if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                    {
                        // 04.30.18 // USE A CALIBRATED CORRECTION POSITION
                        // 04.30.18 // DETERMINE THE INDEX TO GET THE CALIBRATION OFFSET
                        // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                        // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps
                        if (SIZE_CAL_TABLE == 1251)
                        {
                            // multiply _DelaySetting_PS by 10 (since calibration table fixes are at each 100 fs)
                            _CalTableDesiredDelayIndex = (int)(_FinalCP_DelaySetting_PS * 2);
                        }
                        else
                        {
                            _CalTableDesiredDelayIndex = 0;
                        }

                        // 02.03.21 IF THE INDEX IS ABOVE 1250 THEN USE 0 AS THE OFFSET
                        if (_CalTableDesiredDelayIndex <= 1250)
                        {
                            // NOTE: THE CALIBRATION TABLE ENTRY OFFSET IS IN FEMTOSECONDS UNITS, E.G. TABLE ENTRY OF -600 SHOULD BE == -0.60 ps
                            // THEREFORE DIVIDE BY 1000.0 TO GET PS UNITS
                            _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);
                        }
                        else
                        {
                            _CalTableEntryOffsetAmount = 0;
                        }

                        // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                        //_MotorPositionDIGITAL = (unsigned long)((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                        _TEMP_f = ((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                        _MotorPositionDIGITAL = (long)_TEMP_f;

                        if (_MotorPositionDIGITAL > MAX_NUMBER_MOTOR_STEPS) // Final Calibrated Position + 8325 STEPS is beyond limit, then adjust amount
                        {
                            _MotorPositionDIGITAL = MAX_NUMBER_MOTOR_STEPS;
                        }
                        // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                        if (_MotorPositionDIGITAL < 0)
                            _MotorPositionDIGITAL = 0;
                        MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                        MOTOR.CurrentDelaySettingPS = _DelaySetting_PS + (MOTOR_STEPS_PER_FIVE_PS / MOTOR_STEPS_PER_ONE_PS); // use a min of fix to reflect DESIRED delay setting
                        // printf("OVERSHOOT _MotorPositionDIGITAL, Fcp, Fcp offset = %lu, %6.2f, %6.2f \n", _MotorPositionDIGITAL, _FinalCP_DelaySetting_PS, _CalTableEntryOffsetAmount);
                    }
                    else
                    {
                        // MOTOR_SetDelay(_DelaySetting_PS + _OvershootAmount); // add overshoot amount only (CAL TABLE NOT USED)
                        // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                        _MotorPositionDIGITAL = (long)(_DelaySettingPS_With_Overshoot * MOTOR_STEPS_PER_ONE_PS);
                        // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                        if (_MotorPositionDIGITAL < 0)
                            _MotorPositionDIGITAL = 0;
                        MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                        // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                        // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                        MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                    }
                } // end-if

                // 10.21.21 OVERSHOOT MOVE IS COMPLETED (IF OVERSHOOT WAS ON)
                // 10.21.21 MOVE TO FINAL POSITION (AND CHECK FOR CALIBRATION TABLE ON/OFF)
                if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                {
                    // 04.30.18 // USE A CALIBRATED CORRECTION POSITION
                    // 04.30.18 // DETERMINE THE INDEX TO GET THE CALIBRATION OFFSET
                    // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                    // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps
                    if (SIZE_CAL_TABLE == 1251)
                    {
                        // 10.06.21 HOT FIX
                        // ORG _CalTableDesiredDelayIndex = (int)(_DelaySetting_PS * 2);
                        // Replace _DelaySetting_PS with _DelayRemainder_PS
                        _CalTableDesiredDelayIndex = (int)(_DelayRemainder_PS * 2);
                    }
                    else
                    {
                        _CalTableDesiredDelayIndex = 0;
                    }

                    _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);

                    // MOTOR_SetDelay(_DelaySetting_PS - _CalTableEntryOffsetAmount );  // should be MINUS the Offset Amount (not PLUS) 02.03.18
                    INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    // 10.06.21 HOT FIX
                    // ORG _MotorPositionDIGITAL = (long)((_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);
                    // Replace _DelaySetting_PS with _DelayRemainder_PS
                    _MotorPositionDIGITAL = (long)((_DelayRemainder_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);

                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                    // printf("FINAL _MotorPositionDIGITAL, Fcp, offset  = %lu , %6.2f, %6.2f \n", _MotorPositionDIGITAL, _DelaySetting_PS, _CalTableEntryOffsetAmount);

                    // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                    // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                }
                else
                {
                    // 10.21.21 MOVE TO THE FINAL POSITION WITH CALIBRTION TABLE NOT IN USE
                    INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    // ORG _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS); // 10.21.21 _DesiredMotorPos_MOD
                    // 10.21.21 MOVE TO THE DESIRED POSITION FOR THE REMAINDER PORTION OF THE TROMBONE // 10.26.21 change _DesiredMotorPos_MOD to _F
                    _MotorPositionDIGITAL = (long)(_DesiredMotorPos_MOD_F * MOTOR_STEPS_PER_ONE_PS); // 10.21.21 _DesiredMotorPos_MOD
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // 10.21.21 THIS IS THE FINAL POSITION
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                }
            }
            else
            {
                // in PARALLEL MODE ...
                if (_DelaySetting_PS > 630.0)
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
                }
                else
                {
                    INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // signal that this is the last movement
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT // 02.02.21
                    _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS);
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                } // end-else <= 630.0
            }     // end DEVICE_PARALLEL
        }         // end - if delaysetting > 625000

        DISPLAY_SETTINGS.CURRENT_DELAY_F = _DelaySetting_PS;
        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS;

        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    }
    else
    {
        // delay requested is BEYOND range of this device
        // ignore or set to max ? NO. Don't set at all.
        INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
        INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
    } // end else-if
    // } //end else-if

#else
    // 10.23.21 BUILD RD102121
    // 11.07.21 #ifdef DEVICE_XT100_200N

#if defined(USE_DELAY_UL_TABLE)
    // SCAN FOR "." IS IN cmdARG2
    position = LOCAL_CheckForDecimalPt(cmdARG2);

    _afterDecimalPT_I = 0; // all the digits after the dec pt as a int
    _DelaySetting_FS = 0;
    _DelaySetting_NPS_UL = 0; // nnnppp as UL
    _DelaySetting_FS_UL = 0;  // fff as UL
    _DelaySetting_PS_UL = 0;  // ppp as UL
    _DelaySetting_FS_F = 0.0; // fff as FLOAT

    if (position != -1) // IS THERE A DECIMAL POINT ?
    {
        _strlenARG2 = strlen(cmdARG2); // get length of entire string
        // determine the number of character digits only of input entered
        _numberOfDigits = _strlenARG2 - position - 1;

        // DETERMINE IF NS OR PS MODE
        if (INSTRUMENT_SETTINGS.CURRENT_UNITS == NS)
        { // CURRENT UNITS MODE IS IN NS UNITS
            // 11.16.21 GET ALL THE DIGITS AFTER DECIMAL POINT AS A INTEGER
            if ((_numberOfDigits) <= 3) // 3 OR FEWER CHAR DIGITS
            {
                memset(_dest, '\0', sizeof(_dest));
                strncpy(_dest, &cmdARG2[position + 1], strlen(cmdARG2) - position);
                _afterDecimalPT_I = atoi(_dest); // 11.16.21 CONVERT TO INTEGER
                switch (_numberOfDigits)         // 11.17.21 CORRECT NUMERICAL VALUE
                {
                case 1:
                    _DelaySetting_PS_UL = _afterDecimalPT_I * 100;
                    break;
                case 2:
                    _DelaySetting_PS_UL = _afterDecimalPT_I * 10;
                    break;
                case 3:
                    _DelaySetting_PS_UL = _afterDecimalPT_I;
                    break;
                default:
                    _DelaySetting_PS_UL = _afterDecimalPT_I;
                    break;
                }
                _DelaySetting_FS_UL = 0; // 11.17.21 NO CHARS FOR FS
            }
            else
            {
                // 11.17.21 GET THREE DIGITS OF PPP ONLY FIRST
                memset(_dest, '\0', sizeof(_dest));
                strncpy(_dest, &cmdARG2[position + 1], 3);
                _afterDecimalPT_I = atoi(_dest);         // 11.16.21 CONVERT TO INTEGER
                _DelaySetting_PS_UL = _afterDecimalPT_I; // 11.17.21 FINAL ANSWER PPP

                // 11.17.21 GET REMAINDER OF FFF
                memset(_dest, '\0', sizeof(_dest));
                strncpy(_dest, &cmdARG2[position + 4], (_strlenARG2 - (position + 4)));
                _afterDecimalPT_I = atoi(_dest); // 11.16.21 CONVERT TO INTEGER

                switch (_numberOfDigits - 3) // 11.17.21 CORRECT NUMERICAL VALUE
                {
                case 1:
                    _DelaySetting_FS_UL = _afterDecimalPT_I * 100;
                    break;
                case 2:
                    _DelaySetting_FS_UL = _afterDecimalPT_I * 10;
                    break;
                case 3:
                    _DelaySetting_FS_UL = _afterDecimalPT_I;
                    break;
                default:
                    _DelaySetting_FS_UL = _afterDecimalPT_I;
                    break;
                }
            }

            // ALL THE DIGITS BEFORE DEC PT // ARE NANOSECONDS
            _DelaySetting_NPS_UL = strtol(cmdARG2, &TailPoint, 10);
            _DelaySetting_NPS_UL = _DelaySetting_NPS_UL * 1000;
            _DelaySetting_NPS_UL += _DelaySetting_PS_UL;

            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {
                // ROUND DOWN TO NEAREST HALF PS
                if (_DelaySetting_FS_UL <= 250)
                {
                    _DelaySetting_FS_UL = 0;
                    _DelaySetting_FS_F = 0;
                }
                else
                {
                    _DelaySetting_FS_UL = 500;
                    _DelaySetting_FS_F = 0.500;
                }
            }
            else
            {
                // ROUND DOWN TO NEAREST QUARTER PS
                if (_DelaySetting_FS_UL <= 125)
                {
                    _DelaySetting_FS_UL = 0;
                    _DelaySetting_FS_F = 0;
                }
                else if (_DelaySetting_FS_UL <= 375)
                {
                    _DelaySetting_FS_UL = 250;
                    _DelaySetting_FS_F = 0.250;
                }
                else if (_DelaySetting_FS_UL <= 625)
                {
                    _DelaySetting_FS_UL = 500;
                    _DelaySetting_FS_F = 0.500;
                }
                else
                {
                    _DelaySetting_FS_UL = 750;
                    _DelaySetting_FS_F = 0.750;
                }
            }
        }
        else
        { // CURRENT UNITS MODE IS IN PS UNITS
            // 11.16.21 SINCE ONLY WANT FS VALUE, ONLY NEED UP TO THREE CHAR DIGITS OF NUMBERS
            // 11.17.21 AFTER THE DECIMAL POINT
            if (_numberOfDigits >= 4)
            {
                _numberOfDigits = 3;
            }
            // 11.16.21 GET ALL THE DIGITS AFTER DECIMAL POINT AS A INTEGER
            if ((_numberOfDigits) <= 3)
            {
                memset(_dest, '\0', sizeof(_dest));
                strncpy(_dest, &cmdARG2[position + 1], _numberOfDigits);
                _afterDecimalPT_I = atoi(_dest); // 11.16.21 CONVERT TO INTEGER
                switch (_numberOfDigits)
                {
                case 1:
                    _DelaySetting_FS_UL = _afterDecimalPT_I * 100;
                    _DelaySetting_FS_F = (float)(_DelaySetting_FS_UL / 1000.0);
                    break;
                case 2:
                    _DelaySetting_FS_UL = _afterDecimalPT_I * 10;
                    _DelaySetting_FS_F = (float)(_DelaySetting_FS_UL / 1000.0);
                    break;
                case 3:
                    _DelaySetting_FS_UL = _afterDecimalPT_I;
                    _DelaySetting_FS_F = (float)(_DelaySetting_FS_UL / 1000.0);
                    break;
                }
            }
            // ALL THE DIGITS BEFORE DEC PT // ARE THE PS UNITS
            _DelaySetting_NPS_UL = strtol(cmdARG2, &TailPoint, 10);
        }
    }
    else
    {
        // THERE IS NO DECIMAL POINT SO TAKE ALL CHARS AS THE VALUE
        _DelaySetting_NPS_UL = strtol(cmdARG2, &TailPoint, 10);
        // DETERMINE IF NS OR PS MODE
        if (INSTRUMENT_SETTINGS.CURRENT_UNITS == NS)
        {
            _DelaySetting_NPS_UL = _DelaySetting_NPS_UL * 1000;
        }
    }

#endif

    // PROBLEM IS AS A FLOAT THE VALUE 100000.5 SHOWS UP AS 1e+08
    // CANNOT HAS SIX DIGITS OF VALUE PLUS A DIGIT AFTER THE DECIMAL POINT
    // THEREFORE MUST USE UNSIGNED LONG TO REPRESENT

    // DELAY SETTING IS REPRESENTED AS:
    // _DelaySetting_NPS_UL			NNNPPP
    // _DelaySetting_FS_UL          FFF
    //                              NNNPPP.FFF ps of delay

    _DelaySetting_PS = (float)_DelaySetting_NPS_UL + (float)_DelaySetting_FS_F;

    // 04.20.18 DETERMINE IF MODE IS SERIAL OR PARALLEL. IF PARALLEL, DOUBLE THE INPUT
    // 04.20.18 INORDER TO GET THE RIGHT AMOUNT TO SEND TO THE MOTOR
    // 04.20.18 PARALLEL MODE IS ONLY FOR XT-100 INSTRUMENT ONLY

    // 06.03.22 SET THE PROGRESS BAR INDICATOR DIRECTION
    /// WORK NEEDED HERE TO HANDLE DISPLAY PROGRESS BAR CORRECTLY
    // 06.03.22 SET THE PROGRESS BAR INDICATOR DIRECTION

    // float PARAMETERS.deviceMAX_DELAY_PS HAS PS NUMBER OF MAX DELAY OF INSTRUMENT

    if (((_DelaySetting_PS)-INSTRUMENT_SETTINGS.CURRENT_DELAY) > 0)
    {
        INSTRUMENT.stateLESS_TO_MORE_DELAY_SETTING = TRUE;
        // INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int) (((INSTRUMENT_SETTINGS.CURRENT_DELAY/625.0) * CHX_BAR_W) + 0.50);
        // INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int) (((_DelaySetting_PS/625.0)* CHX_BAR_W) + 0.50);
        //  USE SCALED VALUES
        INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int)(((INSTRUMENT_SETTINGS.CURRENT_DELAY / PARAMETERS.deviceMAX_DELAY_PS) * CHX_BAR_W) + 0.50);
        INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int)(((_DelaySetting_PS / PARAMETERS.deviceMAX_DELAY_PS) * CHX_BAR_W) + 0.50);
    }
    else
    {
        INSTRUMENT.stateLESS_TO_MORE_DELAY_SETTING = FALSE;
        // INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int) (((_DelaySetting_PS/625.0)* CHX_BAR_W) + 0.50);
        // INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int) (((INSTRUMENT_SETTINGS.CURRENT_DELAY/625.0) * CHX_BAR_W) + 0.50);
        //  USE SCALED VALUES
        INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int)(((_DelaySetting_PS / PARAMETERS.deviceMAX_DELAY_PS) * CHX_BAR_W) + 0.50);
        INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int)(((INSTRUMENT_SETTINGS.CURRENT_DELAY / PARAMETERS.deviceMAX_DELAY_PS) * CHX_BAR_W) + 0.50);
    }

    _ProgressBarLow_Position = INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT;
    _ProgressBarHigh_Position = INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT;

    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)
    {
        _DelaySetting_PS = _DelaySetting_PS * 2.00;
    }

    _OvershootAmount = (float)g_NVParameters.nv_overshoot_PS;

    // 02.22.2017 CHANGE CODE BELOW TO USE FEMTOSECONDS RESOLUTION RATHER THAN PICOSECONDS

    // 10.23.21 _DelaySetting_PS is a FLOAT
    // 10.23.21 _DelaySetting_FS is a UNSIGNED LONG
    // 10.23.21 PARAMETERS. ARE ALL FLOATS

    // DELAY SETTING IS REPRESENTED AS:
    // _DelaySetting_NPS_UL			NNNPPP
    // _DelaySetting_FS_UL          FFF
    //                              NNNPPP.FFF ps of delay

    //    if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= PARAMETERS.deviceMAX_DELAY_PS))
    _TEMP_UL = (unsigned long)PARAMETERS.deviceMAX_DELAY_PS;

    if ((_DelaySetting_NPS_UL >= 0) && (_DelaySetting_NPS_UL <= _TEMP_UL))
    {
        INSTRUMENT.stateLAST_OperationChannelNumber = 1;
        // XT-100 : HANDLE 0 TO 625.0 IF ONLY TROMBONE (NO RELAYS)
        //        if ((((_DelaySetting_FS >= 0) && (_DelaySetting_FS < 625000))) ||
        //            ((_DelaySetting_FS == 625000) && (((strcmp(INSTRUMENT.deviceOPTION, "000") == 0) ||
        //                                               (strcmp(INSTRUMENT.deviceOPTION, "OEM") == 0) ||
        //                                               (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)))))

        if (((_DelaySetting_NPS_UL >= 0) && (_DelaySetting_NPS_UL < 625)) ||
            ((_DelaySetting_NPS_UL == 625) && ((strcmp(INSTRUMENT.deviceOPTION, "000") == 0) ||
                                               (strcmp(INSTRUMENT.deviceOPTION, "OEM") == 0) ||
                                               (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)))

        )

        {
            if ((g_NVParameters.nv_overshoot == TRUE) && (MOTOR.CurrentDelaySettingPS < _DelaySetting_PS))
            {
                // MOVE TO OVERSHOOT POSITION THEN MOVE TO THE FINAL DESIRED POSITION

                _FinalCP_DelaySetting_PS = _DelaySetting_PS;
                _DelaySettingPS_With_Overshoot = _DelaySetting_PS + _OvershootAmount;

                if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                {
                    // 04.30.18 // use a calibrated correction position
                    // 04.30.18 // determine the index to get the calibration offset
                    // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                    // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps

                    if (SIZE_CAL_TABLE == 1251)
                    {
                        // multiply _DelaySetting_PS by 10 (since calibration table fixes are at each 100 fs)
                        _CalTableDesiredDelayIndex = (int)(_FinalCP_DelaySetting_PS * 2);
                    }
                    else
                    {
                        _CalTableDesiredDelayIndex = 0;
                    }

                    // 02.03.21 IF THE INDEX IS ABOVE 1250 THEN USE 0 AS THE OFFSET
                    if (_CalTableDesiredDelayIndex <= 1250)
                    {
                        // NOTE: THE CALIBRATION TABLE ENTRY OFFSET IS IN FEMTOSECONDS UNITS, E.G. TABLE ENTRY OF -600 SHOULD BE == -0.60 ps
                        // THEREFORE DIVIDE BY 1000.0 TO GET PS UNITS
                        _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);
                    }
                    else
                    {
                        _CalTableEntryOffsetAmount = 0;
                    }

                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    //_MotorPositionDIGITAL = (unsigned long)((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                    _TEMP_f = ((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                    _MotorPositionDIGITAL = (long)_TEMP_f;

                    if (_MotorPositionDIGITAL > MAX_NUMBER_MOTOR_STEPS) // Final Calibrated Position + 8325 STEPS is beyond limit, then adjust amount
                    {
                        _MotorPositionDIGITAL = MAX_NUMBER_MOTOR_STEPS;
                    }
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS + (MOTOR_STEPS_PER_FIVE_PS / MOTOR_STEPS_PER_ONE_PS); // use a min of fix to reflect DESIRED delay setting
                    // printf("OVERSHOOT _MotorPositionDIGITAL, Fcp, Fcp offset = %lu, %6.2f, %6.2f \n", _MotorPositionDIGITAL, _FinalCP_DelaySetting_PS, _CalTableEntryOffsetAmount);
                }
                else
                {
                    // MOTOR_SetDelay(_DelaySetting_PS + _OvershootAmount); // add overshoot amount only (CAL TABLE NOT USED)
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    _MotorPositionDIGITAL = (long)(_DelaySettingPS_With_Overshoot * MOTOR_STEPS_PER_ONE_PS);
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                    // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                    // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                }
            } // end-if

            // MOVE TO FINAL POSITION (AND CHECK FOR CALIBRATION TABLE ON/OFF)
            if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
            {
                // 04.30.18 // USE A CALIBRATED CORRECTION POSITION
                // 04.30.18 // DETERMINE THE INDEX TO GET THE CALIBRATION OFFSET
                // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps
                if (SIZE_CAL_TABLE == 1251)
                {
                    _CalTableDesiredDelayIndex = (int)(_DelaySetting_PS * 2);
                }
                else
                {
                    _CalTableDesiredDelayIndex = 0;
                }

                _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);

                // MOTOR_SetDelay(_DelaySetting_PS - _CalTableEntryOffsetAmount );  // should be MINUS the Offset Amount (not PLUS) 02.03.18
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                _MotorPositionDIGITAL = (long)((_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);
                // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                if (_MotorPositionDIGITAL < 0)
                    _MotorPositionDIGITAL = 0;
                MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                // printf("FINAL _MotorPositionDIGITAL, Fcp, offset  = %lu , %6.2f, %6.2f \n", _MotorPositionDIGITAL, _DelaySetting_PS, _CalTableEntryOffsetAmount);

                // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
            }
            else
            {
                // MOTOR_SetDelay(_DelaySetting_PS);
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS);
                // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                if (_MotorPositionDIGITAL < 0)
                    _MotorPositionDIGITAL = 0;
                MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
            }

            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {
                HWIO_REL_SetRelays_X_SER(0x0000); // TURN OFF ALL THE RELAYS
                for (_j = 1; _j <= HW_RELAYS.NUM_OF_SECTIONS; _j++)
                {
                    HW_RELAYS.RELAY_ON_OFF[_j] = OFF;
                } // end-for
            }     // end-if

        } // bad 06-16-21}		  // end-if

        else
        {
            // XT-100 : WITH RELAYS HANDLE == 625.0 FOR XT-100 WITH RELAYS
            //            if (_DelaySetting_FS == 625000)
            // 10.25.21 change
            if ((_DelaySetting_NPS_UL == 625) && (_DelaySetting_FS_UL == 000))
            {
                // INSTRUMENT HAS A TROMBONE PLUS RELAYS SO LET THE RELAY SET 625.0 ps
                // THIS IS A XT-100-0X0 THEREFORE SET 625.00 ps WITH RELAYS
                _DelayRemainder_PS = HWIO_REL_SetupAndSet_X(_DelaySetting_PS); // only the 0.625 relay ON
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE;                   // signal that this is the last movement
                // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT // 02.02.21
                _MotorPositionDIGITAL = 0;
                // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                if (_MotorPositionDIGITAL < 0)
                    _MotorPositionDIGITAL = 0;
                MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                INSTRUMENT_SETTINGS.CURRENT_DELAY = 625.00;
            } // end-if
        }

        // XT-100 : WITH MORE THAN ONE RELAY SECTION

        // if (_DelaySetting_FS > 625000)
        // 10.25.21 change
        if (((_DelaySetting_NPS_UL >= 625) && (_DelaySetting_FS_UL > 0)) || (_DelaySetting_NPS_UL > 625))
        {
            // normally cycle through each of the relays if in SERIAL mode
            // but if in PARALLEL mode then can't set delay (out of range)
            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {

// 10.22.21 BUILD RD102221
// 11.07.21 #ifdef DEVICE_XT100_200N
#ifdef USE_DELAY_UL_TABLE

                // 10.25.21 CANNOT SEND _DelaySetting_PS as a float to determine remainder because
                // 10.25.21 100000.50 cannot be represented correctly as a float value, so must call with UL delay values
                // 10.25.21 _DelaySetting_NPS_UL and _DelaySetting_FS_UL
                // 10.25.21 RETURNS: Float with remainder to be handled by trombone (<= 624.50 ps)
                // ORG _DelayRemainder_PS = HWIO_REL_SetupRelaysAndSet_UL(_DelaySetting_PS); //HWIO_RelaySetupRelays DOES turn on the last section
                _DelayRemainder_PS = HWIO_REL_SetupRelaysAndSet_UL(_DelaySetting_PS, _DelaySetting_NPS_UL, _DelaySetting_FS_UL);

#else

                // Cycle through each of the relay sections from 16 to 1 and
                // determine which relays to turn ON by calling HWIO_RelaySetupRelays
                // check desired delay value
                // if desired delay is less than the sum of all the relays (except for last one) then use relaySetupRelaysX
                // else if desired delay requires turning on the last relay;then use HWIO_RelaySetupRelays to turn it ON!!
                _Temp = (unsigned long)_DelaySetting_PS;
                _Temp2 = (unsigned long)PARAMETERS.deviceMAX_DELAY_PS;
                if ((_Temp > GLOBAL_SETTINGS.SUM_RELAYS_LESS_1) || (_Temp == _Temp2))
                {
                    _DelayRemainder_PS = HWIO_REL_SetupAndSet_X(_DelaySetting_PS); // successive subtraction but handle the last section differently
                }                                                                  // relaySetupRelaysX does NOT turn on the last section
                else
                {
                    // turn on the last relay
                    _DelayRemainder_PS = HWIO_REL_SetupRelaysAndSet(_DelaySetting_PS); // HWIO_RelaySetupRelays DOES turn on the last section
                }                                                                      // end-else //turn ON the last section because desired delay is high enough
#endif

                // ----
                // 10.06.21 HOT FIX TO HANDLE OVERSHOOT ON DELAY SETTINGS WITH RELAYS
                // _DelayRemainder_PS HAS THE REMAINDER AMOUNT FOR THE TROMBONE TO MOVE TO
                // ORG if ((g_NVParameters.nv_overshoot == TRUE) && (MOTOR.CurrentDelaySettingPS < _DelaySetting_PS))

                // DETERMINE IF OVERSHOOT IS REQUIRED BY COMPARING CURRENT TROMBONE POSITION AND ONLY IF DESIRED TROMBONE POSITION IS HIGHER (MORE DELAY)
                _CurrentMotorPos_MOD_F = computeMOD_F(MOTOR.CurrentDelaySettingPS); // 10.26.21 HOT FIX TO _F
                _DesiredMotorPos_MOD_F = computeMOD_F(_DelaySetting_PS);            // 10.26.21 HOT FIX TO _F

                // 10.26.21 HOT FIX ... HANDLE MAX DELAY SETTING FOR TROMBONE TO FULL ON
                if (_DelaySetting_PS == PARAMETERS.deviceMAX_DELAY_PS)
                {
                    _DesiredMotorPos_MOD_F = 625.0;
                }

                // BUILD RD102121
                // 10.22.21
                // IF THE DESIRED DELAY == 200 NS, THEN REMAINDER IS 625 PS

                // 10.21.21 MOVE TO OVERSHOOT POSITION IF OVERSHOOT IS ON // 10.26.21 CHANGE TO _F
                if ((g_NVParameters.nv_overshoot == TRUE) && (_CurrentMotorPos_MOD_F < _DesiredMotorPos_MOD_F)) // 10.21.21 CHANGE TO < FROM <=
                {
                    // MOVE TO OVERSHOOT POSITION THEN MOVE TO THE FINAL DESIRED POSITION
                    // 10.06.21 HOT FIX
                    // ORG _FinalCP_DelaySetting_PS = _DelaySetting_PS;
                    // ORG _DelaySettingPS_With_Overshoot = _DelaySetting_PS + _OvershootAmount;
                    // Replace _DelaySetting_PS with _DelayRemainder_PS
                    _FinalCP_DelaySetting_PS = _DelayRemainder_PS;
                    _DelaySettingPS_With_Overshoot = _DelayRemainder_PS + _OvershootAmount;

                    if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                    {
                        // 04.30.18 // USE A CALIBRATED CORRECTION POSITION
                        // 04.30.18 // DETERMINE THE INDEX TO GET THE CALIBRATION OFFSET
                        // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                        // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps
                        if (SIZE_CAL_TABLE == 1251)
                        {
                            // multiply _DelaySetting_PS by 10 (since calibration table fixes are at each 100 fs)
                            _CalTableDesiredDelayIndex = (int)(_FinalCP_DelaySetting_PS * 2);
                        }
                        else
                        {
                            _CalTableDesiredDelayIndex = 0;
                        }

                        // 02.03.21 IF THE INDEX IS ABOVE 1250 THEN USE 0 AS THE OFFSET
                        if (_CalTableDesiredDelayIndex <= 1250)
                        {
                            // NOTE: THE CALIBRATION TABLE ENTRY OFFSET IS IN FEMTOSECONDS UNITS, E.G. TABLE ENTRY OF -600 SHOULD BE == -0.60 ps
                            // THEREFORE DIVIDE BY 1000.0 TO GET PS UNITS
                            _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);
                        }
                        else
                        {
                            _CalTableEntryOffsetAmount = 0;
                        }

                        // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                        //_MotorPositionDIGITAL = (unsigned long)((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                        _TEMP_f = ((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                        _MotorPositionDIGITAL = (long)_TEMP_f;

                        if (_MotorPositionDIGITAL > MAX_NUMBER_MOTOR_STEPS) // Final Calibrated Position + 8325 STEPS is beyond limit, then adjust amount
                        {
                            _MotorPositionDIGITAL = MAX_NUMBER_MOTOR_STEPS;
                        }
                        // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                        if (_MotorPositionDIGITAL < 0)
                            _MotorPositionDIGITAL = 0;
                        MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                        MOTOR.CurrentDelaySettingPS = _DelaySetting_PS + (MOTOR_STEPS_PER_FIVE_PS / MOTOR_STEPS_PER_ONE_PS); // use a min of fix to reflect DESIRED delay setting
                        // printf("OVERSHOOT _MotorPositionDIGITAL, Fcp, Fcp offset = %lu, %6.2f, %6.2f \n", _MotorPositionDIGITAL, _FinalCP_DelaySetting_PS, _CalTableEntryOffsetAmount);
                    }
                    else
                    {
                        // MOTOR_SetDelay(_DelaySetting_PS + _OvershootAmount); // add overshoot amount only (CAL TABLE NOT USED)
                        // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                        _MotorPositionDIGITAL = (long)(_DelaySettingPS_With_Overshoot * MOTOR_STEPS_PER_ONE_PS);
                        // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                        if (_MotorPositionDIGITAL < 0)
                            _MotorPositionDIGITAL = 0;
                        MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                        // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                        // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                        MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                    }
                } // end-if

                // 10.21.21 OVERSHOOT MOVE IS COMPLETED (IF OVERSHOOT WAS ON)
                // 10.21.21 MOVE TO FINAL POSITION (AND CHECK FOR CALIBRATION TABLE ON/OFF)
                if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                {
                    // 04.30.18 // USE A CALIBRATED CORRECTION POSITION
                    // 04.30.18 // DETERMINE THE INDEX TO GET THE CALIBRATION OFFSET
                    // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                    // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps
                    if (SIZE_CAL_TABLE == 1251)
                    {
                        // 10.06.21 HOT FIX
                        // ORG _CalTableDesiredDelayIndex = (int)(_DelaySetting_PS * 2);
                        // Replace _DelaySetting_PS with _DelayRemainder_PS
                        _CalTableDesiredDelayIndex = (int)(_DelayRemainder_PS * 2);
                    }
                    else
                    {
                        _CalTableDesiredDelayIndex = 0;
                    }

                    _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);

                    // MOTOR_SetDelay(_DelaySetting_PS - _CalTableEntryOffsetAmount );  // should be MINUS the Offset Amount (not PLUS) 02.03.18
                    INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    // 10.06.21 HOT FIX
                    // ORG _MotorPositionDIGITAL = (long)((_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);
                    // Replace _DelaySetting_PS with _DelayRemainder_PS
                    _MotorPositionDIGITAL = (long)((_DelayRemainder_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);

                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                    // printf("FINAL _MotorPositionDIGITAL, Fcp, offset  = %lu , %6.2f, %6.2f \n", _MotorPositionDIGITAL, _DelaySetting_PS, _CalTableEntryOffsetAmount);

                    // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                    // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                }
                else
                {
                    // 10.21.21 MOVE TO THE FINAL POSITION WITH CALIBRTION TABLE NOT IN USE
                    INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    // ORG _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS); // 10.21.21 _DesiredMotorPos_MOD
                    // 10.21.21 MOVE TO THE DESIRED POSITION FOR THE REMAINDER PORTION OF THE TROMBONE
                    _MotorPositionDIGITAL = (long)(_DesiredMotorPos_MOD_F * MOTOR_STEPS_PER_ONE_PS); // 10.21.21 _DesiredMotorPos_MOD // 10.26.21 to _F
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // 10.21.21 THIS IS THE FINAL POSITION
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                }
            }
            else
            {
                // in PARALLEL MODE ...
                if (_DelaySetting_PS > 630.0)
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
                }
                else
                {
                    INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // signal that this is the last movement
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT // 02.02.21
                    _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS);
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                } // end-else <= 630.0
            }     // end DEVICE_PARALLEL
        }         // end - if delaysetting > 625000

        DISPLAY_SETTINGS.CURRENT_DELAY_F = _DelaySetting_PS;
        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS;

        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    }
    else
    {
        INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
        INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
    } // end else-if
      // } //end else-if

#endif
#endif
// END DEVICE_XT100

// 10.06.21 RD081621 BUILD
//  START DEVICE_XT100_312P --------------------------------------------------------------------------------------------------
#if defined(DEVICE_XT100_312P)

    // 04.20.18 DETERMINE IF MODE IS SERIAL OR PARALLEL. IF PARALLEL, DOUBLE THE INPUT
    // 04.20.18 INORDER TO GET THE RIGHT AMOUNT TO SEND TO THE MOTOR
    // 04.20.18 PARALLEL MODE IS ONLY FOR XT-100 INSTRUMENT ONLY

    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)
    {
        _DelaySetting_PS = _DelaySetting_PS * 2.00;
    }

    // 09.11.18 BUG-FIX - FORGOT TO BRING OVER THIS CODE FROM HW1VER1
    if ((_DelaySetting_PS > 0.0) && (_DelaySetting_PS <= 1.0E-06))
    {
        // SCIENTIFIC NOTATION!!
        _DelaySetting_PS = _DelaySetting_PS * 1.0E+12;
    }
    // 09.11.2018 NOW VERSION 2.01 WITH THIS BUG FIX
    // ORG _TempIntPS = (unsigned int) _DelaySetting_PS;
    // 06.15.18 handle MAX DELAY <= 65.535 and MAX DELAY > 65.535 NS

    // need to use unsigned long for > 65.535 ns because unsigned int has limit of 65535
    _TempULongPS = (unsigned long)(_DelaySetting_PS + 0.01);
    _Delta = _DelaySetting_PS - ((float)_TempULongPS);

    // handle if the last digit is a 9 e.g. xx.yyy9
    if (_Delta < -0.009)
    {
        _DelaySetting_PS = _DelaySetting_PS - 1;
        _Delta = _DelaySetting_PS - ((float)((unsigned long)(_DelaySetting_PS)));
        _TempULongPS = _TempULongPS - 1;
    } // in the case of XXX.99, _Delta is NEGATIVE so make it 0
    else
    {
        if (_Delta < 0)
        {
            _Delta = 0;
        }
    } // end-else

    // 06.05.18 use _TempULongFS instead of _TempUIntFS for delay > 65535
    // get the integer number of FS
    _FemtoSecondsPortion = (_Delta * 1000.0) + 0.10;
    if (_FemtoSecondsPortion < 1)
    {
        _TempUIntFS = 0;
    }
    else
    {
        _TempUIntFS = (unsigned int)_FemtoSecondsPortion;
    }

    // 04.30.18 TRUNCATE
    // 04.30.18 for different size CAL_TABLE
    // 06.01.18 for .50 entry on MT-100A, the value for _TempIntFS is 496
    // 06.01.18 for .25 entry on MT-100A, the value for _TempIntFS is 246
    // 06.01.18 therefore ROUND DOWN from 0 to 250 for ZERO and to 0.500 for all else

    switch (SIZE_CAL_TABLE)
    {
    case 1251:
        if (_TempUIntFS <= 246)
        {                    // was 499 then 496
            _TempUIntFS = 0; // round down to nearest .00 ps
        }
        else
        {
            _TempUIntFS = 500; // round down to nearest .50 ps
        }
        break;
    default:
        break;
    }

    // create the unsigned long integer of FS for total delay
    _DelaySetting_FS = (unsigned long)_TempULongPS;
    _DelaySetting_FS = _DelaySetting_FS * 1000;
    _TempUL = (unsigned long)_TempUIntFS;
    _DelaySetting_FS = _DelaySetting_FS + _TempUL;
    // 04.30.18 set _DelaySetting_PS to the truncated value
    _DelaySetting_PS = ((float)_TempULongPS) + (float)(_TempUIntFS / 1000.0);

    _OvershootAmount = (float)g_NVParameters.nv_overshoot_PS;

    // 02.22.2017 CHANGE CODE BELOW TO USE FEMTOSECONDS RESOLUTION RATHER THAN PICOSECONDS

    if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= PARAMETERS.deviceMAX_DELAY_PS))
    {
        INSTRUMENT.stateLAST_OperationChannelNumber = 1;
        // XT-100 : HANDLE 0 TO 625.0 IF ONLY TROMBONE (NO RELAYS)
        if ((((_DelaySetting_FS >= 0) && (_DelaySetting_FS < 625000))) ||
            ((_DelaySetting_FS == 625000) && (((strcmp(INSTRUMENT.deviceOPTION, "000") == 0) ||
                                               (strcmp(INSTRUMENT.deviceOPTION, "OEM") == 0) ||
                                               (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)))))
        {
            if ((g_NVParameters.nv_overshoot == TRUE) && (MOTOR.CurrentDelaySettingPS < _DelaySetting_PS))
            {
                // MOVE TO OVERSHOOT POSITION THEN MOVE TO THE FINAL DESIRED POSITION

                _FinalCP_DelaySetting_PS = _DelaySetting_PS;
                _DelaySettingPS_With_Overshoot = _DelaySetting_PS + _OvershootAmount;

                if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                {
                    // 04.30.18 // use a calibrated correction position
                    // 04.30.18 // determine the index to get the calibration offset
                    // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                    // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps

                    if (SIZE_CAL_TABLE == 1251)
                    {
                        // multiply _DelaySetting_PS by 10 (since calibration table fixes are at each 100 fs)
                        _CalTableDesiredDelayIndex = (int)(_FinalCP_DelaySetting_PS * 2);
                    }
                    else
                    {
                        _CalTableDesiredDelayIndex = 0;
                    }

                    // 02.03.21 IF THE INDEX IS ABOVE 1250 THEN USE 0 AS THE OFFSET
                    if (_CalTableDesiredDelayIndex <= 1250)
                    {
                        // NOTE: THE CALIBRATION TABLE ENTRY OFFSET IS IN FEMTOSECONDS UNITS, E.G. TABLE ENTRY OF -600 SHOULD BE == -0.60 ps
                        // THEREFORE DIVIDE BY 1000.0 TO GET PS UNITS
                        _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);
                    }
                    else
                    {
                        _CalTableEntryOffsetAmount = 0;
                    }

                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    //_MotorPositionDIGITAL = (unsigned long)((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                    _TEMP_f = ((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                    _MotorPositionDIGITAL = (long)_TEMP_f;

                    if (_MotorPositionDIGITAL > MAX_NUMBER_MOTOR_STEPS) // Final Calibrated Position + 8325 STEPS is beyond limit, then adjust amount
                    {
                        _MotorPositionDIGITAL = MAX_NUMBER_MOTOR_STEPS;
                    }
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS + (MOTOR_STEPS_PER_FIVE_PS / MOTOR_STEPS_PER_ONE_PS); // use a min of fix to reflect DESIRED delay setting
                    // printf("OVERSHOOT _MotorPositionDIGITAL, Fcp, Fcp offset = %lu, %6.2f, %6.2f \n", _MotorPositionDIGITAL, _FinalCP_DelaySetting_PS, _CalTableEntryOffsetAmount);
                }
                else
                {
                    // MOTOR_SetDelay(_DelaySetting_PS + _OvershootAmount); // add overshoot amount only (CAL TABLE NOT USED)
                    // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                    _MotorPositionDIGITAL = (long)(_DelaySettingPS_With_Overshoot * MOTOR_STEPS_PER_ONE_PS);
                    // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                    if (_MotorPositionDIGITAL < 0)
                        _MotorPositionDIGITAL = 0;
                    MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                    // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                    // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                    MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                    INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                }
            } // end-if

            // MOVE TO FINAL POSITION (AND CHECK FOR CALIBRATION TABLE ON/OFF)
            if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
            {
                // 04.30.18 // use a calibrated correction position
                // 04.30.18 // determine the index to get the calibration offset
                // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps
                if (SIZE_CAL_TABLE == 1251)
                {
                    _CalTableDesiredDelayIndex = (int)(_DelaySetting_PS * 2);
                }
                else
                {
                    _CalTableDesiredDelayIndex = 0;
                }

                _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);

                // MOTOR_SetDelay(_DelaySetting_PS - _CalTableEntryOffsetAmount );  // should be MINUS the Offset Amount (not PLUS) 02.03.18
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                _MotorPositionDIGITAL = (long)((_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);
                // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                if (_MotorPositionDIGITAL < 0)
                    _MotorPositionDIGITAL = 0;
                MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                // printf("FINAL _MotorPositionDIGITAL, Fcp, offset  = %lu , %6.2f, %6.2f \n", _MotorPositionDIGITAL, _DelaySetting_PS, _CalTableEntryOffsetAmount);

                // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
            }
            else
            {
                // MOTOR_SetDelay(_DelaySetting_PS);
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE; // SIGNAL THAT THIS IS THE LAST MOVEMENT
                // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS);
                // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                if (_MotorPositionDIGITAL < 0)
                    _MotorPositionDIGITAL = 0;
                MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
            }

        } // end-if

        DISPLAY_SETTINGS.CURRENT_DELAY_F = _DelaySetting_PS;
        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS;

        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    }
    else
    {
        // DELAY REQUESTED IS BEYOND RANGE OF THIS DEVICE
        INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
        INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
    } // end else-if

#endif
// END DEVICE_XT100_312P

// START DEVICE_XR100 ---------------------------------------------------------------------------------------------------------
#if defined(DEVICE_XR100)

#if defined(TFT_ATTACHED)
    // 05.24.22 CLEARING OUT THE TEXT FIELD IS NOT NEEDED
    // 05.26.22 DISPLAY THE CURRENT SETTING IN YELLOW BEFORE SETTING DELAY
    _ValueToDisplay_TFT = DISPLAY_SETTINGS.CURRENT_DELAY_F;
    SYSTEM_TFT_DISPLAY_FLOAT_IN_CH_TEXT(_ValueToDisplay_TFT, VIEWPORT_CH1, G_YELLOW);              // DISPLAY OF TEXT
    gcrectangle(CHX_BAR_X_UL - 1, CHX_BAR_Y_UL - 1, CHX_BAR_X_LR + 1, CHX_BAR_Y_LR + 1, G_YELLOW); // DISPLAY THE FRAME OF BAR

    // CLEAR THE BAR
    gsetcolorb(G_BLACK);
    gfillvp(CHX_BAR_X_UL, CHX_BAR_Y_UL, CHX_BAR_X_LR, CHX_BAR_Y_LR, 0x0000);
#endif

    delay_overflow = FALSE; // 04.19.18 start out as FALSE

    // 06.04.06 delay_setting contains the converted cmdARG2 value
    // e.g. DEL 50 ps ==> delay_setting should contain 50 (units of ps)
    // e.g. DEL 50.0E-12 ==> delay_setting should contain 50 (units of ps)
    // 06.04.06 DETERMINE WHETHER TO HANDLE cmdARG2 as DECIMAL OR SCIENTIFIC NOTATION

    if ((_DelaySetting_PS > 0.0) && (_DelaySetting_PS <= 1.0E-06))
    {
        // SCIENTIFIC NOTATION!!
        _DelaySetting_PS = _DelaySetting_PS * 1.0E+12;
    }

    // BUG FIX:
    //  06.17.05 VER 1.06
    delay_answer = _DelaySetting_PS - PARAMETERS.deviceMAX_DELAY_PS;

    // ORG      if ((delay_answer >= 0) && (delay_answer <= 0.001))
    // ORG         delay_setting = deviceMAX_DELAY_PS;
    // 06.20.06
    // this fixes the bug where delay_setting computes to being GREATER than
    // deviceMAX_DELAY_PS but really isn't because it is really 0.0019.... off.
    // e.g. specifying device limit of 20.460 ns doesnt work but is fixed now
    if ((delay_answer >= 0) && (delay_answer <= 0.5))
    {
        _DelaySetting_PS = PARAMETERS.deviceMAX_DELAY_PS;
    }

    if (_DelaySetting_PS > PARAMETERS.deviceMAX_DELAY_PS)
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
    }
    else
    {
        INSTRUMENT.stateLAST_OperationChannelNumber = 1;
        // _DelaySetting_PS is a float and has the picoseconds amount of desired delay
        // 04.19.18 all good ... continue
        delay_temp = _DelaySetting_PS / 1; // get just the integer portion
        if (delay_temp > 65535.0)
        {
            delay_overflow = TRUE;
            delay_temp = delay_temp - 65535.0;
        }
// 05.25.18 TEN_X IS USED WHEN DELAY RANGE IS > 65535 PS
#ifdef TEN_X
        if (delay_temp > 65535.0)
        {                            // for 131.070 to 196.605 NS
            delay_overflow_2 = TRUE; // record this overflow_2
            delay_temp = delay_temp - 65535.0;
        }
        if (delay_temp > 65535.0)
        {                            // for 196.605ns and up
            delay_overflow_3 = TRUE; // record this overflow_3
            delay_temp = delay_temp - 65535.0;
        }
#endif

        // following steps of code are used to ROUND down the desired delay to
        // nearest step size ...
        // determine just the INTEGER portion of the desired delay
        delay_int_only = (unsigned int)(delay_temp + 0.50f); // 06.21.21 proper way to convert positive float value to an integer

        // determine just the value to the RIGHT of the dec point, called truncated
        if (delay_overflow)
        {
            delay_trunc_f = _DelaySetting_PS - 65535.00 - delay_int_only;
// 05.25.18
#ifdef TEN_X
            // if there were overflows, then successively remove 65535
            if (delay_overflow_2)
            {
                delay_trunc_f = delay_trunc_f - 65535.00;
            }
            if (delay_overflow_3)
            {
                delay_trunc_f = delay_trunc_f - 65535.00;
            }
#endif
        }
        else
        {
            delay_trunc_f = _DelaySetting_PS - delay_int_only;
        }

        // delay_trunc_f has the TRUNCATED portion as a floating point variable
        // delay_trunc_i has the TRUNCATED portion as an unsigned integer variable
        delay_trunc_i = (unsigned int)((delay_trunc_f + 0.01) * 100.0);

        // 05.14.05 -- BECAUSE THIS IS A CPDL, then resolution is to the 1 ps
        // CANNOT SPECIFY A PS VALUE RESOLUTION LESS THAN 1 PS
        // THEREFORE MAKE THE TRUNCATED PART EQUAL TO ZERO !!
        delay_trunc_i = 0;

        // ROUND DOWN to nearest step size of XT-100 motor

        if ((delay_trunc_i >= 0) && (delay_trunc_i <= 24))
            _DelaySetting_PS = (float)delay_int_only; // .00 thru .24 rounds down

        if ((delay_trunc_i >= 25) && (delay_trunc_i <= 49))
        {
            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                _DelaySetting_PS = (float)delay_int_only; // .00 thru .24 rounds down
            else
                _DelaySetting_PS = delay_int_only + 0.25;
        } // end-if

        if ((delay_trunc_i >= 50) && (delay_trunc_i <= 74))
            _DelaySetting_PS = delay_int_only + 0.50;

        if ((delay_trunc_i >= 75) && (delay_trunc_i <= 99))
        {
            if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
            {
                _DelaySetting_PS = (float)(delay_int_only + 1); // round up
            }
            else
            {
                _DelaySetting_PS = delay_int_only + 0.75;
            }
        } // end-if

        if ((delay_trunc_i >= 100) || ((delay_trunc_f > 0.50) && (delay_trunc_f < 1.0))) // 05.14.05 added additional check to handle 99.999 ns
            _DelaySetting_PS = (float)delay_int_only + 1.0;

        // delay_setting now contains valid rounded down to nearest step size desired delay
        // if there is a delay_overflow (because # > 65536), then compensate

        if (delay_overflow)
            _DelaySetting_PS = _DelaySetting_PS + 65535.0;

// 05.25.18
#ifdef TEN_X
        // if there were overflows, then add them back into the total delay setting
        if (delay_overflow_2)
            _DelaySetting_PS = _DelaySetting_PS + 65535.0;
        if (delay_overflow_3)
            _DelaySetting_PS = _DelaySetting_PS + 65535.0;
#endif

        // 12-13-04
        DISPLAY_SETTINGS.CURRENT_DELAY_F = _DelaySetting_PS; // put value into CurrentDelay_F for display

        if (((INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL) && (_DelaySetting_PS > 625.0)) ||
            ((INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL) && (_DelaySetting_PS > PARAMETERS.deviceMAX_DELAY_PS)))
        {
            INSTRUMENT.stateERROR = TRUE;
            INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
            INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
        }
        else
        {
            // NOW SET THE DELAY TO THE DESIRED DELAY SETTING
            if (SYSTEM_DeviceSetDelayNoOVS(_DelaySetting_PS) == TRUE)
            { // set the delay!!
                INSTRUMENT.stateERROR = FALSE;
            } // end-if
            else
            {
                INSTRUMENT.stateERROR = TRUE;
                INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
            } // end else-if
            INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
        } // end-else-if
    }

#endif

// START DEVICE_XT200----------------------------------------------------------------------------------------------------------
#if defined(DEVICE_XT200)

#if defined(TFT_ATTACHED)
    // 05.24.22 CLEARING OUT THE TEXT FIELD IS NOT NEEDED
    // 05.26.22 DISPLAY THE CURRENT SETTING IN YELLOW BEFORE SETTING DELAY
    if ((INSTRUMENT.stateDEL_CHANNEL == CHANNEL_ONE) || (INSTRUMENT.stateDEL_CHANNEL == CHANNEL_BOTH))
    {
        _ValueToDisplay_TFT = INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F;
        SYSTEM_TFT_DISPLAY_FLOAT_IN_CH_TEXT(_ValueToDisplay_TFT, VIEWPORT_CH1, G_YELLOW);              // DISPLAY VALUE IN YELLOW
        gcrectangle(CHX_BAR_X_UL - 1, CHX_BAR_Y_UL - 1, CHX_BAR_X_LR + 1, CHX_BAR_Y_LR + 1, G_YELLOW); // DISPLAY YELLOW FRAME
    }

    if ((INSTRUMENT.stateDEL_CHANNEL == CHANNEL_TWO) || (INSTRUMENT.stateDEL_CHANNEL == CHANNEL_BOTH))
    {
        _ValueToDisplay_TFT = INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F;
        SYSTEM_TFT_DISPLAY_FLOAT_IN_CH_TEXT(_ValueToDisplay_TFT, VIEWPORT_CH2, G_YELLOW);              // DISPLAY VALUE IN YELLOW
        gcrectangle(CHX_BAR_X_UL - 1, CHX_BAR_Y_UL - 1, CHX_BAR_X_LR + 1, CHX_BAR_Y_LR + 1, G_YELLOW); // DISPLAY YELLOW FRAME
    }

    // 06.03.22 SET THE PROGRESS BAR INDICATOR DIRECTION AND LIMIT VALUES
    if (((_DelaySetting_PS)-INSTRUMENT_SETTINGS.CURRENT_DELAY) > 0)
    {
        INSTRUMENT.stateLESS_TO_MORE_DELAY_SETTING = TRUE;
#if defined(DEVICE_XT200_312P)
        INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int)(((INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 312.50) * CHX_BAR_W) + 0.50);
        INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int)(((_DelaySetting_PS / 312.50) * CHX_BAR_W) + 0.50);
#else
        INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int)(((INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 625.0) * CHX_BAR_W) + 0.50);
        INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int)(((_DelaySetting_PS / 625.0) * CHX_BAR_W) + 0.50);
#endif
    }
    else
    {
        INSTRUMENT.stateLESS_TO_MORE_DELAY_SETTING = FALSE;
#if defined(DEVICE_XT200_312P)
        INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int)(((_DelaySetting_PS / 312.50) * CHX_BAR_W) + 0.50);
        INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int)(((INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 312.50) * CHX_BAR_W) + 0.50);
#else
        INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT = (int)(((_DelaySetting_PS / 625.0) * CHX_BAR_W) + 0.50);
        INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT = (int)(((INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F / 625.0) * CHX_BAR_W) + 0.50);
#endif
    }
    _ProgressBarLow_Position = INSTRUMENT_SETTINGS.PROGRESS_BAR_LOW_LIMIT;
    _ProgressBarHigh_Position = INSTRUMENT_SETTINGS.PROGRESS_BAR_HIGH_LIMIT;

#endif

    // 04.20.18 DETERMINE IF MODE IS SERIAL OR PARALLEL. IF PARALLEL, DOUBLE THE INPUT
    // 04.20.18 INORDER TO GET THE RIGHT AMOUNT TO SEND TO THE MOTOR
    // 04.20.18 PARALLEL MODE IS ONLY FOR XT-100 INSTRUMENT ONLY
    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_PARALLEL)
    {
        _DelaySetting_PS = _DelaySetting_PS * 2.00;
    }

    // 09.11.2018 BUG-FIX - FORGOT TO BRING OVER THIS CODE FROM HW1VER1
    if ((_DelaySetting_PS > 0.0) && (_DelaySetting_PS <= 1.0E-06))
    {
        // SCIENTIFIC NOTATION!!
        _DelaySetting_PS = _DelaySetting_PS * 1.0E+12;
    }
    // 09.11.2018 NOW VERSION 2.01 WITH THIS BUG FIX
    // ORG _TempIntPS = (unsigned int) _DelaySetting_PS;
    // 06.15.18 handle MAX DELAY <= 65.535 and MAX DELAY > 65.535 NS
    // need to use unsigned long for > 65.535 ns because unsigned int has limit of 65535
    _TempULongPS = (unsigned long)(_DelaySetting_PS + 0.01);
    _Delta = _DelaySetting_PS - ((float)_TempULongPS);

    // handle if the last digit is a 9 e.g. xx.yyy9
    if (_Delta < -0.009)
    {
        _DelaySetting_PS = _DelaySetting_PS - 1;
        _Delta = _DelaySetting_PS - ((float)((unsigned long)(_DelaySetting_PS)));
        _TempULongPS = _TempULongPS - 1;
    } // in the case of XXX.99, _Delta is NEGATIVE so make it 0
    else
    {
        if (_Delta < 0)
        {
            _Delta = 0;
        }
    }

    // 06.05.18 use _TempULongFS instead of _TempUIntFS for delay > 65535
    // get the integer number of FS
    _FemtoSecondsPortion = (_Delta * 1000.0) + 0.10;
    if (_FemtoSecondsPortion < 1)
    {
        _TempUIntFS = 0;
    }
    else
    {
        _TempUIntFS = (unsigned int)_FemtoSecondsPortion;
    }

    // 04.30.18 TRUNCATE
    // 04.30.18 for different size CAL_TABLE
    // 06.01.18 for .50 entry on MT-100A, the value for _TempIntFS is 496
    // 06.01.18 for .25 entry on MT-100A, the value for _TempIntFS is 246
    // 06.01.18 therefore ROUND DOWN from 0 to 250 for ZERO and to 0.500 for all else

    switch (SIZE_CAL_TABLE)
    {
    case 1251:
        if (_TempUIntFS <= 246)
        {                    // was 499 then 496
            _TempUIntFS = 0; // round down to nearest .00 ps
        }
        else
        {
            _TempUIntFS = 500; // round down to nearest .50 ps
        }
        break;
    default:
        break;
    }

    // create the unsigned long integer of FS for total delay
    _DelaySetting_FS = (unsigned long)_TempULongPS;
    _DelaySetting_FS = _DelaySetting_FS * 1000;
    _TempUL = (unsigned long)_TempUIntFS;
    _DelaySetting_FS = _DelaySetting_FS + _TempUL;
    // 04.30.18 set _DelaySetting_PS to the truncated value
    _DelaySetting_PS = ((float)_TempULongPS) + (float)(_TempUIntFS / 1000.0);

    _OvershootAmount = (float)g_NVParameters.nv_overshoot_PS;

    // check if requested delay is in range of device AND is different from current delay
    if (_DelaySetting_PS <= PARAMETERS.deviceMAX_DELAY_PS)
    {
        switch (INSTRUMENT.stateDEL_CHANNEL)
        {
        case CHANNEL_ONE:
            INSTRUMENT.stateLAST_OperationChannelNumber = 1;
            // 01.03.19 HANDLE CHANNEL ONE - SET THE DELAY
            if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= PARAMETERS.deviceMAX_DELAY_PS))
            {
                if ((_DelaySetting_FS >= 0) && (_DelaySetting_FS <= 625000)) // added = sign to handle 625.0 ps
                {
                    if ((g_NVParameters.nv_overshoot == TRUE) && (MOTOR.CurrentDelaySettingPS < _DelaySetting_PS))
                    {
                        // MOVE TO OVERSHOOT POSITION THEN MOVE TO THE FINAL DESIRED POSITION

                        _FinalCP_DelaySetting_PS = _DelaySetting_PS;
                        _DelaySettingPS_With_Overshoot = _DelaySetting_PS + _OvershootAmount;

                        if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                        {
                            // 04.30.18 // use a calibrated correction position
                            // 04.30.18 // determine the index to get the calibration offset
                            // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                            // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps

                            if (SIZE_CAL_TABLE == 1251)
                            {
                                // multiply _DelaySetting_PS by 10 (since calibration table fixes are at each 100 fs)
                                _CalTableDesiredDelayIndex = (int)(_FinalCP_DelaySetting_PS * 2);
                            }
                            else
                            {
                                _CalTableDesiredDelayIndex = 0;
                            }

                            // 02.03.21 IF THE INDEX IS ABOVE 1250 THEN USE 0 AS THE OFFSET
                            if (_CalTableDesiredDelayIndex <= 1250)
                            {
                                // NOTE: THE CALIBRATION TABLE ENTRY OFFSET IS IN FEMTOSECONDS UNITS, E.G. TABLE ENTRY OF -600 SHOULD BE == -0.60 ps
                                // THEREFORE DIVIDE BY 1000.0 TO GET PS UNITS
                                _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);
                            }
                            else
                            {
                                _CalTableEntryOffsetAmount = 0;
                            }

                            // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                            //_MotorPositionDIGITAL = (long)((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                            _TEMP_f = ((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                            _MotorPositionDIGITAL = (unsigned long)_TEMP_f;
                            if (_MotorPositionDIGITAL > MAX_NUMBER_MOTOR_STEPS) // Final Calibrated Position + 8325 STEPS is beyond limit, then adjust amount
                            {
                                _MotorPositionDIGITAL = MAX_NUMBER_MOTOR_STEPS;
                            }
                            // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                            if (_MotorPositionDIGITAL < 0)
                                _MotorPositionDIGITAL = 0;
                            MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                            MOTOR.CurrentDelaySettingPS = _DelaySetting_PS + (MOTOR_STEPS_PER_FIVE_PS / MOTOR_STEPS_PER_ONE_PS); // use a min of fix to reflect DESIRED delay setting
                            // printf("OVERSHOOT _MotorPositionDIGITAL, Fcp, Fcp offset = %lu, %6.2f, %6.2f \n", _MotorPositionDIGITAL, _FinalCP_DelaySetting_PS, _CalTableEntryOffsetAmount);
                        }
                        else
                        {
                            // MOTOR_SetDelay(_DelaySetting_PS + _OvershootAmount); // add overshoot amount only (CAL TABLE NOT USED)
                            // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                            _MotorPositionDIGITAL = (long)(_DelaySettingPS_With_Overshoot * MOTOR_STEPS_PER_ONE_PS);
                            // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                            if (_MotorPositionDIGITAL < 0)
                                _MotorPositionDIGITAL = 0;
                            MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                            // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                            // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                            MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                            INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                        }
                    } // end-if

                    // MOVE TO FINAL POSITION (AND CHECK FOR CALIBRATION TABLE ON/OFF)
                    if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                    {
                        // 04.30.18 // use a calibrated correction position
                        // 04.30.18 // determine the index to get the calibration offset
                        // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                        // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps

                        if (SIZE_CAL_TABLE == 1251)
                        {
                            _CalTableDesiredDelayIndex = (int)(_DelaySetting_PS * 2);
                        }
                        else
                        {
                            _CalTableDesiredDelayIndex = 0;
                        }

                        _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);

                        // MOTOR_SetDelay(_DelaySetting_PS - _CalTableEntryOffsetAmount );  // should be MINUS the Offset Amount (not PLUS) 02.03.18
                        INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE;
                        // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT // 02.02.21
                        _MotorPositionDIGITAL = (long)((_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);
                        // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                        if (_MotorPositionDIGITAL < 0)
                            _MotorPositionDIGITAL = 0;
                        MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                        // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                        // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                        MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                    }
                    else
                    {
                        // MOTOR_SetDelay(_DelaySetting_PS);
                        INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE;
                        // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT // 02.02.21
                        _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS);
                        // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                        if (_MotorPositionDIGITAL < 0)
                            _MotorPositionDIGITAL = 0;
                        MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                        // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                        // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                        MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                    }

                    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                    {
                        // 04.28.21 NO RELAYS YET IN XT-100-SYSTEM BOARD
                        // relaySetRelay(0x0000); // turn off all relays
                        for (_j = 1; _j <= 16; _j++)
                        {
                            HW_RELAYS.RELAY_ON_OFF[_j] = OFF;
                        } // end-for
                    }     // end-if DEVICE_SERIAL
                }         // end-if < 625000

                // --------------------------------------------------------------------------------------------------------------------
                // --------------------------------------------------------------------------------------------------------------------

                DISPLAY_SETTINGS.CURRENT_DELAY_F = _DelaySetting_PS;
                INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS;

#ifdef PRIMARY_TROMBONE
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS = _DelaySetting_PS * 0.50;
                INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = _DelaySetting_PS * 0.50;
#else
                INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS = _DelaySetting_PS;
                INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = _DelaySetting_PS;
#endif
#endif

                INSTRUMENT.stateERROR = FALSE;
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            } // end-if delay setting <= MAX DELAY
            else
            {
                // ERROR ... Delay Setting specified is beyond limit
                INSTRUMENT.stateERROR = TRUE;
                INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
            }

            break;

        case CHANNEL_TWO:
            INSTRUMENT.stateLAST_OperationChannelNumber = 2;
// 01.27.22 IF IN DEVICE_MODE == PARALLEL, (SECONDARY IS ALWAYS 0 TO 625PS), CHANGE THE COMPARISON DELAY SETTING
#ifdef DEVICE_XT200_312P
            if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= 625.0) && (_DelaySetting_PS != (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS / 2.0)))
#else
            if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= 625.0) && (_DelaySetting_PS != INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS))
#endif
            {
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE;
                delay_set_SEC = _DelaySetting_PS;
                if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = SYSTEM_SetDelaySecTrombone(delay_set_SEC)) != -1)
                { // SET THE TROMBONE PORTION
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
                    // 08.15.22
                    INSTRUMENT.stateOPERATION_COMPLETE = TRUE; // SINCE THIS IS A SECONDARY TROMBONE AND CANT RECEIVE ON SER PORT B

// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = _DelaySetting_PS * 0.50;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = _DelaySetting_PS * 0.50;
#else
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = _DelaySetting_PS;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = _DelaySetting_PS;
#endif
                } // end-if
                else
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
            }
            else
            {
                // requested delay setting is the same as current one //07.21.08
                INSTRUMENT.stateERROR_CODE = NO_ERROR;
            }
            break;
        case CHANNEL_BOTH:
            INSTRUMENT.stateLAST_OperationChannelNumber = 2;
// 01.03.19 HANDLE CHANNEL TWO (SECONDARY TROMBONE)
// 01.25.22 IF IN DEVICE_MODE == PARALLEL, (SECONDARY IS ALWAYS 0 TO 625PS), CHANGE THE COMPARISON DELAY SETTING
#ifdef DEVICE_XT200_312P
            if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= 625.0) && (_DelaySetting_PS != (INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS / 2.0)))
#else
            if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= 625.0) && (_DelaySetting_PS != INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS))
#endif
            {
                INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE;
                delay_set_SEC = _DelaySetting_PS;
                if ((INSTRUMENT_SETTINGS.CURRENT_DELAY = SYSTEM_SetDelaySecTrombone(delay_set_SEC)) != -1)
                { // SET THE TROMBONE PORTION
                    INSTRUMENT.stateERROR_CODE = NO_ERROR;
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = _DelaySetting_PS * 0.50;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = _DelaySetting_PS * 0.50;
#else
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_PS = _DelaySetting_PS;
                    INSTRUMENT_SETTINGS.CURRENT_DELAY_TWO_F = _DelaySetting_PS;
#endif
                } // end-if
                else
                {
                    INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
                }
            } // stateDEL_CHANNEL == 2

            // 01.03.19 HANDLE CHANNEL ONE - SET THE DELAY
            if ((_DelaySetting_PS >= 0.0) && (_DelaySetting_PS <= PARAMETERS.deviceMAX_DELAY_PS))
            {
                if ((_DelaySetting_FS >= 0) && (_DelaySetting_FS <= 625000)) // 05.28.21 added = to handle = 625.0 ps in new motor leadscrew
                {
                    if ((g_NVParameters.nv_overshoot == TRUE) && (MOTOR.CurrentDelaySettingPS < _DelaySetting_PS))
                    {
                        // MOVE TO OVERSHOOT POSITION THEN MOVE TO THE FINAL DESIRED POSITION
                        _FinalCP_DelaySetting_PS = _DelaySetting_PS;
                        if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                        {
                            // 04.30.18 // use a calibrated correction position
                            // 04.30.18 // determine the index to get the calibration offset
                            // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                            // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps

                            if (SIZE_CAL_TABLE == 1251)
                            {
                                // multiply _DelaySetting_PS by 10 (since calibration table fixes are at each 100 fs)
                                _CalTableDesiredDelayIndex = (int)(_FinalCP_DelaySetting_PS * 2);
                            }
                            else
                            {
                                _CalTableDesiredDelayIndex = 0;
                            }

                            // 02.03.21 IF THE INDEX IS ABOVE 1250 THEN USE 0 AS THE OFFSET
                            if (_CalTableDesiredDelayIndex <= 1250)
                            {
                                // NOTE: THE CALIBRATION TABLE ENTRY OFFSET IS IN FEMTOSECONDS UNITS, E.G. TABLE ENTRY OF -600 SHOULD BE == -0.60 ps
                                // THEREFORE DIVIDE BY 1000.0 TO GET PS UNITS
                                _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);
                            }
                            else
                            {
                                _CalTableEntryOffsetAmount = 0;
                            }

                            // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                            //_MotorPositionDIGITAL = (long)((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                            _TEMP_f = ((_FinalCP_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS) + MOTOR_STEPS_PER_FIVE_PS;
                            _MotorPositionDIGITAL = (long)_TEMP_f;
                            if (_MotorPositionDIGITAL > MAX_NUMBER_MOTOR_STEPS) // Final Calibrated Position + 8325 STEPS is beyond limit, then adjust amount
                            {
                                _MotorPositionDIGITAL = MAX_NUMBER_MOTOR_STEPS;
                            }
                            // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                            if (_MotorPositionDIGITAL < 0)
                                _MotorPositionDIGITAL = 0;
                            MOTOR_SetDelayDigital(_MotorPositionDIGITAL);
                            MOTOR.CurrentDelaySettingPS = _DelaySetting_PS + (MOTOR_STEPS_PER_FIVE_PS / MOTOR_STEPS_PER_ONE_PS); // use a min of fix to reflect DESIRED delay setting
                            // printf("OVERSHOOT _MotorPositionDIGITAL, Fcp, Fcp offset = %lu, %6.2f, %6.2f \n", _MotorPositionDIGITAL, _FinalCP_DelaySetting_PS, _CalTableEntryOffsetAmount);
                        }
                        else
                        {
                            // MOTOR_SetDelay(_DelaySetting_PS + _OvershootAmount); // add overshoot amount only (CAL TABLE NOT USED)
                            // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT
                            // 05.20.22 MOVE TO THE OVERSHOOT POSITION BUT WITH NO CALIBRATION TABLE FIX
                            // 05.20.22 BUG: _DelaySettingPS_With_Overshoot IS INVALID IN THIS LINE OF CODE:
                            // ORG: _MotorPositionDIGITAL = (long)(_DelaySettingPS_With_Overshoot * MOTOR_STEPS_PER_ONE_PS);

                            // 05.23.22	// OVERSHOOT SHOULD NEVER BE LESS THAN 0 (UNLESS RE-USED FLASH IS CORRUPTED)
                            if (_OvershootAmount < 0)
                                _OvershootAmount = 5.0;
                            _MotorPositionDIGITAL = (long)(((_DelaySetting_PS) + _OvershootAmount) * MOTOR_STEPS_PER_ONE_PS);
                            // 05.20.22 NOTE: SHOULD REPLACE 5.0 ABOVE WITH ACTUAL OVERSHOOT AMOUNT

                            // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                            if (_MotorPositionDIGITAL < 0)
                                _MotorPositionDIGITAL = 0;
                            MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                            // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                            // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                            MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                            INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                        }

                    } // end-if

                    // MOVE TO FINAL POSITION (AND CHECK FOR CALIBRATION TABLE ON/OFF)
                    if (GLOBAL_SETTINGS.USE_CAL_TABLE == TRUE)
                    {
                        // 04.30.18 // use a calibrated correction position
                        // 04.30.18 // determine the index to get the calibration offset
                        // 04.30.18 // if SIZE_CAL_TABLE == 1251 then calibration offsets are at 0.500 ps steps
                        // 04.30.18 // if SIZE_CAL_TABLE == 6251 then calibration offsets are at 0.100 ps steps

                        if (SIZE_CAL_TABLE == 1251)
                        {
                            _CalTableDesiredDelayIndex = (int)(_DelaySetting_PS * 2);
                        }
                        else
                        {
                            _CalTableDesiredDelayIndex = 0;
                        }
                        _CalTableEntryOffsetAmount = (float)(g_NVParameters.nv_cal_table[_CalTableDesiredDelayIndex] / 1000.0);

                        // MOTOR_SetDelay(_DelaySetting_PS - _CalTableEntryOffsetAmount );  // should be MINUS the Offset Amount (not PLUS) 02.03.18
                        INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE;
                        // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT // 02.02.21
                        _MotorPositionDIGITAL = (long)((_DelaySetting_PS - _CalTableEntryOffsetAmount) * MOTOR_STEPS_PER_ONE_PS);
                        // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                        if (_MotorPositionDIGITAL < 0)
                            _MotorPositionDIGITAL = 0;
                        MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                        // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                        // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                        MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                    }
                    else
                    {
                        // MOTOR_SetDelay(_DelaySetting_PS);
                        INSTRUMENT.stateMOTOR_MOVE_CHECK_OPC = TRUE;
                        // COMPUTE THE NEW DESIRED POSITION IN DIGITAL INT // 02.02.21
                        _MotorPositionDIGITAL = (long)(_DelaySetting_PS * MOTOR_STEPS_PER_ONE_PS);
                        // 07.21.21 IF CALC POSITION IS NEG, MAKE IT ZERO
                        if (_MotorPositionDIGITAL < 0)
                            _MotorPositionDIGITAL = 0;
                        MOTOR_SetDelayDigital(_MotorPositionDIGITAL);

                        // if using the CAL TABLE, then INSTRUMENT_SETTINGS.CurrentDelay AND MOTOR.CurrentDelaySettingPS
                        // SHOULD be the _DelaySetting_PS value rather than the ACTUAL included CALIBRATION OFFSET amount
                        MOTOR.CurrentDelaySettingPS = _DelaySetting_PS;       // fix to reflect DESIRED delay setting
                        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS; // 02.07.08
                    }

                    if (INSTRUMENT.stateDEVICE_MODE == DEVICE_SERIAL)
                    {
                        // 04.28.21 NO RELAYS YET IN XT-100-SYSTEM BOARD
                        // relaySetRelay(0x0000); // turn off all relays
                        for (_j = 1; _j <= 16; _j++)
                        {
                            HW_RELAYS.RELAY_ON_OFF[_j] = OFF;
                        } // end-for
                    }     // end-if DEVICE_SERIAL
                }         // end-if < 625000

                // --------------------------------------------------------------------------------------------------------------------

                INSTRUMENT.stateERROR_CODE = NO_ERROR;
// 11.11.21 BUILD2112_RD102121_RD111121
#ifdef DEVICE_XT200_312P
                INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_PS = _DelaySetting_PS * 0.50;
                INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = _DelaySetting_PS * 0.50;
#else
                INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = _DelaySetting_PS;
                INSTRUMENT_SETTINGS.CURRENT_DELAY_ONE_F = _DelaySetting_PS;
#endif
            } // end-if delay setting <= delay Max // 01.03.19  CHANNEL_BOTH:
            break;

        default:
            break;
        } // end-switch
    }     // end else-if
    else
    {
        // ERROR ... Delay Setting specified is beyond limit
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = DELAY_NOT_SET;
    }

#endif

// 04.25.22 START DEVICE_XS100 ------------------------------------------------------------------------------------------------
#if defined(DEVICE_XS100)

    // 04.25.22 CODE FROM PDM-100A cmdSET_DELAY:

    if (_DelaySetting_PS <= PARAMETERS.deviceMAX_DELAY_PS)
    {
        // unsigned long _Temp, _Temp2;
        _Temp = (unsigned long)_DelaySetting_PS;
        _Temp2 = (unsigned long)PARAMETERS.deviceMAX_DELAY_PS;

        // Cycle through each of the PIN DIODE delay sections from 16 to 1 and
        // use sucessive subtraction to determine which PIN diodes to turn off or on
        // EXCEPT in the case where the total delay does not align on an even boundary of smallest resolution step sizes.
        // In that instance, g_LAST_RELAY_SECTION_ODD is set to TRUE
        // if g_LAST_RELAY_SECTION_ODD is TRUE, then handle delay settings with call to relaySetupRelays(delay_setting) for
        // all delay settings UP TO the sum of all the sections (except for the last section).

        // for PDM-100A CALL SetPIN_diodes...
        // 04.05.06 always use SetPIN_diodesX because it's OK to use the LAST section because it is ALWAYS AN EVEN SECTION

        // 11.05.10 increase the count of # of delay settings recorded
        GLOBAL_SETTINGS.XS_SW_DEL_SET_COUNT++; // as a counter used in SWEEP MODE

        // 04.25.22     float _DelayRemainder_PS;
        _DelayRemainder_PS = XSPDM_SET_PD_COMPUTE(_DelaySetting_PS); // SET PD BY COMPUTE (SUCCESSIVE SUBTRACTION METHOD)
		// NOTE: 8 PS SECTION IGNORED IN SUCCESSIVE SUBTRACTION

// 08.19.22 FOR DEVICE_XS100_005N
#if defined(DEVICE_XS100_005N)
        DISPLAY_SETTINGS.CURRENT_DELAY_F = _DelaySetting_PS;
        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS;
#endif

// 08.19.22 FOR DEVICE_XS100_010N THERE MIGHT BE A REMAINDER BECAUSE STEP SIZE IS 5 PS
#if defined(DEVICE_XS100_010N)
        DISPLAY_SETTINGS.CURRENT_DELAY_F = _DelaySetting_PS - _DelayRemainder_PS;
        INSTRUMENT_SETTINGS.CURRENT_DELAY = _DelaySetting_PS - _DelayRemainder_PS;
#endif

        INSTRUMENT.stateOPERATION_COMPLETE = TRUE;
        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    }
    else
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = DELAY_LIMIT;
        INSTRUMENT.stateOPERATION_COMPLETE = TRUE;

    } // endif

#endif

    return; // ALL DONE -- RETURN //

} // END cmdSET_DELAY FUNCTION

float computeMOD_F(float _Argument)
{
    //
    // FUNCTION TO REPLACE MODULO INT
    // SUCCESSIVELY SUBTRACT 625 AND RETURN THE REMAINDER
    //

    float _SuccessiveSum;
    int _Done;
    int _TEMP_I;
    float _TEMP_F;

    _Done = FALSE;
    if (_Argument < 0)
    {
        return 0; // RETURN 0 EVEN IF ARG IS NEG
    }
    else if (_Argument < 625.0)
    {
        return _Argument;
    }

    _SuccessiveSum = _Argument;
    _Done = FALSE;

    while (_Done == FALSE)
    {
        _SuccessiveSum = _SuccessiveSum - 625.0;
        if (_SuccessiveSum == 0)
        {
            return _SuccessiveSum;
        }
        else if (_SuccessiveSum < 625)
        {
            _Done = TRUE;
        }
    } // end while

    // ROUND THE RESOLUTION TO THE NEAREST HALF PS
    _TEMP_I = (int)_SuccessiveSum;

    _TEMP_F = (_SuccessiveSum - _TEMP_I) * 10.0;
    if (_TEMP_F <= 4)
    {
        _SuccessiveSum = _TEMP_I;
    }
    else
    {
        _SuccessiveSum = (float)(_TEMP_I + 0.50);
    }
    return _SuccessiveSum;
}

void cmdTERM(void)
{
    //
    // Description:   Sets the RS-232 PORT TO TERMINAL MODE ON or TRUE (FOR PUTTY OR TELNET ATTACHED)
    //                Sets the RS-232 PORT TO TERMINAL MODE OFF OR FALSE (FOR MT100A ATTACHED)
    // 11.19.21		  and stores settings into NVRAM
    //

    if ((strcmp(cmdARG2, "OFF") == 0) || (strcmp(cmdARG2, "off") == 0) || (strcmp(cmdARG2, "0") == 0))
    {
        INSTRUMENT.stateDEVICE_MODE_MT100A = TRUE; // MT-100A MODE to ON
        g_NVParameters.nv_terminal_mode = FALSE;   // TERMINAL MODE OFF
        SYSTEM_SaveNVParametersXT();
        INSTRUMENT.stateERROR_CODE = NO_ERROR;
    }
    else
    {
        if ((strcmp(cmdARG2, "ON") == 0) || (strcmp(cmdARG2, "on") == 0) || (strcmp(cmdARG2, "1") == 0))
        {
            INSTRUMENT.stateDEVICE_MODE_MT100A = FALSE; // set MT-100A MODE to OFF
            g_NVParameters.nv_terminal_mode = TRUE;     // means RS-232 in terminal_mode; NOT MT-100A mode
            SYSTEM_SaveNVParametersXT();
            INSTRUMENT.stateERROR_CODE = NO_ERROR;
        }
        else
        {
            INSTRUMENT.stateERROR_CODE = INVALID_ARG;
        }
    }
} // cmdTERM

void cmdTERMQ(void)
{
    //
    // Description:   Returns the state of the TERMINAL MODE
    //

    if (INSTRUMENT.stateDEVICE_MODE_MT100A == TRUE) // IF MT-100A IS ATTACHED, THEN TERM MODE IS FALSE
    {
        sprintf(BUFFERS.DISPLAY_LINE, "OFF\r\n");
    } // end-if
    else
    {
        sprintf(BUFFERS.DISPLAY_LINE, "ON\r\n"); // IF MT-100A IS NOT ATTACHED, THEN TERM MODE IS TRUE
    }                                            // end-else-if
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR; // CLEAR THIS OUT FOR NEXT TIME

} // cmdTERMQ

void cmdMEMSTORE(void)
{
#ifdef DEVICE_XR100
    // cmdARG1 has the MEM command
    // cmdARG2 has the storage location
    // cmdARG3 has the balance

    int _lenARG1, _lenARG2, _lenARG3;
    int _NumItemsProcessed;
    char _Command[10];
    int _StartIndex;
    unsigned long _InputArray[17];
    unsigned long _ProcessedArray[17][2];
    int _IndexPointer;
    int _i;
    unsigned long _ul, _fff;
    float _TempF;
    unsigned int _RelayPattern;

    _RelayPattern = 0; // contains the relay pattern for each delay setting
    _NumItemsProcessed = 0;
    _StartIndex = 0;
    _IndexPointer = 0;

    _lenARG1 = strlen(cmdARG1); // has the command "MEM"
    _lenARG2 = strlen(cmdARG2); // has the starting index
    _lenARG3 = strlen(cmdARG3); // has all the comma separated data (up to to values)

    // _NumItemsProcessed = sscanf(cmdARG2,"%i",&_Index);

    // if ((_NumItemsProcessed != 1) || (_Index < 0) || (_Index >= MAX_NUM_MEM_ARRAY_ITEMS))
    //{
    //     INSTRUMENT.stateERROR_CODE = INVALID_ARG;
    //     return;
    // }

    // BUFFERS.INPUT_COMMAND_LINE
    //
    // _NumItemsProcessed = sscanf(BUFFERS.INPUT_COMMAND_LINE,"%s %i %f,%f,%f,%f,%f,%f,%f,%f,%f,%f",
    //		_Command,&_StartIndex,

    _NumItemsProcessed = sscanf(BUFFERS.INPUT_COMMAND_LINE, "%s %i %lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu",
                                _Command, &_StartIndex,
                                &_InputArray[0], &_InputArray[1], &_InputArray[2], &_InputArray[3], &_InputArray[4],
                                &_InputArray[5], &_InputArray[6], &_InputArray[7], &_InputArray[8], &_InputArray[9],
                                &_InputArray[10], &_InputArray[11], &_InputArray[12], &_InputArray[13], &_InputArray[14],
                                &_InputArray[15]);

    // Check _StartIndex is valid and number of items to process is >0.
    _NumItemsProcessed -= 2; // subtract count for command and startindex values

    if (_NumItemsProcessed > 16)
        _NumItemsProcessed = 16; // set the maximum number of items to process at 16

    if ((_NumItemsProcessed) > 0)
    {
        if ((_StartIndex < 0) || (_StartIndex >= MAX_NUM_MEM_ARRAY_ITEMS))
        {
            INSTRUMENT.stateERROR = TRUE;
            INSTRUMENT.stateERROR_CODE = INVALID_ARG;
            return;
        }

        for (_i = 0; _i < (_NumItemsProcessed); _i++)
        {
            _ul = (unsigned long)_InputArray[_i];
            _TempF = (_InputArray[_i] - _ul) * 100.0;
            // printf("_InputArray[%i] = %f ",i,_InputArray[i]);
            // printf("_TempF %f ",_TempF);

            if (_TempF <= 37.50)
            {
                // printf(".00 \r\n");
                _fff = 0;
            }
            else
            {
                // printf(".50 \r\n");
                _fff = 500;
            }

            _ProcessedArray[_i][0] = _ul;
            _ProcessedArray[_i][1] = _fff;
            // printf ("ps = %6u fff = %3u \r\n", _ProcessedArray[_i][0], _ProcessedArray[_i][1]);

            // 11.23.21 WITH _ul AND SUCCESSIVE SUBTRACTION, DETERMINE THE RELAY SETTINGS PATTERN FOR THE GIVEN VALUE

            _RelayPattern = _DetermineRelayPattern(_ul);

            _IndexPointer = _StartIndex + _i; // location in memory array to store values

            if (_IndexPointer < MAX_NUM_MEM_ARRAY_ITEMS)
            {

                MEMORY_ARRAY.ITEM[_IndexPointer] = _RelayPattern;

                // MEMORY_ARRAY.ITEM[_IndexPointer][0] = _ul;
                // MEMORY_ARRAY.ITEM[_IndexPointer][1] = _fff;
                //  printf ("ps = %6u fff = %3u \r\n", MEMORY_ARRAY.ITEM[_IndexPointer][0],
                //	MEMORY_ARRAY.ITEM[_IndexPointer][1]);
            }
        }
        INSTRUMENT.stateERROR = FALSE;
        INSTRUMENT.stateERROR_CODE = NONE;
    }
    else
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG;
    }
#endif
} // cmdMEMSTORE

void cmdMEMQ(void)
{
#ifdef DEVICE_XR100
    //
    // MEM? index count
    //
    // returns up to ten values starting at index
    //

    int _lenARG1, _lenARG2, _lenARG3;
    int _IndexPointerValue;
    int _NumItemsProcessed;
    int _ItemCount, _i;
    char _Answer[MAX_NUM_MEM_ARRAY_ITEMS * 8];
    char _EachItem[20];
    char _Comma[5];
    char _CRLF[5];

    _ItemCount = 0;
    _lenARG1 = strlen(cmdARG1); // has the command "MEM?"
    _lenARG2 = strlen(cmdARG2); // has the POINTER INDEX VALUE
    _lenARG3 = strlen(cmdARG3); // has the count or number of items to report

    memset(_Answer, 0x00, sizeof(_Answer));
    memset(_EachItem, 0x00, sizeof(_EachItem));

    strcpy(_Comma, ",");
    strcpy(_CRLF, "\r\n");

    _NumItemsProcessed = sscanf(cmdARG2, "%i", &_IndexPointerValue);

    if ((_IndexPointerValue < 0) || (_IndexPointerValue > MAX_NUM_MEM_ARRAY_ITEMS))
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
        return;
    }

    _NumItemsProcessed = sscanf(cmdARG3, "%i", &_ItemCount);

    if (_NumItemsProcessed == -1)
    {
        _ItemCount = 1; // default number of items to return
    }

    // PRINT OUT _ItemCount VALUES STARTING AT INDEX _IndexPointerValue

    for (_i = _IndexPointerValue; _i < (_IndexPointerValue + _ItemCount); _i++)
    {
        if (_i >= MAX_NUM_MEM_ARRAY_ITEMS)
        {
            break; // we're done!!
        }

        sprintf(_EachItem, "0x%04X", MEMORY_ARRAY.ITEM[_i]);
        strcat(_Answer, _EachItem);
        if ((_i != MAX_NUM_MEM_ARRAY_ITEMS - 1) && (_i != ((_IndexPointerValue + _ItemCount) - 1)))
            strcat(_Answer, _Comma);
    }

    // _Answer has all the items.  Add a CRLF to end.
    strcat(_Answer, _CRLF);
    strcpy(BUFFERS.DISPLAY_LINE, _Answer);
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = NONE;
#endif
}
void cmdMEMPTR(void)
{
#ifdef DEVICE_XR100
    // MEMPTR index
    // sets the MEMORY_ARRAY[] INDEX POINTER TO A VALUE BETWEEN 0 AND MAX_NUM_MEM_ARRAY_ITEMS

    float Step;
    float AbsStep;
    int _lenARG1, _lenARG2;
    int _IndexPointerValue;
    int _NumItemsProcessed;

    _lenARG1 = strlen(cmdARG1); // has the command "MEMPTR"
    _lenARG2 = strlen(cmdARG2); // has the POINTER INDEX VALUE

    _NumItemsProcessed = sscanf(cmdARG2, "%i", &_IndexPointerValue);

    if ((_NumItemsProcessed != 1) || (_IndexPointerValue < 0) || (_IndexPointerValue >= MAX_NUM_MEM_ARRAY_ITEMS))
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
        return;
    }

    GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX = _IndexPointerValue;

#endif
} // end cmdMEMPTR

void cmdMEMPTRQ(void)
{
#ifdef DEVICE_XR100

    //
    // QUERY THE MEMPTR index
    //

    sprintf(BUFFERS.DISPLAY_LINE, "%i\r\n", GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX);
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR;

#endif
} // end cmdMEMPTRQ

void cmdMEMWRAP(void)
{
#ifdef DEVICE_XR100
    //
    // MEMPTR index
    // sets the MEMORY_ARRAY_WRAP_AT_END FLAG TO TRUE ON OR 0 OFF
    //
    float Step;
    float AbsStep;
    int _lenARG1, _lenARG2;
    int _IndexPointerValue;
    int _NumItemsProcessed;
    char _Argument[10];

    _lenARG1 = strlen(cmdARG1); // has the command "MEMPTR"
    _lenARG2 = strlen(cmdARG2); // has the POINTER INDEX VALUE

    _NumItemsProcessed = sscanf(cmdARG2, "%s", _Argument);

    if (_NumItemsProcessed != 1)
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
        return;
    }

    if ((strcmp(_Argument, "TRUE") == 0) || (strcmp(_Argument, "ON") == 0) || (strcmp(_Argument, "1") == 0))
    {
        GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP = TRUE;
    }
    else if ((strcmp(_Argument, "FALSE") == 0) || (strcmp(_Argument, "OFF") == 0) || (strcmp(_Argument, "0") == 0))
    {
        GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP = FALSE;
    }
    else
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
        return;
    }

    INSTRUMENT.stateERROR = FALSE;
    INSTRUMENT.stateERROR_CODE = NONE;
    return;
#endif
} // end cmdMEMPTRWRAP

void cmdMEMWRAPQ(void)
{
#ifdef DEVICE_XR100
    //
    // QUERY THE MEMPTR WRAP FLAG
    //
    if (GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP == 1)
    {
        sprintf(BUFFERS.DISPLAY_LINE, "ON\r\n");
    }
    else
    {
        sprintf(BUFFERS.DISPLAY_LINE, "OFF\r\n");
    }
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR;
#endif
} // end cmdMEMWRAPQ

void cmdTRIGGER(void)
{
#ifdef DEVICE_XR100
    //
    // TRIGGER index
    // executes the current pointer to MEMORY_ARRAY[index] specified delay setting
    // and then increments the index pointer

    // Get the setting
    HW_RELAYS.SETTINGS = MEMORY_ARRAY.ITEM[GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX];
    // Set the new relay settings
    HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS);

    GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX += 1;
    if (GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX > GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP_INDEX)
    {
        if (GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP == TRUE)
        {
            GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX = 0; // ROLLOVER WRAP AT ZERO
        }
        else
        {
            // NO WRAP AT LIMIT SO LEAVE INDEX AT MAX-1 INDEX POSITION
            GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX = GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP_INDEX;
        }
    }

#endif
} // cmdTRIGGER

void cmdTRIGGERQ(void)
{
#ifdef DEVICE_XR100
    //
    // SET THE TRIGGER index
    // executes the current pointer to MEMORY_ARRAY[index] specified delay setting
    // and then increments the index pointer and replies with index pointer just set
    //
    // Get the setting
    HW_RELAYS.SETTINGS = MEMORY_ARRAY.ITEM[GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX];
    // Set the new relay settings
    HWIO_REL_SetRelays_X_SER(HW_RELAYS.SETTINGS);

    GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX += 1;
    if (GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX > GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP_INDEX)
    {
        if (GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP == TRUE)
        {
            GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX = 0; // ROLLOVER WRAP AT ZERO
        }
        else
        {
            // NO WRAP AT LIMIT SO LEAVE INDEX AT MAX-1 INDEX POSITION
            GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX = GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP_INDEX;
        }
    }

    // REPLY WITH THE CURRENT POINTER INDEX... ADD REPLY WITH REL SETTINGS?
    sprintf(BUFFERS.DISPLAY_LINE, "%i\r\n", GLOBAL_SETTINGS.MEMORY_ARRAY_PTR_INDEX);
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR;

#endif
} // cmdTRIGGERQ

void cmdMEMPTRW(void)
{
#ifdef DEVICE_XR100
    //
    // MEMPTRW index
    // sets the MEMORY_ARRAY[] WRAP INDEX TO A VALUE BETWEEN 0 AND MAX_NUM_MEM_ARRAY_ITEMS-1

    float Step;
    float AbsStep;
    int _lenARG1, _lenARG2;
    int _IndexPointerValue;
    int _NumItemsProcessed;

    _lenARG1 = strlen(cmdARG1); // has the command "MEMPTRW"
    _lenARG2 = strlen(cmdARG2); // has the POINTER INDEX VALUE

    _NumItemsProcessed = sscanf(cmdARG2, "%i", &_IndexPointerValue);

    if ((_NumItemsProcessed != 1) || (_IndexPointerValue < 0) || (_IndexPointerValue >= MAX_NUM_MEM_ARRAY_ITEMS))
    {
        INSTRUMENT.stateERROR = TRUE;
        INSTRUMENT.stateERROR_CODE = INVALID_ARG; // invalid argument
        return;
    }

    GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP_INDEX = _IndexPointerValue;

#endif
}

void cmdMEMPTRWQ(void)
{
#ifdef DEVICE_XR100

    //
    // QUERY THE MEMPTRW index
    //

    sprintf(BUFFERS.DISPLAY_LINE, "%i\r\n", GLOBAL_SETTINGS.MEMORY_ARRAY_WRAP_INDEX);
    SYSTEM_OutputQueryResponse();
    INSTRUMENT.stateERROR_CODE = NO_ERROR;

#endif
}

/*** BeginHeader */
#endif //#define X_SER_COMMANDS_LIB
       /*** EndHeader */